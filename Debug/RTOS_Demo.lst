
RTOS_Demo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002e80  10001000  10001000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .VENEER_Code  00000144  2000000c  10003e80  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000400  20000150  00000000  00000150  2**0
                  ALLOC
  3 .data         00000018  20000550  10003fc4  00008550  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000028c0  20000568  00000418  00008568  2**2
                  ALLOC
  5 .no_init      00000004  20003ffc  00003eac  00000150  2**2
                  ALLOC
  6 .debug_aranges 00000b70  00000000  00000000  00008568  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000bed0  00000000  00000000  000090d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002148  00000000  00000000  00014fa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00005d01  00000000  00000000  000170f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000264c  00000000  00000000  0001cdf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00006e6f  00000000  00000000  0001f440  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003df3  00000000  00000000  000262af  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000009f8  00000000  00000000  0002a0a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .build_attributes 000004db  00000000  00000000  0002aaa0  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	50 05 00 20 1d 10 00 10 00 00 00 00 9d 10 00 10     P.. ............
10001010:	00 18 04 00 00 01 00 00 00 00 00 80                 ............

1000101c <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
1000101c:	4911      	ldr	r1, [pc, #68]	; (10001064 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101e:	4a12      	ldr	r2, [pc, #72]	; (10001068 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
10001020:	4b12      	ldr	r3, [pc, #72]	; (1000106c <__copy_data+0x16>)
	bl  __copy_data
10001022:	f000 f818 	bl	10001056 <__copy_data>

    ldr  r0, =SystemInit
10001026:	4812      	ldr	r0, [pc, #72]	; (10001070 <__copy_data+0x1a>)
    blx  r0
10001028:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
1000102a:	4912      	ldr	r1, [pc, #72]	; (10001074 <__copy_data+0x1e>)
	ldr	r2, =__data_start
1000102c:	4a12      	ldr	r2, [pc, #72]	; (10001078 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102e:	4b13      	ldr	r3, [pc, #76]	; (1000107c <__copy_data+0x26>)
	bl  __copy_data
10001030:	f000 f811 	bl	10001056 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001034:	4912      	ldr	r1, [pc, #72]	; (10001080 <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001036:	4a13      	ldr	r2, [pc, #76]	; (10001084 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001038:	4b13      	ldr	r3, [pc, #76]	; (10001088 <__copy_data+0x32>)
	bl  __copy_data
1000103a:	f000 f80c 	bl	10001056 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103e:	4913      	ldr	r1, [pc, #76]	; (1000108c <__copy_data+0x36>)
	ldr	r2, =__bss_end
10001040:	4a13      	ldr	r2, [pc, #76]	; (10001090 <__copy_data+0x3a>)

	movs	r0, 0
10001042:	2000      	movs	r0, #0

	subs	r2, r1
10001044:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001046:	dd02      	ble.n	1000104e <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001048:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
1000104a:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
1000104c:	dcfc      	bgt.n	10001048 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x3e>)
    blx  r0
10001050:	4780      	blx	r0
#endif

    ldr  r0, =main
10001052:	4811      	ldr	r0, [pc, #68]	; (10001098 <__copy_data+0x42>)
    blx  r0
10001054:	4780      	blx	r0

10001056 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001056:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001058:	dd03      	ble.n	10001062 <__copy_data+0xc>

.L_loop:
	subs	r3, #4
1000105a:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
1000105c:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105e:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
10001060:	dcfb      	bgt.n	1000105a <__copy_data+0x4>

.L_loop_done:
	bx  lr
10001062:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001064:	10003e80 	.word	0x10003e80
	ldr	r2, =VeneerStart
10001068:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
1000106c:	20000150 	.word	0x20000150
	bl  __copy_data

    ldr  r0, =SystemInit
10001070:	100010a1 	.word	0x100010a1
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001074:	10003fc4 	.word	0x10003fc4
	ldr	r2, =__data_start
10001078:	20000550 	.word	0x20000550
	ldr	r3, =__data_end
1000107c:	20000568 	.word	0x20000568
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
10001080:	10003fdc 	.word	0x10003fdc
	ldr	r2, =__ram_code_start
10001084:	20000568 	.word	0x20000568
	ldr	r3, =__ram_code_end
10001088:	20000568 	.word	0x20000568
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000108c:	20000568 	.word	0x20000568
	ldr	r2, =__bss_end
10001090:	20002e24 	.word	0x20002e24
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001094:	10003d69 	.word	0x10003d69
    blx  r0
#endif

    ldr  r0, =main
10001098:	10003c8d 	.word	0x10003c8d

1000109c <HardFault_Handler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_Handler:
    b  .
1000109c:	e7fe      	b.n	1000109c <HardFault_Handler>
	...

100010a0 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
100010a0:	b580      	push	{r7, lr}
100010a2:	af00      	add	r7, sp, #0
  SystemCoreSetup();
100010a4:	f002 fd26 	bl	10003af4 <SystemCoreSetup>
  SystemCoreClockSetup();
100010a8:	f002 fd72 	bl	10003b90 <SystemCoreClockSetup>
}
100010ac:	46bd      	mov	sp, r7
100010ae:	bd80      	pop	{r7, pc}

100010b0 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010b0:	b580      	push	{r7, lr}
100010b2:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010b4:	4b2a      	ldr	r3, [pc, #168]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010b6:	681a      	ldr	r2, [r3, #0]
100010b8:	23ff      	movs	r3, #255	; 0xff
100010ba:	021b      	lsls	r3, r3, #8
100010bc:	4013      	ands	r3, r2
100010be:	0a1a      	lsrs	r2, r3, #8
100010c0:	4b28      	ldr	r3, [pc, #160]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010c2:	601a      	str	r2, [r3, #0]

  if (IDIV != 0)
100010c4:	4b27      	ldr	r3, [pc, #156]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010c6:	681b      	ldr	r3, [r3, #0]
100010c8:	2b00      	cmp	r3, #0
100010ca:	d037      	beq.n	1000113c <SystemCoreClockUpdate+0x8c>
  {
    FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010cc:	4b24      	ldr	r3, [pc, #144]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010ce:	681b      	ldr	r3, [r3, #0]
100010d0:	22ff      	movs	r2, #255	; 0xff
100010d2:	401a      	ands	r2, r3
100010d4:	4b24      	ldr	r3, [pc, #144]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010d6:	601a      	str	r2, [r3, #0]
    FDIV |= ((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_FDIV_Msk) << 8;
100010d8:	4b21      	ldr	r3, [pc, #132]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010da:	69db      	ldr	r3, [r3, #28]
100010dc:	2203      	movs	r2, #3
100010de:	4013      	ands	r3, r2
100010e0:	021a      	lsls	r2, r3, #8
100010e2:	4b21      	ldr	r3, [pc, #132]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010e4:	681b      	ldr	r3, [r3, #0]
100010e6:	431a      	orrs	r2, r3
100010e8:	4b1f      	ldr	r3, [pc, #124]	; (10001168 <SystemCoreClockUpdate+0xb8>)
100010ea:	601a      	str	r2, [r3, #0]
    
    /* Fractional divider is enabled and used */
    if (((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_DCLKSEL_Msk) == 0U)
100010ec:	4b1c      	ldr	r3, [pc, #112]	; (10001160 <SystemCoreClockUpdate+0xb0>)
100010ee:	69da      	ldr	r2, [r3, #28]
100010f0:	2380      	movs	r3, #128	; 0x80
100010f2:	009b      	lsls	r3, r3, #2
100010f4:	4013      	ands	r3, r2
100010f6:	d10e      	bne.n	10001116 <SystemCoreClockUpdate+0x66>
    {
       SystemCoreClock = ((uint32_t)((DCO1_FREQUENCY << 6U) / ((IDIV << 10) + FDIV))) << 4U;
100010f8:	4b1a      	ldr	r3, [pc, #104]	; (10001164 <SystemCoreClockUpdate+0xb4>)
100010fa:	681b      	ldr	r3, [r3, #0]
100010fc:	029a      	lsls	r2, r3, #10
100010fe:	4b1a      	ldr	r3, [pc, #104]	; (10001168 <SystemCoreClockUpdate+0xb8>)
10001100:	681b      	ldr	r3, [r3, #0]
10001102:	18d3      	adds	r3, r2, r3
10001104:	4819      	ldr	r0, [pc, #100]	; (1000116c <SystemCoreClockUpdate+0xbc>)
10001106:	1c19      	adds	r1, r3, #0
10001108:	f000 fb18 	bl	1000173c <__aeabi_uidiv>
1000110c:	1c03      	adds	r3, r0, #0
1000110e:	011a      	lsls	r2, r3, #4
10001110:	4b17      	ldr	r3, [pc, #92]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001112:	601a      	str	r2, [r3, #0]
10001114:	e021      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
    else
    {
       SystemCoreClock = ((uint32_t)((OSCHP_GetFrequency() << 6U) / ((IDIV << 10) + FDIV))) << 4U;
10001116:	f000 f82f 	bl	10001178 <OSCHP_GetFrequency>
1000111a:	1c03      	adds	r3, r0, #0
1000111c:	0199      	lsls	r1, r3, #6
1000111e:	4b11      	ldr	r3, [pc, #68]	; (10001164 <SystemCoreClockUpdate+0xb4>)
10001120:	681b      	ldr	r3, [r3, #0]
10001122:	029a      	lsls	r2, r3, #10
10001124:	4b10      	ldr	r3, [pc, #64]	; (10001168 <SystemCoreClockUpdate+0xb8>)
10001126:	681b      	ldr	r3, [r3, #0]
10001128:	18d3      	adds	r3, r2, r3
1000112a:	1c08      	adds	r0, r1, #0
1000112c:	1c19      	adds	r1, r3, #0
1000112e:	f000 fb05 	bl	1000173c <__aeabi_uidiv>
10001132:	1c03      	adds	r3, r0, #0
10001134:	011a      	lsls	r2, r3, #4
10001136:	4b0e      	ldr	r3, [pc, #56]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001138:	601a      	str	r2, [r3, #0]
1000113a:	e00e      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
  }
  else
  {
    /* Fractional divider bypassed. */
    if (((SCU_CLK->CLKCR1) & SCU_CLK_CLKCR1_DCLKSEL_Msk) == 0U)
1000113c:	4b08      	ldr	r3, [pc, #32]	; (10001160 <SystemCoreClockUpdate+0xb0>)
1000113e:	69da      	ldr	r2, [r3, #28]
10001140:	2380      	movs	r3, #128	; 0x80
10001142:	009b      	lsls	r3, r3, #2
10001144:	4013      	ands	r3, r2
10001146:	d103      	bne.n	10001150 <SystemCoreClockUpdate+0xa0>
    {
        SystemCoreClock = DCO1_FREQUENCY;
10001148:	4b09      	ldr	r3, [pc, #36]	; (10001170 <SystemCoreClockUpdate+0xc0>)
1000114a:	4a0a      	ldr	r2, [pc, #40]	; (10001174 <SystemCoreClockUpdate+0xc4>)
1000114c:	601a      	str	r2, [r3, #0]
1000114e:	e004      	b.n	1000115a <SystemCoreClockUpdate+0xaa>
    }
    else
    {
        SystemCoreClock = OSCHP_GetFrequency();
10001150:	f000 f812 	bl	10001178 <OSCHP_GetFrequency>
10001154:	1c02      	adds	r2, r0, #0
10001156:	4b06      	ldr	r3, [pc, #24]	; (10001170 <SystemCoreClockUpdate+0xc0>)
10001158:	601a      	str	r2, [r3, #0]
    }
  }
}
1000115a:	46bd      	mov	sp, r7
1000115c:	bd80      	pop	{r7, pc}
1000115e:	46c0      	nop			; (mov r8, r8)
10001160:	40010300 	.word	0x40010300
10001164:	20000568 	.word	0x20000568
10001168:	2000056c 	.word	0x2000056c
1000116c:	b71b0000 	.word	0xb71b0000
10001170:	20003ffc 	.word	0x20003ffc
10001174:	02dc6c00 	.word	0x02dc6c00

10001178 <OSCHP_GetFrequency>:

__WEAK uint32_t OSCHP_GetFrequency(void)
{
10001178:	b580      	push	{r7, lr}
1000117a:	af00      	add	r7, sp, #0
  return OSCHP_FREQUENCY;
1000117c:	4b01      	ldr	r3, [pc, #4]	; (10001184 <OSCHP_GetFrequency+0xc>)
}
1000117e:	1c18      	adds	r0, r3, #0
10001180:	46bd      	mov	sp, r7
10001182:	bd80      	pop	{r7, pc}
10001184:	01312d00 	.word	0x01312d00

10001188 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
10001188:	b590      	push	{r4, r7, lr}
1000118a:	b085      	sub	sp, #20
1000118c:	af00      	add	r7, sp, #0
1000118e:	60f8      	str	r0, [r7, #12]
10001190:	607a      	str	r2, [r7, #4]
10001192:	230b      	movs	r3, #11
10001194:	18fb      	adds	r3, r7, r3
10001196:	1c0a      	adds	r2, r1, #0
10001198:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000119a:	230b      	movs	r3, #11
1000119c:	18fb      	adds	r3, r7, r3
1000119e:	781b      	ldrb	r3, [r3, #0]
100011a0:	089b      	lsrs	r3, r3, #2
100011a2:	b2db      	uxtb	r3, r3
100011a4:	1c18      	adds	r0, r3, #0
100011a6:	230b      	movs	r3, #11
100011a8:	18fb      	adds	r3, r7, r3
100011aa:	781b      	ldrb	r3, [r3, #0]
100011ac:	089b      	lsrs	r3, r3, #2
100011ae:	b2db      	uxtb	r3, r3
100011b0:	1c1a      	adds	r2, r3, #0
100011b2:	68fb      	ldr	r3, [r7, #12]
100011b4:	3204      	adds	r2, #4
100011b6:	0092      	lsls	r2, r2, #2
100011b8:	58d3      	ldr	r3, [r2, r3]
100011ba:	220b      	movs	r2, #11
100011bc:	18ba      	adds	r2, r7, r2
100011be:	7812      	ldrb	r2, [r2, #0]
100011c0:	2103      	movs	r1, #3
100011c2:	400a      	ands	r2, r1
100011c4:	00d2      	lsls	r2, r2, #3
100011c6:	1c11      	adds	r1, r2, #0
100011c8:	22fc      	movs	r2, #252	; 0xfc
100011ca:	408a      	lsls	r2, r1
100011cc:	43d2      	mvns	r2, r2
100011ce:	401a      	ands	r2, r3
100011d0:	1c11      	adds	r1, r2, #0
100011d2:	68fb      	ldr	r3, [r7, #12]
100011d4:	1d02      	adds	r2, r0, #4
100011d6:	0092      	lsls	r2, r2, #2
100011d8:	50d1      	str	r1, [r2, r3]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
100011da:	68fb      	ldr	r3, [r7, #12]
100011dc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
100011de:	220b      	movs	r2, #11
100011e0:	18ba      	adds	r2, r7, r2
100011e2:	7812      	ldrb	r2, [r2, #0]
100011e4:	0052      	lsls	r2, r2, #1
100011e6:	1c11      	adds	r1, r2, #0
100011e8:	2203      	movs	r2, #3
100011ea:	408a      	lsls	r2, r1
100011ec:	43d2      	mvns	r2, r2
100011ee:	401a      	ands	r2, r3
100011f0:	68fb      	ldr	r3, [r7, #12]
100011f2:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
100011f4:	230b      	movs	r3, #11
100011f6:	18fb      	adds	r3, r7, r3
100011f8:	781b      	ldrb	r3, [r3, #0]
100011fa:	08db      	lsrs	r3, r3, #3
100011fc:	b2db      	uxtb	r3, r3
100011fe:	1c18      	adds	r0, r3, #0
10001200:	230b      	movs	r3, #11
10001202:	18fb      	adds	r3, r7, r3
10001204:	781b      	ldrb	r3, [r3, #0]
10001206:	08db      	lsrs	r3, r3, #3
10001208:	b2db      	uxtb	r3, r3
1000120a:	1c1a      	adds	r2, r3, #0
1000120c:	68fb      	ldr	r3, [r7, #12]
1000120e:	3210      	adds	r2, #16
10001210:	0092      	lsls	r2, r2, #2
10001212:	58d3      	ldr	r3, [r2, r3]
10001214:	220b      	movs	r2, #11
10001216:	18ba      	adds	r2, r7, r2
10001218:	7812      	ldrb	r2, [r2, #0]
1000121a:	2107      	movs	r1, #7
1000121c:	400a      	ands	r2, r1
1000121e:	0092      	lsls	r2, r2, #2
10001220:	1c11      	adds	r1, r2, #0
10001222:	2204      	movs	r2, #4
10001224:	408a      	lsls	r2, r1
10001226:	43d2      	mvns	r2, r2
10001228:	401a      	ands	r2, r3
1000122a:	1c11      	adds	r1, r2, #0
1000122c:	68fb      	ldr	r3, [r7, #12]
1000122e:	1c02      	adds	r2, r0, #0
10001230:	3210      	adds	r2, #16
10001232:	0092      	lsls	r2, r2, #2
10001234:	50d1      	str	r1, [r2, r3]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
10001236:	230b      	movs	r3, #11
10001238:	18fb      	adds	r3, r7, r3
1000123a:	781b      	ldrb	r3, [r3, #0]
1000123c:	08db      	lsrs	r3, r3, #3
1000123e:	b2db      	uxtb	r3, r3
10001240:	1c18      	adds	r0, r3, #0
10001242:	230b      	movs	r3, #11
10001244:	18fb      	adds	r3, r7, r3
10001246:	781b      	ldrb	r3, [r3, #0]
10001248:	08db      	lsrs	r3, r3, #3
1000124a:	b2db      	uxtb	r3, r3
1000124c:	1c1a      	adds	r2, r3, #0
1000124e:	68fb      	ldr	r3, [r7, #12]
10001250:	3210      	adds	r2, #16
10001252:	0092      	lsls	r2, r2, #2
10001254:	58d2      	ldr	r2, [r2, r3]
10001256:	687b      	ldr	r3, [r7, #4]
10001258:	785b      	ldrb	r3, [r3, #1]
1000125a:	1c1c      	adds	r4, r3, #0
1000125c:	230b      	movs	r3, #11
1000125e:	18fb      	adds	r3, r7, r3
10001260:	781b      	ldrb	r3, [r3, #0]
10001262:	2107      	movs	r1, #7
10001264:	400b      	ands	r3, r1
10001266:	009b      	lsls	r3, r3, #2
10001268:	409c      	lsls	r4, r3
1000126a:	1c23      	adds	r3, r4, #0
1000126c:	431a      	orrs	r2, r3
1000126e:	1c11      	adds	r1, r2, #0
10001270:	68fb      	ldr	r3, [r7, #12]
10001272:	1c02      	adds	r2, r0, #0
10001274:	3210      	adds	r2, #16
10001276:	0092      	lsls	r2, r2, #2
10001278:	50d1      	str	r1, [r2, r3]

  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
1000127a:	68fb      	ldr	r3, [r7, #12]
1000127c:	4a20      	ldr	r2, [pc, #128]	; (10001300 <XMC_GPIO_Init+0x178>)
1000127e:	4293      	cmp	r3, r2
10001280:	d10b      	bne.n	1000129a <XMC_GPIO_Init+0x112>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
10001282:	68fb      	ldr	r3, [r7, #12]
10001284:	6e1b      	ldr	r3, [r3, #96]	; 0x60
10001286:	220b      	movs	r2, #11
10001288:	18ba      	adds	r2, r7, r2
1000128a:	7812      	ldrb	r2, [r2, #0]
1000128c:	2101      	movs	r1, #1
1000128e:	4091      	lsls	r1, r2
10001290:	1c0a      	adds	r2, r1, #0
10001292:	43d2      	mvns	r2, r2
10001294:	401a      	ands	r2, r3
10001296:	68fb      	ldr	r3, [r7, #12]
10001298:	661a      	str	r2, [r3, #96]	; 0x60
  }

  if ((config->mode & XMC_GPIO_MODE_OE) != 0)
1000129a:	687b      	ldr	r3, [r7, #4]
1000129c:	781b      	ldrb	r3, [r3, #0]
1000129e:	b2db      	uxtb	r3, r3
100012a0:	b25b      	sxtb	r3, r3
100012a2:	2b00      	cmp	r3, #0
100012a4:	da07      	bge.n	100012b6 <XMC_GPIO_Init+0x12e>
  {
    /* If output is enabled */

    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
100012a6:	687b      	ldr	r3, [r7, #4]
100012a8:	685a      	ldr	r2, [r3, #4]
100012aa:	230b      	movs	r3, #11
100012ac:	18fb      	adds	r3, r7, r3
100012ae:	781b      	ldrb	r3, [r3, #0]
100012b0:	409a      	lsls	r2, r3
100012b2:	68fb      	ldr	r3, [r7, #12]
100012b4:	605a      	str	r2, [r3, #4]
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
100012b6:	230b      	movs	r3, #11
100012b8:	18fb      	adds	r3, r7, r3
100012ba:	781b      	ldrb	r3, [r3, #0]
100012bc:	089b      	lsrs	r3, r3, #2
100012be:	b2db      	uxtb	r3, r3
100012c0:	1c18      	adds	r0, r3, #0
100012c2:	230b      	movs	r3, #11
100012c4:	18fb      	adds	r3, r7, r3
100012c6:	781b      	ldrb	r3, [r3, #0]
100012c8:	089b      	lsrs	r3, r3, #2
100012ca:	b2db      	uxtb	r3, r3
100012cc:	1c1a      	adds	r2, r3, #0
100012ce:	68fb      	ldr	r3, [r7, #12]
100012d0:	3204      	adds	r2, #4
100012d2:	0092      	lsls	r2, r2, #2
100012d4:	58d2      	ldr	r2, [r2, r3]
100012d6:	687b      	ldr	r3, [r7, #4]
100012d8:	781b      	ldrb	r3, [r3, #0]
100012da:	1c1c      	adds	r4, r3, #0
100012dc:	230b      	movs	r3, #11
100012de:	18fb      	adds	r3, r7, r3
100012e0:	781b      	ldrb	r3, [r3, #0]
100012e2:	2103      	movs	r1, #3
100012e4:	400b      	ands	r3, r1
100012e6:	00db      	lsls	r3, r3, #3
100012e8:	409c      	lsls	r4, r3
100012ea:	1c23      	adds	r3, r4, #0
100012ec:	431a      	orrs	r2, r3
100012ee:	1c11      	adds	r1, r2, #0
100012f0:	68fb      	ldr	r3, [r7, #12]
100012f2:	1d02      	adds	r2, r0, #4
100012f4:	0092      	lsls	r2, r2, #2
100012f6:	50d1      	str	r1, [r2, r3]
}
100012f8:	46bd      	mov	sp, r7
100012fa:	b005      	add	sp, #20
100012fc:	bd90      	pop	{r4, r7, pc}
100012fe:	46c0      	nop			; (mov r8, r8)
10001300:	40040200 	.word	0x40040200

10001304 <XMC_SCU_LockProtectedBits>:
#endif
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
10001304:	b580      	push	{r7, lr}
10001306:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
10001308:	4b02      	ldr	r3, [pc, #8]	; (10001314 <XMC_SCU_LockProtectedBits+0x10>)
1000130a:	22c3      	movs	r2, #195	; 0xc3
1000130c:	625a      	str	r2, [r3, #36]	; 0x24
}
1000130e:	46bd      	mov	sp, r7
10001310:	bd80      	pop	{r7, pc}
10001312:	46c0      	nop			; (mov r8, r8)
10001314:	40010000 	.word	0x40010000

10001318 <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
10001318:	b580      	push	{r7, lr}
1000131a:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
1000131c:	4b05      	ldr	r3, [pc, #20]	; (10001334 <XMC_SCU_UnlockProtectedBits+0x1c>)
1000131e:	22c0      	movs	r2, #192	; 0xc0
10001320:	625a      	str	r2, [r3, #36]	; 0x24

  while (((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
10001322:	46c0      	nop			; (mov r8, r8)
10001324:	4b03      	ldr	r3, [pc, #12]	; (10001334 <XMC_SCU_UnlockProtectedBits+0x1c>)
10001326:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10001328:	2204      	movs	r2, #4
1000132a:	4013      	ands	r3, r2
1000132c:	d1fa      	bne.n	10001324 <XMC_SCU_UnlockProtectedBits+0xc>
  {
    /* Loop until the lock is removed */
  }
}
1000132e:	46bd      	mov	sp, r7
10001330:	bd80      	pop	{r7, pc}
10001332:	46c0      	nop			; (mov r8, r8)
10001334:	40010000 	.word	0x40010000

10001338 <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
10001338:	b580      	push	{r7, lr}
1000133a:	b086      	sub	sp, #24
1000133c:	af00      	add	r7, sp, #0
1000133e:	6078      	str	r0, [r7, #4]
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
10001340:	f7ff ffea 	bl	10001318 <XMC_SCU_UnlockProtectedBits>

#if (UC_SERIES == XMC14)
  /* OSCHP source selection - OSC mode */

  if (config->oschp_mode != XMC_SCU_CLOCK_OSCHP_MODE_DISABLED)
10001344:	687b      	ldr	r3, [r7, #4]
10001346:	799b      	ldrb	r3, [r3, #6]
10001348:	2b30      	cmp	r3, #48	; 0x30
1000134a:	d053      	beq.n	100013f4 <XMC_SCU_CLOCK_Init+0xbc>
  {
    if (OSCHP_GetFrequency() > 20000000U)
1000134c:	f7ff ff14 	bl	10001178 <OSCHP_GetFrequency>
10001350:	1e02      	subs	r2, r0, #0
10001352:	4b49      	ldr	r3, [pc, #292]	; (10001478 <XMC_SCU_CLOCK_Init+0x140>)
10001354:	429a      	cmp	r2, r3
10001356:	d909      	bls.n	1000136c <XMC_SCU_CLOCK_Init+0x34>
    {
      SCU_ANALOG->ANAOSCHPCTRL |= (uint16_t)SCU_ANALOG_ANAOSCHPCTRL_HYSCTRL_Msk;
10001358:	4a48      	ldr	r2, [pc, #288]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000135a:	4948      	ldr	r1, [pc, #288]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000135c:	2390      	movs	r3, #144	; 0x90
1000135e:	5acb      	ldrh	r3, [r1, r3]
10001360:	b29b      	uxth	r3, r3
10001362:	2140      	movs	r1, #64	; 0x40
10001364:	430b      	orrs	r3, r1
10001366:	b299      	uxth	r1, r3
10001368:	2390      	movs	r3, #144	; 0x90
1000136a:	52d1      	strh	r1, [r2, r3]
    }

    SCU_ANALOG->ANAOSCHPCTRL = (uint16_t)(SCU_ANALOG->ANAOSCHPCTRL & ~(SCU_ANALOG_ANAOSCHPCTRL_SHBY_Msk | SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk)) |
1000136c:	4a43      	ldr	r2, [pc, #268]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000136e:	4943      	ldr	r1, [pc, #268]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
10001370:	2390      	movs	r3, #144	; 0x90
10001372:	5acb      	ldrh	r3, [r1, r3]
10001374:	b29b      	uxth	r3, r3
10001376:	b29b      	uxth	r3, r3
10001378:	1c19      	adds	r1, r3, #0
1000137a:	2332      	movs	r3, #50	; 0x32
1000137c:	4399      	bics	r1, r3
1000137e:	1c0b      	adds	r3, r1, #0
10001380:	b299      	uxth	r1, r3
                               config->oschp_mode;
10001382:	687b      	ldr	r3, [r7, #4]
10001384:	799b      	ldrb	r3, [r3, #6]
    if (OSCHP_GetFrequency() > 20000000U)
    {
      SCU_ANALOG->ANAOSCHPCTRL |= (uint16_t)SCU_ANALOG_ANAOSCHPCTRL_HYSCTRL_Msk;
    }

    SCU_ANALOG->ANAOSCHPCTRL = (uint16_t)(SCU_ANALOG->ANAOSCHPCTRL & ~(SCU_ANALOG_ANAOSCHPCTRL_SHBY_Msk | SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk)) |
10001386:	b29b      	uxth	r3, r3
10001388:	430b      	orrs	r3, r1
1000138a:	b29b      	uxth	r3, r3
1000138c:	b299      	uxth	r1, r3
1000138e:	2390      	movs	r3, #144	; 0x90
10001390:	52d1      	strh	r1, [r2, r3]
                               config->oschp_mode;

    do
    {
      /* clear the status bit before restarting the detection. */
      SCU_INTERRUPT->SRCLR1 = SCU_INTERRUPT_SRCLR1_LOECI_Msk;
10001392:	4b3b      	ldr	r3, [pc, #236]	; (10001480 <XMC_SCU_CLOCK_Init+0x148>)
10001394:	2202      	movs	r2, #2
10001396:	629a      	str	r2, [r3, #40]	; 0x28

      /* According to errata SCU_CM.023, to reset the XOWD it is needed to disable/enable the watchdog,
         keeping in between at least one DCO2 cycle */

      /* Disable XOWD */
      SCU_CLK->OSCCSR &= ~SCU_CLK_OSCCSR_XOWDEN_Msk;
10001398:	4b3a      	ldr	r3, [pc, #232]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
1000139a:	4a3a      	ldr	r2, [pc, #232]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
1000139c:	6952      	ldr	r2, [r2, #20]
1000139e:	493a      	ldr	r1, [pc, #232]	; (10001488 <XMC_SCU_CLOCK_Init+0x150>)
100013a0:	400a      	ands	r2, r1
100013a2:	615a      	str	r2, [r3, #20]
100013a4:	4b39      	ldr	r3, [pc, #228]	; (1000148c <XMC_SCU_CLOCK_Init+0x154>)
100013a6:	617b      	str	r3, [r7, #20]
100013a8:	e000      	b.n	100013ac <XMC_SCU_CLOCK_Init+0x74>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
100013aa:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
100013ac:	697b      	ldr	r3, [r7, #20]
100013ae:	3b01      	subs	r3, #1
100013b0:	617b      	str	r3, [r7, #20]
100013b2:	697b      	ldr	r3, [r7, #20]
100013b4:	2b00      	cmp	r3, #0
100013b6:	d1f8      	bne.n	100013aa <XMC_SCU_CLOCK_Init+0x72>
      /* Clock domains synchronization, at least 1 DCO2 cycle */
      /* delay value calculation assuming worst case DCO1=48Mhz and 3cycles per delay iteration */
      delay(538);

      /* Enable XOWD */
      SCU_CLK->OSCCSR |= SCU_CLK_OSCCSR_XOWDEN_Msk | SCU_CLK_OSCCSR_XOWDRES_Msk;
100013b8:	4b32      	ldr	r3, [pc, #200]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013ba:	4a32      	ldr	r2, [pc, #200]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013bc:	6952      	ldr	r2, [r2, #20]
100013be:	21c0      	movs	r1, #192	; 0xc0
100013c0:	0489      	lsls	r1, r1, #18
100013c2:	430a      	orrs	r2, r1
100013c4:	615a      	str	r2, [r3, #20]

      /* OSCCSR.XOWDRES bit will be automatically reset to 0 after XOWD is reset */
      while (SCU_CLK->OSCCSR & SCU_CLK_OSCCSR_XOWDRES_Msk);
100013c6:	46c0      	nop			; (mov r8, r8)
100013c8:	4b2e      	ldr	r3, [pc, #184]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
100013ca:	695a      	ldr	r2, [r3, #20]
100013cc:	2380      	movs	r3, #128	; 0x80
100013ce:	045b      	lsls	r3, r3, #17
100013d0:	4013      	ands	r3, r2
100013d2:	d1f9      	bne.n	100013c8 <XMC_SCU_CLOCK_Init+0x90>
100013d4:	4b2e      	ldr	r3, [pc, #184]	; (10001490 <XMC_SCU_CLOCK_Init+0x158>)
100013d6:	613b      	str	r3, [r7, #16]
100013d8:	e000      	b.n	100013dc <XMC_SCU_CLOCK_Init+0xa4>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
100013da:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
100013dc:	693b      	ldr	r3, [r7, #16]
100013de:	3b01      	subs	r3, #1
100013e0:	613b      	str	r3, [r7, #16]
100013e2:	693b      	ldr	r3, [r7, #16]
100013e4:	2b00      	cmp	r3, #0
100013e6:	d1f8      	bne.n	100013da <XMC_SCU_CLOCK_Init+0xa2>
      /* Wait a at least 5 DCO2 cycles for the update of the XTAL OWD result */
      /* delay value calculation assuming worst case DCO1=48Mhz and 3cycles per delay iteration */
      delay(2685);

    }
    while (SCU_INTERRUPT->SRRAW1 & SCU_INTERRUPT_SRRAW1_LOECI_Msk);
100013e8:	4b25      	ldr	r3, [pc, #148]	; (10001480 <XMC_SCU_CLOCK_Init+0x148>)
100013ea:	6a1b      	ldr	r3, [r3, #32]
100013ec:	2202      	movs	r2, #2
100013ee:	4013      	ands	r3, r2
100013f0:	d1cf      	bne.n	10001392 <XMC_SCU_CLOCK_Init+0x5a>
100013f2:	e009      	b.n	10001408 <XMC_SCU_CLOCK_Init+0xd0>
  }
  else /* (config->oschp_mode == XMC_SCU_CLOCK_OSCHP_MODE_DISABLED) */
  {
    SCU_ANALOG->ANAOSCHPCTRL |= SCU_ANALOG_ANAOSCHPCTRL_MODE_Msk;
100013f4:	4a21      	ldr	r2, [pc, #132]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
100013f6:	4921      	ldr	r1, [pc, #132]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
100013f8:	2390      	movs	r3, #144	; 0x90
100013fa:	5acb      	ldrh	r3, [r1, r3]
100013fc:	b29b      	uxth	r3, r3
100013fe:	2130      	movs	r1, #48	; 0x30
10001400:	430b      	orrs	r3, r1
10001402:	b299      	uxth	r1, r3
10001404:	2390      	movs	r3, #144	; 0x90
10001406:	52d1      	strh	r1, [r2, r3]
  }

  SCU_ANALOG->ANAOSCLPCTRL = (uint16_t)config->osclp_mode;
10001408:	4a1c      	ldr	r2, [pc, #112]	; (1000147c <XMC_SCU_CLOCK_Init+0x144>)
1000140a:	687b      	ldr	r3, [r7, #4]
1000140c:	79db      	ldrb	r3, [r3, #7]
1000140e:	b299      	uxth	r1, r3
10001410:	238c      	movs	r3, #140	; 0x8c
10001412:	52d1      	strh	r1, [r2, r3]
#ifndef DISABLE_WAIT_RTC_XTAL_OSC_STARTUP
  if (config->osclp_mode == XMC_SCU_CLOCK_OSCLP_MODE_OSC)
10001414:	687b      	ldr	r3, [r7, #4]
10001416:	79db      	ldrb	r3, [r3, #7]
10001418:	2b00      	cmp	r3, #0
1000141a:	d109      	bne.n	10001430 <XMC_SCU_CLOCK_Init+0xf8>
1000141c:	4b1d      	ldr	r3, [pc, #116]	; (10001494 <XMC_SCU_CLOCK_Init+0x15c>)
1000141e:	60fb      	str	r3, [r7, #12]
10001420:	e000      	b.n	10001424 <XMC_SCU_CLOCK_Init+0xec>
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
  {
    __NOP();
10001422:	46c0      	nop			; (mov r8, r8)

#if UC_SERIES == XMC14
/* This is a local function used to generate the delay until register get updated with new configured value.  */
__STATIC_FORCEINLINE void delay(uint32_t cycles)
{
  while (--cycles > 0U)
10001424:	68fb      	ldr	r3, [r7, #12]
10001426:	3b01      	subs	r3, #1
10001428:	60fb      	str	r3, [r7, #12]
1000142a:	68fb      	ldr	r3, [r7, #12]
1000142c:	2b00      	cmp	r3, #0
1000142e:	d1f8      	bne.n	10001422 <XMC_SCU_CLOCK_Init+0xea>
    /* Wait oscillator startup time ~5s */
    delay(6500000);
  }
#endif

  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
10001430:	4b14      	ldr	r3, [pc, #80]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001432:	4a14      	ldr	r2, [pc, #80]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001434:	69d2      	ldr	r2, [r2, #28]
10001436:	4918      	ldr	r1, [pc, #96]	; (10001498 <XMC_SCU_CLOCK_Init+0x160>)
10001438:	400a      	ands	r2, r1
                    config->dclk_src;
1000143a:	6879      	ldr	r1, [r7, #4]
1000143c:	8889      	ldrh	r1, [r1, #4]
    /* Wait oscillator startup time ~5s */
    delay(6500000);
  }
#endif

  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
1000143e:	430a      	orrs	r2, r1
10001440:	61da      	str	r2, [r3, #28]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001442:	4a10      	ldr	r2, [pc, #64]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001444:	4b0f      	ldr	r3, [pc, #60]	; (10001484 <XMC_SCU_CLOCK_Init+0x14c>)
10001446:	681b      	ldr	r3, [r3, #0]
10001448:	4914      	ldr	r1, [pc, #80]	; (1000149c <XMC_SCU_CLOCK_Init+0x164>)
1000144a:	4019      	ands	r1, r3
                   config->rtc_src |
1000144c:	687b      	ldr	r3, [r7, #4]
1000144e:	68db      	ldr	r3, [r3, #12]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001450:	4319      	orrs	r1, r3
                   config->rtc_src |
                   config->pclk_src;
10001452:	687b      	ldr	r3, [r7, #4]
10001454:	689b      	ldr	r3, [r3, #8]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
10001456:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
10001458:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
1000145a:	f7ff ff53 	bl	10001304 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
1000145e:	687b      	ldr	r3, [r7, #4]
10001460:	789b      	ldrb	r3, [r3, #2]
10001462:	1c1a      	adds	r2, r3, #0
10001464:	687b      	ldr	r3, [r7, #4]
10001466:	881b      	ldrh	r3, [r3, #0]
10001468:	1c10      	adds	r0, r2, #0
1000146a:	1c19      	adds	r1, r3, #0
1000146c:	f000 f832 	bl	100014d4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
10001470:	46bd      	mov	sp, r7
10001472:	b006      	add	sp, #24
10001474:	bd80      	pop	{r7, pc}
10001476:	46c0      	nop			; (mov r8, r8)
10001478:	01312d00 	.word	0x01312d00
1000147c:	40011000 	.word	0x40011000
10001480:	40010038 	.word	0x40010038
10001484:	40010300 	.word	0x40010300
10001488:	fdffffff 	.word	0xfdffffff
1000148c:	0000021a 	.word	0x0000021a
10001490:	00000a7d 	.word	0x00000a7d
10001494:	00632ea0 	.word	0x00632ea0
10001498:	fffffdff 	.word	0xfffffdff
1000149c:	fff0ffff 	.word	0xfff0ffff

100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
100014a0:	b580      	push	{r7, lr}
100014a2:	b082      	sub	sp, #8
100014a4:	af00      	add	r7, sp, #0
100014a6:	6078      	str	r0, [r7, #4]
  XMC_SCU_UnlockProtectedBits();
100014a8:	f7ff ff36 	bl	10001318 <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
100014ac:	4b08      	ldr	r3, [pc, #32]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014ae:	4a08      	ldr	r2, [pc, #32]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014b0:	6911      	ldr	r1, [r2, #16]
100014b2:	687a      	ldr	r2, [r7, #4]
100014b4:	430a      	orrs	r2, r1
100014b6:	611a      	str	r2, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100014b8:	46c0      	nop			; (mov r8, r8)
100014ba:	4b05      	ldr	r3, [pc, #20]	; (100014d0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x30>)
100014bc:	681a      	ldr	r2, [r3, #0]
100014be:	2380      	movs	r3, #128	; 0x80
100014c0:	05db      	lsls	r3, r3, #23
100014c2:	4013      	ands	r3, r2
100014c4:	d1f9      	bne.n	100014ba <XMC_SCU_CLOCK_UngatePeripheralClock+0x1a>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
100014c6:	f7ff ff1d 	bl	10001304 <XMC_SCU_LockProtectedBits>
}
100014ca:	46bd      	mov	sp, r7
100014cc:	b002      	add	sp, #8
100014ce:	bd80      	pop	{r7, pc}
100014d0:	40010300 	.word	0x40010300

100014d4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
100014d4:	b580      	push	{r7, lr}
100014d6:	b084      	sub	sp, #16
100014d8:	af00      	add	r7, sp, #0
100014da:	6078      	str	r0, [r7, #4]
100014dc:	6039      	str	r1, [r7, #0]
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
100014de:	f7ff ff1b 	bl	10001318 <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100014e2:	4b27      	ldr	r3, [pc, #156]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
100014e4:	681a      	ldr	r2, [r3, #0]
100014e6:	23ff      	movs	r3, #255	; 0xff
100014e8:	021b      	lsls	r3, r3, #8
100014ea:	4013      	ands	r3, r2
100014ec:	0a1b      	lsrs	r3, r3, #8
100014ee:	60fb      	str	r3, [r7, #12]

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
100014f0:	4b23      	ldr	r3, [pc, #140]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
100014f2:	4a23      	ldr	r2, [pc, #140]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
100014f4:	69d2      	ldr	r2, [r2, #28]
100014f6:	2103      	movs	r1, #3
100014f8:	438a      	bics	r2, r1
100014fa:	1c11      	adds	r1, r2, #0
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);
100014fc:	683a      	ldr	r2, [r7, #0]
100014fe:	0a12      	lsrs	r2, r2, #8

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
10001500:	430a      	orrs	r2, r1
10001502:	61da      	str	r2, [r3, #28]
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001504:	4b1e      	ldr	r3, [pc, #120]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001506:	4a1e      	ldr	r2, [pc, #120]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001508:	6812      	ldr	r2, [r2, #0]
1000150a:	491e      	ldr	r1, [pc, #120]	; (10001584 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb0>)
1000150c:	4011      	ands	r1, r2
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
1000150e:	683a      	ldr	r2, [r7, #0]
10001510:	20ff      	movs	r0, #255	; 0xff
10001512:	4002      	ands	r2, r0

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001514:	430a      	orrs	r2, r1
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
10001516:	491c      	ldr	r1, [pc, #112]	; (10001588 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb4>)
10001518:	430a      	orrs	r2, r1

#if (UC_SERIES == XMC14)
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & (uint32_t)~(SCU_CLK_CLKCR1_FDIV_Msk)) |
                    (uint32_t)((fdiv >> 8U) << SCU_CLK_CLKCR1_FDIV_Pos);

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000151a:	601a      	str	r2, [r3, #0]
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000151c:	46c0      	nop			; (mov r8, r8)
1000151e:	4b18      	ldr	r3, [pc, #96]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001520:	681a      	ldr	r2, [r3, #0]
10001522:	2380      	movs	r3, #128	; 0x80
10001524:	05db      	lsls	r3, r3, #23
10001526:	4013      	ands	r3, r2
10001528:	d1f9      	bne.n	1000151e <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x4a>
  {
    /* Spin until the core supply stabilizes */
  }

  if (curr_idiv <= idiv)
1000152a:	68fa      	ldr	r2, [r7, #12]
1000152c:	687b      	ldr	r3, [r7, #4]
1000152e:	429a      	cmp	r2, r3
10001530:	d806      	bhi.n	10001540 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x6c>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
10001532:	68fa      	ldr	r2, [r7, #12]
10001534:	687b      	ldr	r3, [r7, #4]
10001536:	1c10      	adds	r0, r2, #0
10001538:	1c19      	adds	r1, r3, #0
1000153a:	f000 f853 	bl	100015e4 <XMC_SCU_CLOCK_lFrequencyDownScaling>
1000153e:	e005      	b.n	1000154c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x78>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
10001540:	68fa      	ldr	r2, [r7, #12]
10001542:	687b      	ldr	r3, [r7, #4]
10001544:	1c10      	adds	r0, r2, #0
10001546:	1c19      	adds	r1, r3, #0
10001548:	f000 f822 	bl	10001590 <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000154c:	4b0c      	ldr	r3, [pc, #48]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
1000154e:	4a0c      	ldr	r2, [pc, #48]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001550:	6812      	ldr	r2, [r2, #0]
10001552:	490e      	ldr	r1, [pc, #56]	; (1000158c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb8>)
10001554:	4011      	ands	r1, r2
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
10001556:	687a      	ldr	r2, [r7, #4]
10001558:	0212      	lsls	r2, r2, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000155a:	430a      	orrs	r2, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
1000155c:	490a      	ldr	r1, [pc, #40]	; (10001588 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb4>)
1000155e:	430a      	orrs	r2, r1
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001560:	601a      	str	r2, [r3, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001562:	46c0      	nop			; (mov r8, r8)
10001564:	4b06      	ldr	r3, [pc, #24]	; (10001580 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xac>)
10001566:	681a      	ldr	r2, [r3, #0]
10001568:	2380      	movs	r3, #128	; 0x80
1000156a:	05db      	lsls	r3, r3, #23
1000156c:	4013      	ands	r3, r2
1000156e:	d1f9      	bne.n	10001564 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x90>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
10001570:	f7ff fec8 	bl	10001304 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
10001574:	f7ff fd9c 	bl	100010b0 <SystemCoreClockUpdate>

}
10001578:	46bd      	mov	sp, r7
1000157a:	b004      	add	sp, #16
1000157c:	bd80      	pop	{r7, pc}
1000157e:	46c0      	nop			; (mov r8, r8)
10001580:	40010300 	.word	0x40010300
10001584:	c00fff00 	.word	0xc00fff00
10001588:	3ff00000 	.word	0x3ff00000
1000158c:	c00f00ff 	.word	0xc00f00ff

10001590 <XMC_SCU_CLOCK_lFrequencyUpScaling>:

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10001590:	b580      	push	{r7, lr}
10001592:	b082      	sub	sp, #8
10001594:	af00      	add	r7, sp, #0
10001596:	6078      	str	r0, [r7, #4]
10001598:	6039      	str	r1, [r7, #0]
  while (curr_idiv > (target_idiv * 4UL))
1000159a:	e014      	b.n	100015c6 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x36>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
1000159c:	687b      	ldr	r3, [r7, #4]
1000159e:	089b      	lsrs	r3, r3, #2
100015a0:	607b      	str	r3, [r7, #4]

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015a2:	4b0d      	ldr	r3, [pc, #52]	; (100015d8 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015a4:	4a0c      	ldr	r2, [pc, #48]	; (100015d8 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015a6:	6812      	ldr	r2, [r2, #0]
100015a8:	490c      	ldr	r1, [pc, #48]	; (100015dc <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4c>)
100015aa:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
100015ac:	687a      	ldr	r2, [r7, #4]
100015ae:	0212      	lsls	r2, r2, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015b0:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
100015b2:	490b      	ldr	r1, [pc, #44]	; (100015e0 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x50>)
100015b4:	430a      	orrs	r2, r1
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100015b6:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100015b8:	46c0      	nop			; (mov r8, r8)
100015ba:	4b07      	ldr	r3, [pc, #28]	; (100015d8 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100015bc:	681a      	ldr	r2, [r3, #0]
100015be:	2380      	movs	r3, #128	; 0x80
100015c0:	05db      	lsls	r3, r3, #23
100015c2:	4013      	ands	r3, r2
100015c4:	d1f9      	bne.n	100015ba <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2a>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
100015c6:	683b      	ldr	r3, [r7, #0]
100015c8:	009a      	lsls	r2, r3, #2
100015ca:	687b      	ldr	r3, [r7, #4]
100015cc:	429a      	cmp	r2, r3
100015ce:	d3e5      	bcc.n	1000159c <XMC_SCU_CLOCK_lFrequencyUpScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
100015d0:	46bd      	mov	sp, r7
100015d2:	b002      	add	sp, #8
100015d4:	bd80      	pop	{r7, pc}
100015d6:	46c0      	nop			; (mov r8, r8)
100015d8:	40010300 	.word	0x40010300
100015dc:	c00f00ff 	.word	0xc00f00ff
100015e0:	3ff00000 	.word	0x3ff00000

100015e4 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
100015e4:	b580      	push	{r7, lr}
100015e6:	b082      	sub	sp, #8
100015e8:	af00      	add	r7, sp, #0
100015ea:	6078      	str	r0, [r7, #4]
100015ec:	6039      	str	r1, [r7, #0]

  while ((curr_idiv * 4UL) < target_idiv)
100015ee:	e019      	b.n	10001624 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x40>
  {
    if (0U == curr_idiv)
100015f0:	687b      	ldr	r3, [r7, #4]
100015f2:	2b00      	cmp	r3, #0
100015f4:	d101      	bne.n	100015fa <XMC_SCU_CLOCK_lFrequencyDownScaling+0x16>
    {
      curr_idiv = 1U;
100015f6:	2301      	movs	r3, #1
100015f8:	607b      	str	r3, [r7, #4]
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
100015fa:	687b      	ldr	r3, [r7, #4]
100015fc:	009b      	lsls	r3, r3, #2
100015fe:	607b      	str	r3, [r7, #4]
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001600:	4b0c      	ldr	r3, [pc, #48]	; (10001634 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001602:	4a0c      	ldr	r2, [pc, #48]	; (10001634 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001604:	6812      	ldr	r2, [r2, #0]
10001606:	490c      	ldr	r1, [pc, #48]	; (10001638 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x54>)
10001608:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000160a:	687a      	ldr	r2, [r7, #4]
1000160c:	0212      	lsls	r2, r2, #8
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000160e:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001610:	490a      	ldr	r1, [pc, #40]	; (1000163c <XMC_SCU_CLOCK_lFrequencyDownScaling+0x58>)
10001612:	430a      	orrs	r2, r1
    if (0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001614:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001616:	46c0      	nop			; (mov r8, r8)
10001618:	4b06      	ldr	r3, [pc, #24]	; (10001634 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
1000161a:	681a      	ldr	r2, [r3, #0]
1000161c:	2380      	movs	r3, #128	; 0x80
1000161e:	05db      	lsls	r3, r3, #23
10001620:	4013      	ands	r3, r2
10001622:	d1f9      	bne.n	10001618 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
10001624:	687b      	ldr	r3, [r7, #4]
10001626:	009a      	lsls	r2, r3, #2
10001628:	683b      	ldr	r3, [r7, #0]
1000162a:	429a      	cmp	r2, r3
1000162c:	d3e0      	bcc.n	100015f0 <XMC_SCU_CLOCK_lFrequencyDownScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
      /* Wait voltage suply stabilization */
    }
  }
}
1000162e:	46bd      	mov	sp, r7
10001630:	b002      	add	sp, #8
10001632:	bd80      	pop	{r7, pc}
10001634:	40010300 	.word	0x40010300
10001638:	c00f00ff 	.word	0xc00f00ff
1000163c:	3ff00000 	.word	0x3ff00000

10001640 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
10001640:	b580      	push	{r7, lr}
10001642:	b082      	sub	sp, #8
10001644:	af00      	add	r7, sp, #0
10001646:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
10001648:	687b      	ldr	r3, [r7, #4]
1000164a:	2280      	movs	r2, #128	; 0x80
1000164c:	0052      	lsls	r2, r2, #1
1000164e:	60da      	str	r2, [r3, #12]
}
10001650:	46bd      	mov	sp, r7
10001652:	b002      	add	sp, #8
10001654:	bd80      	pop	{r7, pc}
10001656:	46c0      	nop			; (mov r8, r8)

10001658 <XMC_CCU4_lUngateClock>:
    XMC_ASSERT("XMC_CCU4_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
10001658:	b580      	push	{r7, lr}
1000165a:	b082      	sub	sp, #8
1000165c:	af00      	add	r7, sp, #0
1000165e:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
10001660:	687b      	ldr	r3, [r7, #4]
10001662:	4a09      	ldr	r2, [pc, #36]	; (10001688 <XMC_CCU4_lUngateClock+0x30>)
10001664:	4293      	cmp	r3, r2
10001666:	d103      	bne.n	10001670 <XMC_CCU4_lUngateClock+0x18>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
10001668:	2004      	movs	r0, #4
1000166a:	f7ff ff19 	bl	100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>
1000166e:	e008      	b.n	10001682 <XMC_CCU4_lUngateClock+0x2a>
  }
#if defined(CCU41)
  else if (module == CCU41)
10001670:	687b      	ldr	r3, [r7, #4]
10001672:	4a06      	ldr	r2, [pc, #24]	; (1000168c <XMC_CCU4_lUngateClock+0x34>)
10001674:	4293      	cmp	r3, r2
10001676:	d104      	bne.n	10001682 <XMC_CCU4_lUngateClock+0x2a>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
10001678:	2380      	movs	r3, #128	; 0x80
1000167a:	029b      	lsls	r3, r3, #10
1000167c:	1c18      	adds	r0, r3, #0
1000167e:	f7ff ff0f 	bl	100014a0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
  }
}
10001682:	46bd      	mov	sp, r7
10001684:	b002      	add	sp, #8
10001686:	bd80      	pop	{r7, pc}
10001688:	48040000 	.word	0x48040000
1000168c:	48044000 	.word	0x48044000

10001690 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
10001690:	b580      	push	{r7, lr}
10001692:	b082      	sub	sp, #8
10001694:	af00      	add	r7, sp, #0
10001696:	6078      	str	r0, [r7, #4]
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
10001698:	687b      	ldr	r3, [r7, #4]
1000169a:	1c18      	adds	r0, r3, #0
1000169c:	f7ff ffdc 	bl	10001658 <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
#endif
}
100016a0:	46bd      	mov	sp, r7
100016a2:	b002      	add	sp, #8
100016a4:	bd80      	pop	{r7, pc}
100016a6:	46c0      	nop			; (mov r8, r8)

100016a8 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
100016a8:	b580      	push	{r7, lr}
100016aa:	b084      	sub	sp, #16
100016ac:	af00      	add	r7, sp, #0
100016ae:	6078      	str	r0, [r7, #4]
100016b0:	1c0a      	adds	r2, r1, #0
100016b2:	1cfb      	adds	r3, r7, #3
100016b4:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
100016b6:	687b      	ldr	r3, [r7, #4]
100016b8:	1c18      	adds	r0, r3, #0
100016ba:	f7ff ffe9 	bl	10001690 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
100016be:	687b      	ldr	r3, [r7, #4]
100016c0:	1c18      	adds	r0, r3, #0
100016c2:	f7ff ffbd 	bl	10001640 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
100016c6:	687b      	ldr	r3, [r7, #4]
100016c8:	681b      	ldr	r3, [r3, #0]
100016ca:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
100016cc:	68fb      	ldr	r3, [r7, #12]
100016ce:	4a07      	ldr	r2, [pc, #28]	; (100016ec <XMC_CCU4_Init+0x44>)
100016d0:	4013      	ands	r3, r2
100016d2:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
100016d4:	1cfb      	adds	r3, r7, #3
100016d6:	781b      	ldrb	r3, [r3, #0]
100016d8:	039b      	lsls	r3, r3, #14
100016da:	68fa      	ldr	r2, [r7, #12]
100016dc:	4313      	orrs	r3, r2
100016de:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
100016e0:	687b      	ldr	r3, [r7, #4]
100016e2:	68fa      	ldr	r2, [r7, #12]
100016e4:	601a      	str	r2, [r3, #0]
}
100016e6:	46bd      	mov	sp, r7
100016e8:	b004      	add	sp, #16
100016ea:	bd80      	pop	{r7, pc}
100016ec:	ffff3fff 	.word	0xffff3fff

100016f0 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
100016f0:	b580      	push	{r7, lr}
100016f2:	b082      	sub	sp, #8
100016f4:	af00      	add	r7, sp, #0
100016f6:	6078      	str	r0, [r7, #4]
100016f8:	1c08      	adds	r0, r1, #0
100016fa:	1c11      	adds	r1, r2, #0
100016fc:	1cfb      	adds	r3, r7, #3
100016fe:	1c02      	adds	r2, r0, #0
10001700:	701a      	strb	r2, [r3, #0]
10001702:	1cbb      	adds	r3, r7, #2
10001704:	1c0a      	adds	r2, r1, #0
10001706:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10001708:	687b      	ldr	r3, [r7, #4]
1000170a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
1000170c:	1cfa      	adds	r2, r7, #3
1000170e:	7812      	ldrb	r2, [r2, #0]
10001710:	0052      	lsls	r2, r2, #1
10001712:	1c11      	adds	r1, r2, #0
10001714:	2203      	movs	r2, #3
10001716:	408a      	lsls	r2, r1
10001718:	43d2      	mvns	r2, r2
1000171a:	401a      	ands	r2, r3
1000171c:	687b      	ldr	r3, [r7, #4]
1000171e:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
10001720:	687b      	ldr	r3, [r7, #4]
10001722:	6f5a      	ldr	r2, [r3, #116]	; 0x74
10001724:	1cbb      	adds	r3, r7, #2
10001726:	781b      	ldrb	r3, [r3, #0]
10001728:	1cf9      	adds	r1, r7, #3
1000172a:	7809      	ldrb	r1, [r1, #0]
1000172c:	0049      	lsls	r1, r1, #1
1000172e:	408b      	lsls	r3, r1
10001730:	431a      	orrs	r2, r3
10001732:	687b      	ldr	r3, [r7, #4]
10001734:	675a      	str	r2, [r3, #116]	; 0x74
}
10001736:	46bd      	mov	sp, r7
10001738:	b002      	add	sp, #8
1000173a:	bd80      	pop	{r7, pc}

1000173c <__aeabi_uidiv>:
/***********************************************************************************************************************
 * API IMPLEMENTATION - aeabi routines
 **********************************************************************************************************************/
/* This function performs unsigned integer division */
uint32_t __aeabi_uidiv(uint32_t dividend, uint32_t divisor)
{
1000173c:	b580      	push	{r7, lr}
1000173e:	b088      	sub	sp, #32
10001740:	af00      	add	r7, sp, #0
10001742:	6078      	str	r0, [r7, #4]
10001744:	6039      	str	r1, [r7, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
10001746:	f3ef 8310 	mrs	r3, PRIMASK
1000174a:	617b      	str	r3, [r7, #20]
  return(result);
1000174c:	697b      	ldr	r3, [r7, #20]
 * API IMPLEMENTATION - Utility functions
 ********************************************************************************************************************/
__attribute__((always_inline)) __STATIC_INLINE uint32_t critical_section_enter(void)
{
  uint32_t status;
  status = __get_PRIMASK();
1000174e:	613b      	str	r3, [r7, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10001750:	b672      	cpsid	i
  __disable_irq ();
  return status;
10001752:	693b      	ldr	r3, [r7, #16]
/* This function performs unsigned integer division */
uint32_t __aeabi_uidiv(uint32_t dividend, uint32_t divisor)
{
  uint32_t result;
  uint32_t ics;
  ics = critical_section_enter();
10001754:	61fb      	str	r3, [r7, #28]

  MATH->DIVCON  = XMC_MATH_UNSIGNED_DIVISION;
10001756:	4b0c      	ldr	r3, [pc, #48]	; (10001788 <__aeabi_uidiv+0x4c>)
10001758:	2204      	movs	r2, #4
1000175a:	635a      	str	r2, [r3, #52]	; 0x34
  MATH->DVD     = dividend;
1000175c:	4b0a      	ldr	r3, [pc, #40]	; (10001788 <__aeabi_uidiv+0x4c>)
1000175e:	687a      	ldr	r2, [r7, #4]
10001760:	621a      	str	r2, [r3, #32]
  MATH->DVS     = divisor;
10001762:	4b09      	ldr	r3, [pc, #36]	; (10001788 <__aeabi_uidiv+0x4c>)
10001764:	683a      	ldr	r2, [r7, #0]
10001766:	625a      	str	r2, [r3, #36]	; 0x24

  result = MATH->QUOT;
10001768:	4b07      	ldr	r3, [pc, #28]	; (10001788 <__aeabi_uidiv+0x4c>)
1000176a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
1000176c:	61bb      	str	r3, [r7, #24]
1000176e:	69fb      	ldr	r3, [r7, #28]
10001770:	60fb      	str	r3, [r7, #12]
10001772:	68fb      	ldr	r3, [r7, #12]
10001774:	60bb      	str	r3, [r7, #8]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
10001776:	68bb      	ldr	r3, [r7, #8]
10001778:	f383 8810 	msr	PRIMASK, r3

  critical_section_exit(ics);

  return result;
1000177c:	69bb      	ldr	r3, [r7, #24]
}
1000177e:	1c18      	adds	r0, r3, #0
10001780:	46bd      	mov	sp, r7
10001782:	b008      	add	sp, #32
10001784:	bd80      	pop	{r7, pc}
10001786:	46c0      	nop			; (mov r8, r8)
10001788:	40030000 	.word	0x40030000

1000178c <_init>:
  }
}

/* Init */
void _init(void)
{}
1000178c:	b580      	push	{r7, lr}
1000178e:	af00      	add	r7, sp, #0
10001790:	46bd      	mov	sp, r7
10001792:	bd80      	pop	{r7, pc}

10001794 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
10001794:	b580      	push	{r7, lr}
10001796:	b082      	sub	sp, #8
10001798:	af00      	add	r7, sp, #0
1000179a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
1000179c:	687b      	ldr	r3, [r7, #4]
1000179e:	2280      	movs	r2, #128	; 0x80
100017a0:	0052      	lsls	r2, r2, #1
100017a2:	60da      	str	r2, [r3, #12]
}
100017a4:	46bd      	mov	sp, r7
100017a6:	b002      	add	sp, #8
100017a8:	bd80      	pop	{r7, pc}
100017aa:	46c0      	nop			; (mov r8, r8)

100017ac <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
100017ac:	b580      	push	{r7, lr}
100017ae:	b082      	sub	sp, #8
100017b0:	af00      	add	r7, sp, #0
100017b2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
100017b4:	687b      	ldr	r3, [r7, #4]
100017b6:	7b5b      	ldrb	r3, [r3, #13]
100017b8:	2201      	movs	r2, #1
100017ba:	4053      	eors	r3, r2
100017bc:	b2db      	uxtb	r3, r3
100017be:	2b00      	cmp	r3, #0
100017c0:	d00f      	beq.n	100017e2 <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
100017c2:	687b      	ldr	r3, [r7, #4]
100017c4:	689a      	ldr	r2, [r3, #8]
100017c6:	687b      	ldr	r3, [r7, #4]
100017c8:	7b1b      	ldrb	r3, [r3, #12]
100017ca:	1c10      	adds	r0, r2, #0
100017cc:	1c19      	adds	r1, r3, #0
100017ce:	f7ff ff6b 	bl	100016a8 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
100017d2:	687b      	ldr	r3, [r7, #4]
100017d4:	689b      	ldr	r3, [r3, #8]
100017d6:	1c18      	adds	r0, r3, #0
100017d8:	f7ff ffdc 	bl	10001794 <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
100017dc:	687b      	ldr	r3, [r7, #4]
100017de:	2201      	movs	r2, #1
100017e0:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
100017e2:	2300      	movs	r3, #0
}
100017e4:	1c18      	adds	r0, r3, #0
100017e6:	46bd      	mov	sp, r7
100017e8:	b002      	add	sp, #8
100017ea:	bd80      	pop	{r7, pc}

100017ec <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
100017ec:	b580      	push	{r7, lr}
100017ee:	b084      	sub	sp, #16
100017f0:	af00      	add	r7, sp, #0
100017f2:	60f8      	str	r0, [r7, #12]
100017f4:	60b9      	str	r1, [r7, #8]
100017f6:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                          /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
100017f8:	68fb      	ldr	r3, [r7, #12]
100017fa:	3b04      	subs	r3, #4
100017fc:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
100017fe:	68fb      	ldr	r3, [r7, #12]
10001800:	2280      	movs	r2, #128	; 0x80
10001802:	0452      	lsls	r2, r2, #17
10001804:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10001806:	68fb      	ldr	r3, [r7, #12]
10001808:	3b04      	subs	r3, #4
1000180a:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
1000180c:	68ba      	ldr	r2, [r7, #8]
1000180e:	68fb      	ldr	r3, [r7, #12]
10001810:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
10001812:	68fb      	ldr	r3, [r7, #12]
10001814:	3b04      	subs	r3, #4
10001816:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
10001818:	4a08      	ldr	r2, [pc, #32]	; (1000183c <pxPortInitialiseStack+0x50>)
1000181a:	68fb      	ldr	r3, [r7, #12]
1000181c:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
1000181e:	68fb      	ldr	r3, [r7, #12]
10001820:	3b14      	subs	r3, #20
10001822:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
10001824:	687a      	ldr	r2, [r7, #4]
10001826:	68fb      	ldr	r3, [r7, #12]
10001828:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                       /* R11..R4. */
1000182a:	68fb      	ldr	r3, [r7, #12]
1000182c:	3b20      	subs	r3, #32
1000182e:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
10001830:	68fb      	ldr	r3, [r7, #12]
}
10001832:	1c18      	adds	r0, r3, #0
10001834:	46bd      	mov	sp, r7
10001836:	b004      	add	sp, #16
10001838:	bd80      	pop	{r7, pc}
1000183a:	46c0      	nop			; (mov r8, r8)
1000183c:	10001841 	.word	0x10001841

10001840 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
10001840:	b580      	push	{r7, lr}
10001842:	b082      	sub	sp, #8
10001844:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
10001846:	2300      	movs	r3, #0
10001848:	607b      	str	r3, [r7, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
1000184a:	4b07      	ldr	r3, [pc, #28]	; (10001868 <prvTaskExitError+0x28>)
1000184c:	681b      	ldr	r3, [r3, #0]
1000184e:	3301      	adds	r3, #1
10001850:	d001      	beq.n	10001856 <prvTaskExitError+0x16>
10001852:	b672      	cpsid	i
10001854:	e7fe      	b.n	10001854 <prvTaskExitError+0x14>
    portDISABLE_INTERRUPTS();
10001856:	b672      	cpsid	i

    while( ulDummy == 0 )
10001858:	46c0      	nop			; (mov r8, r8)
1000185a:	687b      	ldr	r3, [r7, #4]
1000185c:	2b00      	cmp	r3, #0
1000185e:	d0fc      	beq.n	1000185a <prvTaskExitError+0x1a>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
10001860:	46bd      	mov	sp, r7
10001862:	b002      	add	sp, #8
10001864:	bd80      	pop	{r7, pc}
10001866:	46c0      	nop			; (mov r8, r8)
10001868:	20000560 	.word	0x20000560

1000186c <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
1000186c:	b580      	push	{r7, lr}
1000186e:	af00      	add	r7, sp, #0
    /* This function is no longer used, but retained for backward
     * compatibility. */
}
10001870:	46bd      	mov	sp, r7
10001872:	bd80      	pop	{r7, pc}
	...

10001880 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
10001880:	4a0b      	ldr	r2, [pc, #44]	; (100018b0 <pxCurrentTCBConst2>)
10001882:	6813      	ldr	r3, [r2, #0]
10001884:	6818      	ldr	r0, [r3, #0]
10001886:	3020      	adds	r0, #32
10001888:	f380 8809 	msr	PSP, r0
1000188c:	2002      	movs	r0, #2
1000188e:	f380 8814 	msr	CONTROL, r0
10001892:	f3bf 8f6f 	isb	sy
10001896:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
10001898:	46ae      	mov	lr, r5
1000189a:	bc08      	pop	{r3}
1000189c:	bc04      	pop	{r2}
1000189e:	b662      	cpsie	i
100018a0:	4718      	bx	r3
100018a2:	46c0      	nop			; (mov r8, r8)
100018a4:	46c0      	nop			; (mov r8, r8)
100018a6:	46c0      	nop			; (mov r8, r8)
100018a8:	46c0      	nop			; (mov r8, r8)
100018aa:	46c0      	nop			; (mov r8, r8)
100018ac:	46c0      	nop			; (mov r8, r8)
100018ae:	46c0      	nop			; (mov r8, r8)

100018b0 <pxCurrentTCBConst2>:
100018b0:	20002ca0 	.word	0x20002ca0
100018b4:	46c0      	nop			; (mov r8, r8)
100018b6:	46c0      	nop			; (mov r8, r8)
100018b8:	46c0      	nop			; (mov r8, r8)
100018ba:	46c0      	nop			; (mov r8, r8)
100018bc:	46c0      	nop			; (mov r8, r8)
100018be:	46c0      	nop			; (mov r8, r8)

100018c0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
100018c0:	b580      	push	{r7, lr}
100018c2:	af00      	add	r7, sp, #0
    /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
100018c4:	4b0e      	ldr	r3, [pc, #56]	; (10001900 <xPortStartScheduler+0x40>)
100018c6:	4a0e      	ldr	r2, [pc, #56]	; (10001900 <xPortStartScheduler+0x40>)
100018c8:	6812      	ldr	r2, [r2, #0]
100018ca:	21ff      	movs	r1, #255	; 0xff
100018cc:	0409      	lsls	r1, r1, #16
100018ce:	430a      	orrs	r2, r1
100018d0:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
100018d2:	4b0b      	ldr	r3, [pc, #44]	; (10001900 <xPortStartScheduler+0x40>)
100018d4:	4a0a      	ldr	r2, [pc, #40]	; (10001900 <xPortStartScheduler+0x40>)
100018d6:	6812      	ldr	r2, [r2, #0]
100018d8:	21ff      	movs	r1, #255	; 0xff
100018da:	0609      	lsls	r1, r1, #24
100018dc:	430a      	orrs	r2, r1
100018de:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
100018e0:	f000 f896 	bl	10001a10 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
100018e4:	4b07      	ldr	r3, [pc, #28]	; (10001904 <xPortStartScheduler+0x44>)
100018e6:	2200      	movs	r2, #0
100018e8:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    vPortStartFirstTask();
100018ea:	f7ff ffc9 	bl	10001880 <vPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
100018ee:	f001 faf1 	bl	10002ed4 <vTaskSwitchContext>
    prvTaskExitError();
100018f2:	f7ff ffa5 	bl	10001840 <prvTaskExitError>

    /* Should not get here! */
    return 0;
100018f6:	2300      	movs	r3, #0
}
100018f8:	1c18      	adds	r0, r3, #0
100018fa:	46bd      	mov	sp, r7
100018fc:	bd80      	pop	{r7, pc}
100018fe:	46c0      	nop			; (mov r8, r8)
10001900:	e000ed20 	.word	0xe000ed20
10001904:	20000560 	.word	0x20000560

10001908 <vPortYield>:
    configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
10001908:	b580      	push	{r7, lr}
1000190a:	af00      	add	r7, sp, #0
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
1000190c:	4b04      	ldr	r3, [pc, #16]	; (10001920 <vPortYield+0x18>)
1000190e:	2280      	movs	r2, #128	; 0x80
10001910:	0552      	lsls	r2, r2, #21
10001912:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
10001914:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10001918:	f3bf 8f6f 	isb	sy
}
1000191c:	46bd      	mov	sp, r7
1000191e:	bd80      	pop	{r7, pc}
10001920:	e000ed04 	.word	0xe000ed04

10001924 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
10001924:	b580      	push	{r7, lr}
10001926:	af00      	add	r7, sp, #0
    portDISABLE_INTERRUPTS();
10001928:	b672      	cpsid	i
    uxCriticalNesting++;
1000192a:	4b05      	ldr	r3, [pc, #20]	; (10001940 <vPortEnterCritical+0x1c>)
1000192c:	681b      	ldr	r3, [r3, #0]
1000192e:	1c5a      	adds	r2, r3, #1
10001930:	4b03      	ldr	r3, [pc, #12]	; (10001940 <vPortEnterCritical+0x1c>)
10001932:	601a      	str	r2, [r3, #0]
    __asm volatile ( "dsb" ::: "memory" );
10001934:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
10001938:	f3bf 8f6f 	isb	sy
}
1000193c:	46bd      	mov	sp, r7
1000193e:	bd80      	pop	{r7, pc}
10001940:	20000560 	.word	0x20000560

10001944 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
10001944:	b580      	push	{r7, lr}
10001946:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
10001948:	4b08      	ldr	r3, [pc, #32]	; (1000196c <vPortExitCritical+0x28>)
1000194a:	681b      	ldr	r3, [r3, #0]
1000194c:	2b00      	cmp	r3, #0
1000194e:	d101      	bne.n	10001954 <vPortExitCritical+0x10>
10001950:	b672      	cpsid	i
10001952:	e7fe      	b.n	10001952 <vPortExitCritical+0xe>
    uxCriticalNesting--;
10001954:	4b05      	ldr	r3, [pc, #20]	; (1000196c <vPortExitCritical+0x28>)
10001956:	681b      	ldr	r3, [r3, #0]
10001958:	1e5a      	subs	r2, r3, #1
1000195a:	4b04      	ldr	r3, [pc, #16]	; (1000196c <vPortExitCritical+0x28>)
1000195c:	601a      	str	r2, [r3, #0]

    if( uxCriticalNesting == 0 )
1000195e:	4b03      	ldr	r3, [pc, #12]	; (1000196c <vPortExitCritical+0x28>)
10001960:	681b      	ldr	r3, [r3, #0]
10001962:	2b00      	cmp	r3, #0
10001964:	d100      	bne.n	10001968 <vPortExitCritical+0x24>
    {
        portENABLE_INTERRUPTS();
10001966:	b662      	cpsie	i
    }
}
10001968:	46bd      	mov	sp, r7
1000196a:	bd80      	pop	{r7, pc}
1000196c:	20000560 	.word	0x20000560

10001970 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
10001970:	f3ef 8010 	mrs	r0, PRIMASK
10001974:	b672      	cpsid	i
10001976:	4770      	bx	lr
        " mrs r0, PRIMASK	\n"
        " cpsid i			\n"
        " bx lr				  "
        ::: "memory"
        );
}
10001978:	1c18      	adds	r0, r3, #0
1000197a:	46c0      	nop			; (mov r8, r8)

1000197c <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
1000197c:	f380 8810 	msr	PRIMASK, r0
10001980:	4770      	bx	lr
10001982:	46c0      	nop			; (mov r8, r8)
	...

10001990 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
10001990:	f3ef 8009 	mrs	r0, PSP
10001994:	4b0e      	ldr	r3, [pc, #56]	; (100019d0 <pxCurrentTCBConst>)
10001996:	681a      	ldr	r2, [r3, #0]
10001998:	3820      	subs	r0, #32
1000199a:	6010      	str	r0, [r2, #0]
1000199c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
1000199e:	4644      	mov	r4, r8
100019a0:	464d      	mov	r5, r9
100019a2:	4656      	mov	r6, sl
100019a4:	465f      	mov	r7, fp
100019a6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
100019a8:	b508      	push	{r3, lr}
100019aa:	b672      	cpsid	i
100019ac:	f001 fa92 	bl	10002ed4 <vTaskSwitchContext>
100019b0:	b662      	cpsie	i
100019b2:	bc0c      	pop	{r2, r3}
100019b4:	6811      	ldr	r1, [r2, #0]
100019b6:	6808      	ldr	r0, [r1, #0]
100019b8:	3010      	adds	r0, #16
100019ba:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
100019bc:	46a0      	mov	r8, r4
100019be:	46a9      	mov	r9, r5
100019c0:	46b2      	mov	sl, r6
100019c2:	46bb      	mov	fp, r7
100019c4:	f380 8809 	msr	PSP, r0
100019c8:	3820      	subs	r0, #32
100019ca:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
100019cc:	4718      	bx	r3
100019ce:	46c0      	nop			; (mov r8, r8)

100019d0 <pxCurrentTCBConst>:
100019d0:	20002ca0 	.word	0x20002ca0
100019d4:	46c0      	nop			; (mov r8, r8)
100019d6:	46c0      	nop			; (mov r8, r8)
100019d8:	46c0      	nop			; (mov r8, r8)
100019da:	46c0      	nop			; (mov r8, r8)
100019dc:	46c0      	nop			; (mov r8, r8)
100019de:	46c0      	nop			; (mov r8, r8)

100019e0 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
100019e0:	b580      	push	{r7, lr}
100019e2:	b082      	sub	sp, #8
100019e4:	af00      	add	r7, sp, #0
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
100019e6:	f7ff ffc3 	bl	10001970 <ulSetInterruptMaskFromISR>
100019ea:	1c03      	adds	r3, r0, #0
100019ec:	607b      	str	r3, [r7, #4]
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
100019ee:	f001 f9c1 	bl	10002d74 <xTaskIncrementTick>
100019f2:	1e03      	subs	r3, r0, #0
100019f4:	d003      	beq.n	100019fe <SysTick_Handler+0x1e>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
100019f6:	4b05      	ldr	r3, [pc, #20]	; (10001a0c <SysTick_Handler+0x2c>)
100019f8:	2280      	movs	r2, #128	; 0x80
100019fa:	0552      	lsls	r2, r2, #21
100019fc:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
100019fe:	687b      	ldr	r3, [r7, #4]
10001a00:	1c18      	adds	r0, r3, #0
10001a02:	f7ff ffbb 	bl	1000197c <vClearInterruptMaskFromISR>
}
10001a06:	46bd      	mov	sp, r7
10001a08:	b002      	add	sp, #8
10001a0a:	bd80      	pop	{r7, pc}
10001a0c:	e000ed04 	.word	0xe000ed04

10001a10 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
10001a10:	b598      	push	{r3, r4, r7, lr}
10001a12:	af00      	add	r7, sp, #0
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
10001a14:	4b0a      	ldr	r3, [pc, #40]	; (10001a40 <vPortSetupTimerInterrupt+0x30>)
10001a16:	2200      	movs	r2, #0
10001a18:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
10001a1a:	4b0a      	ldr	r3, [pc, #40]	; (10001a44 <vPortSetupTimerInterrupt+0x34>)
10001a1c:	2200      	movs	r2, #0
10001a1e:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
10001a20:	4c09      	ldr	r4, [pc, #36]	; (10001a48 <vPortSetupTimerInterrupt+0x38>)
10001a22:	4b0a      	ldr	r3, [pc, #40]	; (10001a4c <vPortSetupTimerInterrupt+0x3c>)
10001a24:	681b      	ldr	r3, [r3, #0]
10001a26:	1c18      	adds	r0, r3, #0
10001a28:	210a      	movs	r1, #10
10001a2a:	f7ff fe87 	bl	1000173c <__aeabi_uidiv>
10001a2e:	1c03      	adds	r3, r0, #0
10001a30:	3b01      	subs	r3, #1
10001a32:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
10001a34:	4b02      	ldr	r3, [pc, #8]	; (10001a40 <vPortSetupTimerInterrupt+0x30>)
10001a36:	2207      	movs	r2, #7
10001a38:	601a      	str	r2, [r3, #0]
}
10001a3a:	46bd      	mov	sp, r7
10001a3c:	bd98      	pop	{r3, r4, r7, pc}
10001a3e:	46c0      	nop			; (mov r8, r8)
10001a40:	e000e010 	.word	0xe000e010
10001a44:	e000e018 	.word	0xe000e018
10001a48:	e000e014 	.word	0xe000e014
10001a4c:	20003ffc 	.word	0x20003ffc

10001a50 <pvPortMalloc>:
PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
10001a50:	b580      	push	{r7, lr}
10001a52:	b086      	sub	sp, #24
10001a54:	af00      	add	r7, sp, #0
10001a56:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    void * pvReturn = NULL;
10001a58:	2300      	movs	r3, #0
10001a5a:	60fb      	str	r3, [r7, #12]

    vTaskSuspendAll();
10001a5c:	f001 f8e4 	bl	10002c28 <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
10001a60:	4b4b      	ldr	r3, [pc, #300]	; (10001b90 <pvPortMalloc+0x140>)
10001a62:	681b      	ldr	r3, [r3, #0]
10001a64:	2b00      	cmp	r3, #0
10001a66:	d101      	bne.n	10001a6c <pvPortMalloc+0x1c>
        {
            prvHeapInit();
10001a68:	f000 f8ec 	bl	10001c44 <prvHeapInit>

        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
10001a6c:	4b49      	ldr	r3, [pc, #292]	; (10001b94 <pvPortMalloc+0x144>)
10001a6e:	681b      	ldr	r3, [r3, #0]
10001a70:	687a      	ldr	r2, [r7, #4]
10001a72:	4013      	ands	r3, r2
10001a74:	d000      	beq.n	10001a78 <pvPortMalloc+0x28>
10001a76:	e07e      	b.n	10001b76 <pvPortMalloc+0x126>
        {
            /* The wanted size is increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( xWantedSize > 0 )
10001a78:	687b      	ldr	r3, [r7, #4]
10001a7a:	2b00      	cmp	r3, #0
10001a7c:	d012      	beq.n	10001aa4 <pvPortMalloc+0x54>
            {
                xWantedSize += xHeapStructSize;
10001a7e:	2208      	movs	r2, #8
10001a80:	687b      	ldr	r3, [r7, #4]
10001a82:	189b      	adds	r3, r3, r2
10001a84:	607b      	str	r3, [r7, #4]

                /* Ensure that blocks are always aligned to the required number
                 * of bytes. */
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
10001a86:	687b      	ldr	r3, [r7, #4]
10001a88:	2207      	movs	r2, #7
10001a8a:	4013      	ands	r3, r2
10001a8c:	d00a      	beq.n	10001aa4 <pvPortMalloc+0x54>
                {
                    /* Byte alignment required. */
                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
10001a8e:	687b      	ldr	r3, [r7, #4]
10001a90:	2207      	movs	r2, #7
10001a92:	4393      	bics	r3, r2
10001a94:	3308      	adds	r3, #8
10001a96:	607b      	str	r3, [r7, #4]
                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
10001a98:	687b      	ldr	r3, [r7, #4]
10001a9a:	2207      	movs	r2, #7
10001a9c:	4013      	ands	r3, r2
10001a9e:	d001      	beq.n	10001aa4 <pvPortMalloc+0x54>
10001aa0:	b672      	cpsid	i
10001aa2:	e7fe      	b.n	10001aa2 <pvPortMalloc+0x52>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
10001aa4:	687b      	ldr	r3, [r7, #4]
10001aa6:	2b00      	cmp	r3, #0
10001aa8:	d065      	beq.n	10001b76 <pvPortMalloc+0x126>
10001aaa:	4b3b      	ldr	r3, [pc, #236]	; (10001b98 <pvPortMalloc+0x148>)
10001aac:	681b      	ldr	r3, [r3, #0]
10001aae:	687a      	ldr	r2, [r7, #4]
10001ab0:	429a      	cmp	r2, r3
10001ab2:	d860      	bhi.n	10001b76 <pvPortMalloc+0x126>
            {
                /* Traverse the list from the start	(lowest address) block until
                 * one	of adequate size is found. */
                pxPreviousBlock = &xStart;
10001ab4:	4b39      	ldr	r3, [pc, #228]	; (10001b9c <pvPortMalloc+0x14c>)
10001ab6:	613b      	str	r3, [r7, #16]
                pxBlock = xStart.pxNextFreeBlock;
10001ab8:	4b38      	ldr	r3, [pc, #224]	; (10001b9c <pvPortMalloc+0x14c>)
10001aba:	681b      	ldr	r3, [r3, #0]
10001abc:	617b      	str	r3, [r7, #20]

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
10001abe:	e004      	b.n	10001aca <pvPortMalloc+0x7a>
                {
                    pxPreviousBlock = pxBlock;
10001ac0:	697b      	ldr	r3, [r7, #20]
10001ac2:	613b      	str	r3, [r7, #16]
                    pxBlock = pxBlock->pxNextFreeBlock;
10001ac4:	697b      	ldr	r3, [r7, #20]
10001ac6:	681b      	ldr	r3, [r3, #0]
10001ac8:	617b      	str	r3, [r7, #20]
                /* Traverse the list from the start	(lowest address) block until
                 * one	of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
10001aca:	697b      	ldr	r3, [r7, #20]
10001acc:	685a      	ldr	r2, [r3, #4]
10001ace:	687b      	ldr	r3, [r7, #4]
10001ad0:	429a      	cmp	r2, r3
10001ad2:	d203      	bcs.n	10001adc <pvPortMalloc+0x8c>
10001ad4:	697b      	ldr	r3, [r7, #20]
10001ad6:	681b      	ldr	r3, [r3, #0]
10001ad8:	2b00      	cmp	r3, #0
10001ada:	d1f1      	bne.n	10001ac0 <pvPortMalloc+0x70>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was	not found. */
                if( pxBlock != pxEnd )
10001adc:	4b2c      	ldr	r3, [pc, #176]	; (10001b90 <pvPortMalloc+0x140>)
10001ade:	681b      	ldr	r3, [r3, #0]
10001ae0:	697a      	ldr	r2, [r7, #20]
10001ae2:	429a      	cmp	r2, r3
10001ae4:	d047      	beq.n	10001b76 <pvPortMalloc+0x126>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
10001ae6:	693b      	ldr	r3, [r7, #16]
10001ae8:	681b      	ldr	r3, [r3, #0]
10001aea:	2208      	movs	r2, #8
10001aec:	189b      	adds	r3, r3, r2
10001aee:	60fb      	str	r3, [r7, #12]

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
10001af0:	697b      	ldr	r3, [r7, #20]
10001af2:	681a      	ldr	r2, [r3, #0]
10001af4:	693b      	ldr	r3, [r7, #16]
10001af6:	601a      	str	r2, [r3, #0]

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
10001af8:	697b      	ldr	r3, [r7, #20]
10001afa:	685a      	ldr	r2, [r3, #4]
10001afc:	687b      	ldr	r3, [r7, #4]
10001afe:	1ad2      	subs	r2, r2, r3
10001b00:	2308      	movs	r3, #8
10001b02:	005b      	lsls	r3, r3, #1
10001b04:	429a      	cmp	r2, r3
10001b06:	d916      	bls.n	10001b36 <pvPortMalloc+0xe6>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
10001b08:	697a      	ldr	r2, [r7, #20]
10001b0a:	687b      	ldr	r3, [r7, #4]
10001b0c:	18d3      	adds	r3, r2, r3
10001b0e:	60bb      	str	r3, [r7, #8]
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
10001b10:	68bb      	ldr	r3, [r7, #8]
10001b12:	2207      	movs	r2, #7
10001b14:	4013      	ands	r3, r2
10001b16:	d001      	beq.n	10001b1c <pvPortMalloc+0xcc>
10001b18:	b672      	cpsid	i
10001b1a:	e7fe      	b.n	10001b1a <pvPortMalloc+0xca>

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
10001b1c:	697b      	ldr	r3, [r7, #20]
10001b1e:	685a      	ldr	r2, [r3, #4]
10001b20:	687b      	ldr	r3, [r7, #4]
10001b22:	1ad2      	subs	r2, r2, r3
10001b24:	68bb      	ldr	r3, [r7, #8]
10001b26:	605a      	str	r2, [r3, #4]
                        pxBlock->xBlockSize = xWantedSize;
10001b28:	697b      	ldr	r3, [r7, #20]
10001b2a:	687a      	ldr	r2, [r7, #4]
10001b2c:	605a      	str	r2, [r3, #4]

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
10001b2e:	68bb      	ldr	r3, [r7, #8]
10001b30:	1c18      	adds	r0, r3, #0
10001b32:	f000 f8e7 	bl	10001d04 <prvInsertBlockIntoFreeList>
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
10001b36:	4b18      	ldr	r3, [pc, #96]	; (10001b98 <pvPortMalloc+0x148>)
10001b38:	681a      	ldr	r2, [r3, #0]
10001b3a:	697b      	ldr	r3, [r7, #20]
10001b3c:	685b      	ldr	r3, [r3, #4]
10001b3e:	1ad2      	subs	r2, r2, r3
10001b40:	4b15      	ldr	r3, [pc, #84]	; (10001b98 <pvPortMalloc+0x148>)
10001b42:	601a      	str	r2, [r3, #0]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
10001b44:	4b14      	ldr	r3, [pc, #80]	; (10001b98 <pvPortMalloc+0x148>)
10001b46:	681a      	ldr	r2, [r3, #0]
10001b48:	4b15      	ldr	r3, [pc, #84]	; (10001ba0 <pvPortMalloc+0x150>)
10001b4a:	681b      	ldr	r3, [r3, #0]
10001b4c:	429a      	cmp	r2, r3
10001b4e:	d203      	bcs.n	10001b58 <pvPortMalloc+0x108>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
10001b50:	4b11      	ldr	r3, [pc, #68]	; (10001b98 <pvPortMalloc+0x148>)
10001b52:	681a      	ldr	r2, [r3, #0]
10001b54:	4b12      	ldr	r3, [pc, #72]	; (10001ba0 <pvPortMalloc+0x150>)
10001b56:	601a      	str	r2, [r3, #0]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
10001b58:	697b      	ldr	r3, [r7, #20]
10001b5a:	685a      	ldr	r2, [r3, #4]
10001b5c:	4b0d      	ldr	r3, [pc, #52]	; (10001b94 <pvPortMalloc+0x144>)
10001b5e:	681b      	ldr	r3, [r3, #0]
10001b60:	431a      	orrs	r2, r3
10001b62:	697b      	ldr	r3, [r7, #20]
10001b64:	605a      	str	r2, [r3, #4]
                    pxBlock->pxNextFreeBlock = NULL;
10001b66:	697b      	ldr	r3, [r7, #20]
10001b68:	2200      	movs	r2, #0
10001b6a:	601a      	str	r2, [r3, #0]
                    xNumberOfSuccessfulAllocations++;
10001b6c:	4b0d      	ldr	r3, [pc, #52]	; (10001ba4 <pvPortMalloc+0x154>)
10001b6e:	681b      	ldr	r3, [r3, #0]
10001b70:	1c5a      	adds	r2, r3, #1
10001b72:	4b0c      	ldr	r3, [pc, #48]	; (10001ba4 <pvPortMalloc+0x154>)
10001b74:	601a      	str	r2, [r3, #0]
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
10001b76:	f001 f863 	bl	10002c40 <xTaskResumeAll>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
10001b7a:	68fb      	ldr	r3, [r7, #12]
10001b7c:	2207      	movs	r2, #7
10001b7e:	4013      	ands	r3, r2
10001b80:	d001      	beq.n	10001b86 <pvPortMalloc+0x136>
10001b82:	b672      	cpsid	i
10001b84:	e7fe      	b.n	10001b84 <pvPortMalloc+0x134>
    return pvReturn;
10001b86:	68fb      	ldr	r3, [r7, #12]
}
10001b88:	1c18      	adds	r0, r3, #0
10001b8a:	46bd      	mov	sp, r7
10001b8c:	b006      	add	sp, #24
10001b8e:	bd80      	pop	{r7, pc}
10001b90:	20002c88 	.word	0x20002c88
10001b94:	20002c9c 	.word	0x20002c9c
10001b98:	20002c8c 	.word	0x20002c8c
10001b9c:	20002c80 	.word	0x20002c80
10001ba0:	20002c90 	.word	0x20002c90
10001ba4:	20002c94 	.word	0x20002c94

10001ba8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
10001ba8:	b580      	push	{r7, lr}
10001baa:	b084      	sub	sp, #16
10001bac:	af00      	add	r7, sp, #0
10001bae:	6078      	str	r0, [r7, #4]
    uint8_t * puc = ( uint8_t * ) pv;
10001bb0:	687b      	ldr	r3, [r7, #4]
10001bb2:	60fb      	str	r3, [r7, #12]
    BlockLink_t * pxLink;

    if( pv != NULL )
10001bb4:	687b      	ldr	r3, [r7, #4]
10001bb6:	2b00      	cmp	r3, #0
10001bb8:	d03a      	beq.n	10001c30 <vPortFree+0x88>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;
10001bba:	2308      	movs	r3, #8
10001bbc:	425b      	negs	r3, r3
10001bbe:	68fa      	ldr	r2, [r7, #12]
10001bc0:	18d3      	adds	r3, r2, r3
10001bc2:	60fb      	str	r3, [r7, #12]

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
10001bc4:	68fb      	ldr	r3, [r7, #12]
10001bc6:	60bb      	str	r3, [r7, #8]

        /* Check the block is actually allocated. */
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
10001bc8:	68bb      	ldr	r3, [r7, #8]
10001bca:	685a      	ldr	r2, [r3, #4]
10001bcc:	4b1a      	ldr	r3, [pc, #104]	; (10001c38 <vPortFree+0x90>)
10001bce:	681b      	ldr	r3, [r3, #0]
10001bd0:	4013      	ands	r3, r2
10001bd2:	d101      	bne.n	10001bd8 <vPortFree+0x30>
10001bd4:	b672      	cpsid	i
10001bd6:	e7fe      	b.n	10001bd6 <vPortFree+0x2e>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
10001bd8:	68bb      	ldr	r3, [r7, #8]
10001bda:	681b      	ldr	r3, [r3, #0]
10001bdc:	2b00      	cmp	r3, #0
10001bde:	d001      	beq.n	10001be4 <vPortFree+0x3c>
10001be0:	b672      	cpsid	i
10001be2:	e7fe      	b.n	10001be2 <vPortFree+0x3a>

        if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
10001be4:	68bb      	ldr	r3, [r7, #8]
10001be6:	685a      	ldr	r2, [r3, #4]
10001be8:	4b13      	ldr	r3, [pc, #76]	; (10001c38 <vPortFree+0x90>)
10001bea:	681b      	ldr	r3, [r3, #0]
10001bec:	4013      	ands	r3, r2
10001bee:	d01f      	beq.n	10001c30 <vPortFree+0x88>
        {
            if( pxLink->pxNextFreeBlock == NULL )
10001bf0:	68bb      	ldr	r3, [r7, #8]
10001bf2:	681b      	ldr	r3, [r3, #0]
10001bf4:	2b00      	cmp	r3, #0
10001bf6:	d11b      	bne.n	10001c30 <vPortFree+0x88>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
10001bf8:	68bb      	ldr	r3, [r7, #8]
10001bfa:	685a      	ldr	r2, [r3, #4]
10001bfc:	4b0e      	ldr	r3, [pc, #56]	; (10001c38 <vPortFree+0x90>)
10001bfe:	681b      	ldr	r3, [r3, #0]
10001c00:	43db      	mvns	r3, r3
10001c02:	401a      	ands	r2, r3
10001c04:	68bb      	ldr	r3, [r7, #8]
10001c06:	605a      	str	r2, [r3, #4]

                vTaskSuspendAll();
10001c08:	f001 f80e 	bl	10002c28 <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
10001c0c:	68bb      	ldr	r3, [r7, #8]
10001c0e:	685a      	ldr	r2, [r3, #4]
10001c10:	4b0a      	ldr	r3, [pc, #40]	; (10001c3c <vPortFree+0x94>)
10001c12:	681b      	ldr	r3, [r3, #0]
10001c14:	18d2      	adds	r2, r2, r3
10001c16:	4b09      	ldr	r3, [pc, #36]	; (10001c3c <vPortFree+0x94>)
10001c18:	601a      	str	r2, [r3, #0]
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
10001c1a:	68bb      	ldr	r3, [r7, #8]
10001c1c:	1c18      	adds	r0, r3, #0
10001c1e:	f000 f871 	bl	10001d04 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
10001c22:	4b07      	ldr	r3, [pc, #28]	; (10001c40 <vPortFree+0x98>)
10001c24:	681b      	ldr	r3, [r3, #0]
10001c26:	1c5a      	adds	r2, r3, #1
10001c28:	4b05      	ldr	r3, [pc, #20]	; (10001c40 <vPortFree+0x98>)
10001c2a:	601a      	str	r2, [r3, #0]
                }
                ( void ) xTaskResumeAll();
10001c2c:	f001 f808 	bl	10002c40 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
10001c30:	46bd      	mov	sp, r7
10001c32:	b004      	add	sp, #16
10001c34:	bd80      	pop	{r7, pc}
10001c36:	46c0      	nop			; (mov r8, r8)
10001c38:	20002c9c 	.word	0x20002c9c
10001c3c:	20002c8c 	.word	0x20002c8c
10001c40:	20002c98 	.word	0x20002c98

10001c44 <prvHeapInit>:
    /* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
10001c44:	b580      	push	{r7, lr}
10001c46:	b084      	sub	sp, #16
10001c48:	af00      	add	r7, sp, #0
    BlockLink_t * pxFirstFreeBlock;
    uint8_t * pucAlignedHeap;
    size_t uxAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
10001c4a:	4b27      	ldr	r3, [pc, #156]	; (10001ce8 <prvHeapInit+0xa4>)
10001c4c:	60bb      	str	r3, [r7, #8]

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxAddress = ( size_t ) ucHeap;
10001c4e:	4b27      	ldr	r3, [pc, #156]	; (10001cec <prvHeapInit+0xa8>)
10001c50:	60fb      	str	r3, [r7, #12]

    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
10001c52:	68fb      	ldr	r3, [r7, #12]
10001c54:	2207      	movs	r2, #7
10001c56:	4013      	ands	r3, r2
10001c58:	d00c      	beq.n	10001c74 <prvHeapInit+0x30>
    {
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
10001c5a:	68fb      	ldr	r3, [r7, #12]
10001c5c:	3307      	adds	r3, #7
10001c5e:	60fb      	str	r3, [r7, #12]
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
10001c60:	68fb      	ldr	r3, [r7, #12]
10001c62:	2207      	movs	r2, #7
10001c64:	4393      	bics	r3, r2
10001c66:	60fb      	str	r3, [r7, #12]
        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
10001c68:	68ba      	ldr	r2, [r7, #8]
10001c6a:	68fb      	ldr	r3, [r7, #12]
10001c6c:	1ad2      	subs	r2, r2, r3
10001c6e:	4b1f      	ldr	r3, [pc, #124]	; (10001cec <prvHeapInit+0xa8>)
10001c70:	18d3      	adds	r3, r2, r3
10001c72:	60bb      	str	r3, [r7, #8]
    }

    pucAlignedHeap = ( uint8_t * ) uxAddress;
10001c74:	68fb      	ldr	r3, [r7, #12]
10001c76:	607b      	str	r3, [r7, #4]

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
10001c78:	4b1d      	ldr	r3, [pc, #116]	; (10001cf0 <prvHeapInit+0xac>)
10001c7a:	687a      	ldr	r2, [r7, #4]
10001c7c:	601a      	str	r2, [r3, #0]
    xStart.xBlockSize = ( size_t ) 0;
10001c7e:	4b1c      	ldr	r3, [pc, #112]	; (10001cf0 <prvHeapInit+0xac>)
10001c80:	2200      	movs	r2, #0
10001c82:	605a      	str	r2, [r3, #4]

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
10001c84:	687a      	ldr	r2, [r7, #4]
10001c86:	68bb      	ldr	r3, [r7, #8]
10001c88:	18d3      	adds	r3, r2, r3
10001c8a:	60fb      	str	r3, [r7, #12]
    uxAddress -= xHeapStructSize;
10001c8c:	2208      	movs	r2, #8
10001c8e:	68fb      	ldr	r3, [r7, #12]
10001c90:	1a9b      	subs	r3, r3, r2
10001c92:	60fb      	str	r3, [r7, #12]
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
10001c94:	68fb      	ldr	r3, [r7, #12]
10001c96:	2207      	movs	r2, #7
10001c98:	4393      	bics	r3, r2
10001c9a:	60fb      	str	r3, [r7, #12]
    pxEnd = ( void * ) uxAddress;
10001c9c:	68fa      	ldr	r2, [r7, #12]
10001c9e:	4b15      	ldr	r3, [pc, #84]	; (10001cf4 <prvHeapInit+0xb0>)
10001ca0:	601a      	str	r2, [r3, #0]
    pxEnd->xBlockSize = 0;
10001ca2:	4b14      	ldr	r3, [pc, #80]	; (10001cf4 <prvHeapInit+0xb0>)
10001ca4:	681b      	ldr	r3, [r3, #0]
10001ca6:	2200      	movs	r2, #0
10001ca8:	605a      	str	r2, [r3, #4]
    pxEnd->pxNextFreeBlock = NULL;
10001caa:	4b12      	ldr	r3, [pc, #72]	; (10001cf4 <prvHeapInit+0xb0>)
10001cac:	681b      	ldr	r3, [r3, #0]
10001cae:	2200      	movs	r2, #0
10001cb0:	601a      	str	r2, [r3, #0]

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( void * ) pucAlignedHeap;
10001cb2:	687b      	ldr	r3, [r7, #4]
10001cb4:	603b      	str	r3, [r7, #0]
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
10001cb6:	683b      	ldr	r3, [r7, #0]
10001cb8:	68fa      	ldr	r2, [r7, #12]
10001cba:	1ad2      	subs	r2, r2, r3
10001cbc:	683b      	ldr	r3, [r7, #0]
10001cbe:	605a      	str	r2, [r3, #4]
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
10001cc0:	4b0c      	ldr	r3, [pc, #48]	; (10001cf4 <prvHeapInit+0xb0>)
10001cc2:	681a      	ldr	r2, [r3, #0]
10001cc4:	683b      	ldr	r3, [r7, #0]
10001cc6:	601a      	str	r2, [r3, #0]

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
10001cc8:	683b      	ldr	r3, [r7, #0]
10001cca:	685a      	ldr	r2, [r3, #4]
10001ccc:	4b0a      	ldr	r3, [pc, #40]	; (10001cf8 <prvHeapInit+0xb4>)
10001cce:	601a      	str	r2, [r3, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
10001cd0:	683b      	ldr	r3, [r7, #0]
10001cd2:	685a      	ldr	r2, [r3, #4]
10001cd4:	4b09      	ldr	r3, [pc, #36]	; (10001cfc <prvHeapInit+0xb8>)
10001cd6:	601a      	str	r2, [r3, #0]

    /* Work out the position of the top bit in a size_t variable. */
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
10001cd8:	4b09      	ldr	r3, [pc, #36]	; (10001d00 <prvHeapInit+0xbc>)
10001cda:	2280      	movs	r2, #128	; 0x80
10001cdc:	0612      	lsls	r2, r2, #24
10001cde:	601a      	str	r2, [r3, #0]
}
10001ce0:	46bd      	mov	sp, r7
10001ce2:	b004      	add	sp, #16
10001ce4:	bd80      	pop	{r7, pc}
10001ce6:	46c0      	nop			; (mov r8, r8)
10001ce8:	00002710 	.word	0x00002710
10001cec:	20000570 	.word	0x20000570
10001cf0:	20002c80 	.word	0x20002c80
10001cf4:	20002c88 	.word	0x20002c88
10001cf8:	20002c90 	.word	0x20002c90
10001cfc:	20002c8c 	.word	0x20002c8c
10001d00:	20002c9c 	.word	0x20002c9c

10001d04 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
10001d04:	b580      	push	{r7, lr}
10001d06:	b084      	sub	sp, #16
10001d08:	af00      	add	r7, sp, #0
10001d0a:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
10001d0c:	4b26      	ldr	r3, [pc, #152]	; (10001da8 <prvInsertBlockIntoFreeList+0xa4>)
10001d0e:	60fb      	str	r3, [r7, #12]
10001d10:	e002      	b.n	10001d18 <prvInsertBlockIntoFreeList+0x14>
10001d12:	68fb      	ldr	r3, [r7, #12]
10001d14:	681b      	ldr	r3, [r3, #0]
10001d16:	60fb      	str	r3, [r7, #12]
10001d18:	68fb      	ldr	r3, [r7, #12]
10001d1a:	681a      	ldr	r2, [r3, #0]
10001d1c:	687b      	ldr	r3, [r7, #4]
10001d1e:	429a      	cmp	r2, r3
10001d20:	d3f7      	bcc.n	10001d12 <prvInsertBlockIntoFreeList+0xe>
        /* Nothing to do here, just iterate to the right position. */
    }

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;
10001d22:	68fb      	ldr	r3, [r7, #12]
10001d24:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
10001d26:	68fb      	ldr	r3, [r7, #12]
10001d28:	685b      	ldr	r3, [r3, #4]
10001d2a:	68ba      	ldr	r2, [r7, #8]
10001d2c:	18d2      	adds	r2, r2, r3
10001d2e:	687b      	ldr	r3, [r7, #4]
10001d30:	429a      	cmp	r2, r3
10001d32:	d108      	bne.n	10001d46 <prvInsertBlockIntoFreeList+0x42>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
10001d34:	68fb      	ldr	r3, [r7, #12]
10001d36:	685a      	ldr	r2, [r3, #4]
10001d38:	687b      	ldr	r3, [r7, #4]
10001d3a:	685b      	ldr	r3, [r3, #4]
10001d3c:	18d2      	adds	r2, r2, r3
10001d3e:	68fb      	ldr	r3, [r7, #12]
10001d40:	605a      	str	r2, [r3, #4]
        pxBlockToInsert = pxIterator;
10001d42:	68fb      	ldr	r3, [r7, #12]
10001d44:	607b      	str	r3, [r7, #4]
        mtCOVERAGE_TEST_MARKER();
    }

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;
10001d46:	687b      	ldr	r3, [r7, #4]
10001d48:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
10001d4a:	687b      	ldr	r3, [r7, #4]
10001d4c:	685b      	ldr	r3, [r3, #4]
10001d4e:	68ba      	ldr	r2, [r7, #8]
10001d50:	18d2      	adds	r2, r2, r3
10001d52:	68fb      	ldr	r3, [r7, #12]
10001d54:	681b      	ldr	r3, [r3, #0]
10001d56:	429a      	cmp	r2, r3
10001d58:	d118      	bne.n	10001d8c <prvInsertBlockIntoFreeList+0x88>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
10001d5a:	68fb      	ldr	r3, [r7, #12]
10001d5c:	681a      	ldr	r2, [r3, #0]
10001d5e:	4b13      	ldr	r3, [pc, #76]	; (10001dac <prvInsertBlockIntoFreeList+0xa8>)
10001d60:	681b      	ldr	r3, [r3, #0]
10001d62:	429a      	cmp	r2, r3
10001d64:	d00d      	beq.n	10001d82 <prvInsertBlockIntoFreeList+0x7e>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
10001d66:	687b      	ldr	r3, [r7, #4]
10001d68:	685a      	ldr	r2, [r3, #4]
10001d6a:	68fb      	ldr	r3, [r7, #12]
10001d6c:	681b      	ldr	r3, [r3, #0]
10001d6e:	685b      	ldr	r3, [r3, #4]
10001d70:	18d2      	adds	r2, r2, r3
10001d72:	687b      	ldr	r3, [r7, #4]
10001d74:	605a      	str	r2, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
10001d76:	68fb      	ldr	r3, [r7, #12]
10001d78:	681b      	ldr	r3, [r3, #0]
10001d7a:	681a      	ldr	r2, [r3, #0]
10001d7c:	687b      	ldr	r3, [r7, #4]
10001d7e:	601a      	str	r2, [r3, #0]
10001d80:	e008      	b.n	10001d94 <prvInsertBlockIntoFreeList+0x90>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
10001d82:	4b0a      	ldr	r3, [pc, #40]	; (10001dac <prvInsertBlockIntoFreeList+0xa8>)
10001d84:	681a      	ldr	r2, [r3, #0]
10001d86:	687b      	ldr	r3, [r7, #4]
10001d88:	601a      	str	r2, [r3, #0]
10001d8a:	e003      	b.n	10001d94 <prvInsertBlockIntoFreeList+0x90>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
10001d8c:	68fb      	ldr	r3, [r7, #12]
10001d8e:	681a      	ldr	r2, [r3, #0]
10001d90:	687b      	ldr	r3, [r7, #4]
10001d92:	601a      	str	r2, [r3, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
10001d94:	68fa      	ldr	r2, [r7, #12]
10001d96:	687b      	ldr	r3, [r7, #4]
10001d98:	429a      	cmp	r2, r3
10001d9a:	d002      	beq.n	10001da2 <prvInsertBlockIntoFreeList+0x9e>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
10001d9c:	68fb      	ldr	r3, [r7, #12]
10001d9e:	687a      	ldr	r2, [r7, #4]
10001da0:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10001da2:	46bd      	mov	sp, r7
10001da4:	b004      	add	sp, #16
10001da6:	bd80      	pop	{r7, pc}
10001da8:	20002c80 	.word	0x20002c80
10001dac:	20002c88 	.word	0x20002c88

10001db0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
10001db0:	b580      	push	{r7, lr}
10001db2:	b082      	sub	sp, #8
10001db4:	af00      	add	r7, sp, #0
10001db6:	6078      	str	r0, [r7, #4]
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10001db8:	687b      	ldr	r3, [r7, #4]
10001dba:	3308      	adds	r3, #8
10001dbc:	1c1a      	adds	r2, r3, #0
10001dbe:	687b      	ldr	r3, [r7, #4]
10001dc0:	605a      	str	r2, [r3, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
10001dc2:	687b      	ldr	r3, [r7, #4]
10001dc4:	2201      	movs	r2, #1
10001dc6:	4252      	negs	r2, r2
10001dc8:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10001dca:	687b      	ldr	r3, [r7, #4]
10001dcc:	3308      	adds	r3, #8
10001dce:	1c1a      	adds	r2, r3, #0
10001dd0:	687b      	ldr	r3, [r7, #4]
10001dd2:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
10001dd4:	687b      	ldr	r3, [r7, #4]
10001dd6:	3308      	adds	r3, #8
10001dd8:	1c1a      	adds	r2, r3, #0
10001dda:	687b      	ldr	r3, [r7, #4]
10001ddc:	611a      	str	r2, [r3, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
10001dde:	687b      	ldr	r3, [r7, #4]
10001de0:	2200      	movs	r2, #0
10001de2:	601a      	str	r2, [r3, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
10001de4:	46bd      	mov	sp, r7
10001de6:	b002      	add	sp, #8
10001de8:	bd80      	pop	{r7, pc}
10001dea:	46c0      	nop			; (mov r8, r8)

10001dec <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
10001dec:	b580      	push	{r7, lr}
10001dee:	b082      	sub	sp, #8
10001df0:	af00      	add	r7, sp, #0
10001df2:	6078      	str	r0, [r7, #4]
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
10001df4:	687b      	ldr	r3, [r7, #4]
10001df6:	2200      	movs	r2, #0
10001df8:	611a      	str	r2, [r3, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
10001dfa:	46bd      	mov	sp, r7
10001dfc:	b002      	add	sp, #8
10001dfe:	bd80      	pop	{r7, pc}

10001e00 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
10001e00:	b580      	push	{r7, lr}
10001e02:	b084      	sub	sp, #16
10001e04:	af00      	add	r7, sp, #0
10001e06:	6078      	str	r0, [r7, #4]
10001e08:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
10001e0a:	687b      	ldr	r3, [r7, #4]
10001e0c:	685b      	ldr	r3, [r3, #4]
10001e0e:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
10001e10:	683b      	ldr	r3, [r7, #0]
10001e12:	68fa      	ldr	r2, [r7, #12]
10001e14:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
10001e16:	68fb      	ldr	r3, [r7, #12]
10001e18:	689a      	ldr	r2, [r3, #8]
10001e1a:	683b      	ldr	r3, [r7, #0]
10001e1c:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
10001e1e:	68fb      	ldr	r3, [r7, #12]
10001e20:	689b      	ldr	r3, [r3, #8]
10001e22:	683a      	ldr	r2, [r7, #0]
10001e24:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
10001e26:	68fb      	ldr	r3, [r7, #12]
10001e28:	683a      	ldr	r2, [r7, #0]
10001e2a:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
10001e2c:	683b      	ldr	r3, [r7, #0]
10001e2e:	687a      	ldr	r2, [r7, #4]
10001e30:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10001e32:	687b      	ldr	r3, [r7, #4]
10001e34:	681b      	ldr	r3, [r3, #0]
10001e36:	1c5a      	adds	r2, r3, #1
10001e38:	687b      	ldr	r3, [r7, #4]
10001e3a:	601a      	str	r2, [r3, #0]
}
10001e3c:	46bd      	mov	sp, r7
10001e3e:	b004      	add	sp, #16
10001e40:	bd80      	pop	{r7, pc}
10001e42:	46c0      	nop			; (mov r8, r8)

10001e44 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
10001e44:	b580      	push	{r7, lr}
10001e46:	b084      	sub	sp, #16
10001e48:	af00      	add	r7, sp, #0
10001e4a:	6078      	str	r0, [r7, #4]
10001e4c:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
10001e4e:	683b      	ldr	r3, [r7, #0]
10001e50:	681b      	ldr	r3, [r3, #0]
10001e52:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
10001e54:	68bb      	ldr	r3, [r7, #8]
10001e56:	3301      	adds	r3, #1
10001e58:	d103      	bne.n	10001e62 <vListInsert+0x1e>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
10001e5a:	687b      	ldr	r3, [r7, #4]
10001e5c:	691b      	ldr	r3, [r3, #16]
10001e5e:	60fb      	str	r3, [r7, #12]
10001e60:	e00c      	b.n	10001e7c <vListInsert+0x38>
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
10001e62:	687b      	ldr	r3, [r7, #4]
10001e64:	3308      	adds	r3, #8
10001e66:	60fb      	str	r3, [r7, #12]
10001e68:	e002      	b.n	10001e70 <vListInsert+0x2c>
10001e6a:	68fb      	ldr	r3, [r7, #12]
10001e6c:	685b      	ldr	r3, [r3, #4]
10001e6e:	60fb      	str	r3, [r7, #12]
10001e70:	68fb      	ldr	r3, [r7, #12]
10001e72:	685b      	ldr	r3, [r3, #4]
10001e74:	681a      	ldr	r2, [r3, #0]
10001e76:	68bb      	ldr	r3, [r7, #8]
10001e78:	429a      	cmp	r2, r3
10001e7a:	d9f6      	bls.n	10001e6a <vListInsert+0x26>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
10001e7c:	68fb      	ldr	r3, [r7, #12]
10001e7e:	685a      	ldr	r2, [r3, #4]
10001e80:	683b      	ldr	r3, [r7, #0]
10001e82:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
10001e84:	683b      	ldr	r3, [r7, #0]
10001e86:	685b      	ldr	r3, [r3, #4]
10001e88:	683a      	ldr	r2, [r7, #0]
10001e8a:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
10001e8c:	683b      	ldr	r3, [r7, #0]
10001e8e:	68fa      	ldr	r2, [r7, #12]
10001e90:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
10001e92:	68fb      	ldr	r3, [r7, #12]
10001e94:	683a      	ldr	r2, [r7, #0]
10001e96:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
10001e98:	683b      	ldr	r3, [r7, #0]
10001e9a:	687a      	ldr	r2, [r7, #4]
10001e9c:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems )++;
10001e9e:	687b      	ldr	r3, [r7, #4]
10001ea0:	681b      	ldr	r3, [r3, #0]
10001ea2:	1c5a      	adds	r2, r3, #1
10001ea4:	687b      	ldr	r3, [r7, #4]
10001ea6:	601a      	str	r2, [r3, #0]
}
10001ea8:	46bd      	mov	sp, r7
10001eaa:	b004      	add	sp, #16
10001eac:	bd80      	pop	{r7, pc}
10001eae:	46c0      	nop			; (mov r8, r8)

10001eb0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
10001eb0:	b580      	push	{r7, lr}
10001eb2:	b084      	sub	sp, #16
10001eb4:	af00      	add	r7, sp, #0
10001eb6:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
10001eb8:	687b      	ldr	r3, [r7, #4]
10001eba:	691b      	ldr	r3, [r3, #16]
10001ebc:	60fb      	str	r3, [r7, #12]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
10001ebe:	687b      	ldr	r3, [r7, #4]
10001ec0:	685b      	ldr	r3, [r3, #4]
10001ec2:	687a      	ldr	r2, [r7, #4]
10001ec4:	6892      	ldr	r2, [r2, #8]
10001ec6:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
10001ec8:	687b      	ldr	r3, [r7, #4]
10001eca:	689b      	ldr	r3, [r3, #8]
10001ecc:	687a      	ldr	r2, [r7, #4]
10001ece:	6852      	ldr	r2, [r2, #4]
10001ed0:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
10001ed2:	68fb      	ldr	r3, [r7, #12]
10001ed4:	685a      	ldr	r2, [r3, #4]
10001ed6:	687b      	ldr	r3, [r7, #4]
10001ed8:	429a      	cmp	r2, r3
10001eda:	d103      	bne.n	10001ee4 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
10001edc:	687b      	ldr	r3, [r7, #4]
10001ede:	689a      	ldr	r2, [r3, #8]
10001ee0:	68fb      	ldr	r3, [r7, #12]
10001ee2:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
10001ee4:	687b      	ldr	r3, [r7, #4]
10001ee6:	2200      	movs	r2, #0
10001ee8:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems )--;
10001eea:	68fb      	ldr	r3, [r7, #12]
10001eec:	681b      	ldr	r3, [r3, #0]
10001eee:	1e5a      	subs	r2, r3, #1
10001ef0:	68fb      	ldr	r3, [r7, #12]
10001ef2:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
10001ef4:	68fb      	ldr	r3, [r7, #12]
10001ef6:	681b      	ldr	r3, [r3, #0]
}
10001ef8:	1c18      	adds	r0, r3, #0
10001efa:	46bd      	mov	sp, r7
10001efc:	b004      	add	sp, #16
10001efe:	bd80      	pop	{r7, pc}

10001f00 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
10001f00:	b580      	push	{r7, lr}
10001f02:	b084      	sub	sp, #16
10001f04:	af00      	add	r7, sp, #0
10001f06:	6078      	str	r0, [r7, #4]
10001f08:	6039      	str	r1, [r7, #0]
    Queue_t * const pxQueue = xQueue;
10001f0a:	687b      	ldr	r3, [r7, #4]
10001f0c:	60fb      	str	r3, [r7, #12]

    configASSERT( pxQueue );
10001f0e:	68fb      	ldr	r3, [r7, #12]
10001f10:	2b00      	cmp	r3, #0
10001f12:	d101      	bne.n	10001f18 <xQueueGenericReset+0x18>
10001f14:	b672      	cpsid	i
10001f16:	e7fe      	b.n	10001f16 <xQueueGenericReset+0x16>

    taskENTER_CRITICAL();
10001f18:	f7ff fd04 	bl	10001924 <vPortEnterCritical>
    {
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10001f1c:	68fb      	ldr	r3, [r7, #12]
10001f1e:	681a      	ldr	r2, [r3, #0]
10001f20:	68fb      	ldr	r3, [r7, #12]
10001f22:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
10001f24:	68fb      	ldr	r3, [r7, #12]
10001f26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001f28:	434b      	muls	r3, r1
10001f2a:	18d2      	adds	r2, r2, r3
10001f2c:	68fb      	ldr	r3, [r7, #12]
10001f2e:	609a      	str	r2, [r3, #8]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
10001f30:	68fb      	ldr	r3, [r7, #12]
10001f32:	2200      	movs	r2, #0
10001f34:	639a      	str	r2, [r3, #56]	; 0x38
        pxQueue->pcWriteTo = pxQueue->pcHead;
10001f36:	68fb      	ldr	r3, [r7, #12]
10001f38:	681a      	ldr	r2, [r3, #0]
10001f3a:	68fb      	ldr	r3, [r7, #12]
10001f3c:	605a      	str	r2, [r3, #4]
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10001f3e:	68fb      	ldr	r3, [r7, #12]
10001f40:	681a      	ldr	r2, [r3, #0]
10001f42:	68fb      	ldr	r3, [r7, #12]
10001f44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10001f46:	1e59      	subs	r1, r3, #1
10001f48:	68fb      	ldr	r3, [r7, #12]
10001f4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001f4c:	434b      	muls	r3, r1
10001f4e:	18d2      	adds	r2, r2, r3
10001f50:	68fb      	ldr	r3, [r7, #12]
10001f52:	60da      	str	r2, [r3, #12]
        pxQueue->cRxLock = queueUNLOCKED;
10001f54:	68fb      	ldr	r3, [r7, #12]
10001f56:	2244      	movs	r2, #68	; 0x44
10001f58:	21ff      	movs	r1, #255	; 0xff
10001f5a:	5499      	strb	r1, [r3, r2]
        pxQueue->cTxLock = queueUNLOCKED;
10001f5c:	68fb      	ldr	r3, [r7, #12]
10001f5e:	2245      	movs	r2, #69	; 0x45
10001f60:	21ff      	movs	r1, #255	; 0xff
10001f62:	5499      	strb	r1, [r3, r2]

        if( xNewQueue == pdFALSE )
10001f64:	683b      	ldr	r3, [r7, #0]
10001f66:	2b00      	cmp	r3, #0
10001f68:	d10d      	bne.n	10001f86 <xQueueGenericReset+0x86>
            /* If there are tasks blocked waiting to read from the queue, then
             * the tasks will remain blocked as after this function exits the queue
             * will still be empty.  If there are tasks blocked waiting to write to
             * the queue, then one should be unblocked as after this function exits
             * it will be possible to write to it. */
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10001f6a:	68fb      	ldr	r3, [r7, #12]
10001f6c:	691b      	ldr	r3, [r3, #16]
10001f6e:	2b00      	cmp	r3, #0
10001f70:	d013      	beq.n	10001f9a <xQueueGenericReset+0x9a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
10001f72:	68fb      	ldr	r3, [r7, #12]
10001f74:	3310      	adds	r3, #16
10001f76:	1c18      	adds	r0, r3, #0
10001f78:	f001 f83c 	bl	10002ff4 <xTaskRemoveFromEventList>
10001f7c:	1e03      	subs	r3, r0, #0
10001f7e:	d00c      	beq.n	10001f9a <xQueueGenericReset+0x9a>
                {
                    queueYIELD_IF_USING_PREEMPTION();
10001f80:	f7ff fcc2 	bl	10001908 <vPortYield>
10001f84:	e009      	b.n	10001f9a <xQueueGenericReset+0x9a>
            }
        }
        else
        {
            /* Ensure the event queues start in the correct state. */
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
10001f86:	68fb      	ldr	r3, [r7, #12]
10001f88:	3310      	adds	r3, #16
10001f8a:	1c18      	adds	r0, r3, #0
10001f8c:	f7ff ff10 	bl	10001db0 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
10001f90:	68fb      	ldr	r3, [r7, #12]
10001f92:	3324      	adds	r3, #36	; 0x24
10001f94:	1c18      	adds	r0, r3, #0
10001f96:	f7ff ff0b 	bl	10001db0 <vListInitialise>
        }
    }
    taskEXIT_CRITICAL();
10001f9a:	f7ff fcd3 	bl	10001944 <vPortExitCritical>

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return pdPASS;
10001f9e:	2301      	movs	r3, #1
}
10001fa0:	1c18      	adds	r0, r3, #0
10001fa2:	46bd      	mov	sp, r7
10001fa4:	b004      	add	sp, #16
10001fa6:	bd80      	pop	{r7, pc}

10001fa8 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
10001fa8:	b590      	push	{r4, r7, lr}
10001faa:	b08b      	sub	sp, #44	; 0x2c
10001fac:	af02      	add	r7, sp, #8
10001fae:	60f8      	str	r0, [r7, #12]
10001fb0:	60b9      	str	r1, [r7, #8]
10001fb2:	1dfb      	adds	r3, r7, #7
10001fb4:	701a      	strb	r2, [r3, #0]
        Queue_t * pxNewQueue;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
10001fb6:	68fb      	ldr	r3, [r7, #12]
10001fb8:	2b00      	cmp	r3, #0
10001fba:	d101      	bne.n	10001fc0 <xQueueGenericCreate+0x18>
10001fbc:	b672      	cpsid	i
10001fbe:	e7fe      	b.n	10001fbe <xQueueGenericCreate+0x16>

        /* Allocate enough space to hold the maximum number of items that
         * can be in the queue at any time.  It is valid for uxItemSize to be
         * zero in the case the queue is used as a semaphore. */
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10001fc0:	68fb      	ldr	r3, [r7, #12]
10001fc2:	68ba      	ldr	r2, [r7, #8]
10001fc4:	4353      	muls	r3, r2
10001fc6:	61fb      	str	r3, [r7, #28]

        /* Check for multiplication overflow. */
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
10001fc8:	68bb      	ldr	r3, [r7, #8]
10001fca:	2b00      	cmp	r3, #0
10001fcc:	d008      	beq.n	10001fe0 <xQueueGenericCreate+0x38>
10001fce:	69f8      	ldr	r0, [r7, #28]
10001fd0:	68b9      	ldr	r1, [r7, #8]
10001fd2:	f7ff fbb3 	bl	1000173c <__aeabi_uidiv>
10001fd6:	1c03      	adds	r3, r0, #0
10001fd8:	1e1a      	subs	r2, r3, #0
10001fda:	68fb      	ldr	r3, [r7, #12]
10001fdc:	429a      	cmp	r2, r3
10001fde:	d101      	bne.n	10001fe4 <xQueueGenericCreate+0x3c>
10001fe0:	2301      	movs	r3, #1
10001fe2:	e000      	b.n	10001fe6 <xQueueGenericCreate+0x3e>
10001fe4:	2300      	movs	r3, #0
10001fe6:	2b00      	cmp	r3, #0
10001fe8:	d101      	bne.n	10001fee <xQueueGenericCreate+0x46>
10001fea:	b672      	cpsid	i
10001fec:	e7fe      	b.n	10001fec <xQueueGenericCreate+0x44>

        /* Check for addition overflow. */
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
10001fee:	69fb      	ldr	r3, [r7, #28]
10001ff0:	3354      	adds	r3, #84	; 0x54
10001ff2:	1e1a      	subs	r2, r3, #0
10001ff4:	69fb      	ldr	r3, [r7, #28]
10001ff6:	429a      	cmp	r2, r3
10001ff8:	d801      	bhi.n	10001ffe <xQueueGenericCreate+0x56>
10001ffa:	b672      	cpsid	i
10001ffc:	e7fe      	b.n	10001ffc <xQueueGenericCreate+0x54>
         * alignment requirements of the Queue_t structure - which in this case
         * is an int8_t *.  Therefore, whenever the stack alignment requirements
         * are greater than or equal to the pointer to char requirements the cast
         * is safe.  In other cases alignment requirements are not strict (one or
         * two bytes). */
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
10001ffe:	69fb      	ldr	r3, [r7, #28]
10002000:	3354      	adds	r3, #84	; 0x54
10002002:	1c18      	adds	r0, r3, #0
10002004:	f7ff fd24 	bl	10001a50 <pvPortMalloc>
10002008:	1c03      	adds	r3, r0, #0
1000200a:	61bb      	str	r3, [r7, #24]

        if( pxNewQueue != NULL )
1000200c:	69bb      	ldr	r3, [r7, #24]
1000200e:	2b00      	cmp	r3, #0
10002010:	d00e      	beq.n	10002030 <xQueueGenericCreate+0x88>
        {
            /* Jump past the queue structure to find the location of the queue
             * storage area. */
            pucQueueStorage = ( uint8_t * ) pxNewQueue;
10002012:	69bb      	ldr	r3, [r7, #24]
10002014:	617b      	str	r3, [r7, #20]
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
10002016:	697b      	ldr	r3, [r7, #20]
10002018:	3354      	adds	r3, #84	; 0x54
1000201a:	617b      	str	r3, [r7, #20]
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
            #endif /* configSUPPORT_STATIC_ALLOCATION */

            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
1000201c:	68f8      	ldr	r0, [r7, #12]
1000201e:	68b9      	ldr	r1, [r7, #8]
10002020:	697a      	ldr	r2, [r7, #20]
10002022:	1dfb      	adds	r3, r7, #7
10002024:	781c      	ldrb	r4, [r3, #0]
10002026:	69bb      	ldr	r3, [r7, #24]
10002028:	9300      	str	r3, [sp, #0]
1000202a:	1c23      	adds	r3, r4, #0
1000202c:	f000 f806 	bl	1000203c <prvInitialiseNewQueue>
        {
            traceQUEUE_CREATE_FAILED( ucQueueType );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
10002030:	69bb      	ldr	r3, [r7, #24]
    }
10002032:	1c18      	adds	r0, r3, #0
10002034:	46bd      	mov	sp, r7
10002036:	b009      	add	sp, #36	; 0x24
10002038:	bd90      	pop	{r4, r7, pc}
1000203a:	46c0      	nop			; (mov r8, r8)

1000203c <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
1000203c:	b580      	push	{r7, lr}
1000203e:	b084      	sub	sp, #16
10002040:	af00      	add	r7, sp, #0
10002042:	60f8      	str	r0, [r7, #12]
10002044:	60b9      	str	r1, [r7, #8]
10002046:	607a      	str	r2, [r7, #4]
10002048:	1c1a      	adds	r2, r3, #0
1000204a:	1cfb      	adds	r3, r7, #3
1000204c:	701a      	strb	r2, [r3, #0]
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
1000204e:	68bb      	ldr	r3, [r7, #8]
10002050:	2b00      	cmp	r3, #0
10002052:	d103      	bne.n	1000205c <prvInitialiseNewQueue+0x20>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
10002054:	69bb      	ldr	r3, [r7, #24]
10002056:	69ba      	ldr	r2, [r7, #24]
10002058:	601a      	str	r2, [r3, #0]
1000205a:	e002      	b.n	10002062 <prvInitialiseNewQueue+0x26>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
1000205c:	69bb      	ldr	r3, [r7, #24]
1000205e:	687a      	ldr	r2, [r7, #4]
10002060:	601a      	str	r2, [r3, #0]
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
10002062:	69bb      	ldr	r3, [r7, #24]
10002064:	68fa      	ldr	r2, [r7, #12]
10002066:	63da      	str	r2, [r3, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
10002068:	69bb      	ldr	r3, [r7, #24]
1000206a:	68ba      	ldr	r2, [r7, #8]
1000206c:	641a      	str	r2, [r3, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
1000206e:	69bb      	ldr	r3, [r7, #24]
10002070:	1c18      	adds	r0, r3, #0
10002072:	2101      	movs	r1, #1
10002074:	f7ff ff44 	bl	10001f00 <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
10002078:	69bb      	ldr	r3, [r7, #24]
1000207a:	1cfa      	adds	r2, r7, #3
1000207c:	2150      	movs	r1, #80	; 0x50
1000207e:	7812      	ldrb	r2, [r2, #0]
10002080:	545a      	strb	r2, [r3, r1]
        }
    #endif /* configUSE_TRACE_FACILITY */

    #if ( configUSE_QUEUE_SETS == 1 )
        {
            pxNewQueue->pxQueueSetContainer = NULL;
10002082:	69bb      	ldr	r3, [r7, #24]
10002084:	2200      	movs	r2, #0
10002086:	649a      	str	r2, [r3, #72]	; 0x48
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
10002088:	46bd      	mov	sp, r7
1000208a:	b004      	add	sp, #16
1000208c:	bd80      	pop	{r7, pc}
1000208e:	46c0      	nop			; (mov r8, r8)

10002090 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
10002090:	b580      	push	{r7, lr}
10002092:	b08a      	sub	sp, #40	; 0x28
10002094:	af00      	add	r7, sp, #0
10002096:	60f8      	str	r0, [r7, #12]
10002098:	60b9      	str	r1, [r7, #8]
1000209a:	607a      	str	r2, [r7, #4]
1000209c:	603b      	str	r3, [r7, #0]
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
1000209e:	2300      	movs	r3, #0
100020a0:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
100020a2:	68fb      	ldr	r3, [r7, #12]
100020a4:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
100020a6:	6a3b      	ldr	r3, [r7, #32]
100020a8:	2b00      	cmp	r3, #0
100020aa:	d101      	bne.n	100020b0 <xQueueGenericSend+0x20>
100020ac:	b672      	cpsid	i
100020ae:	e7fe      	b.n	100020ae <xQueueGenericSend+0x1e>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
100020b0:	68bb      	ldr	r3, [r7, #8]
100020b2:	2b00      	cmp	r3, #0
100020b4:	d103      	bne.n	100020be <xQueueGenericSend+0x2e>
100020b6:	6a3b      	ldr	r3, [r7, #32]
100020b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100020ba:	2b00      	cmp	r3, #0
100020bc:	d101      	bne.n	100020c2 <xQueueGenericSend+0x32>
100020be:	2301      	movs	r3, #1
100020c0:	e000      	b.n	100020c4 <xQueueGenericSend+0x34>
100020c2:	2300      	movs	r3, #0
100020c4:	2b00      	cmp	r3, #0
100020c6:	d101      	bne.n	100020cc <xQueueGenericSend+0x3c>
100020c8:	b672      	cpsid	i
100020ca:	e7fe      	b.n	100020ca <xQueueGenericSend+0x3a>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
100020cc:	683b      	ldr	r3, [r7, #0]
100020ce:	2b02      	cmp	r3, #2
100020d0:	d103      	bne.n	100020da <xQueueGenericSend+0x4a>
100020d2:	6a3b      	ldr	r3, [r7, #32]
100020d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100020d6:	2b01      	cmp	r3, #1
100020d8:	d101      	bne.n	100020de <xQueueGenericSend+0x4e>
100020da:	2301      	movs	r3, #1
100020dc:	e000      	b.n	100020e0 <xQueueGenericSend+0x50>
100020de:	2300      	movs	r3, #0
100020e0:	2b00      	cmp	r3, #0
100020e2:	d101      	bne.n	100020e8 <xQueueGenericSend+0x58>
100020e4:	b672      	cpsid	i
100020e6:	e7fe      	b.n	100020e6 <xQueueGenericSend+0x56>
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
100020e8:	f001 f90a 	bl	10003300 <xTaskGetSchedulerState>
100020ec:	1e03      	subs	r3, r0, #0
100020ee:	d102      	bne.n	100020f6 <xQueueGenericSend+0x66>
100020f0:	687b      	ldr	r3, [r7, #4]
100020f2:	2b00      	cmp	r3, #0
100020f4:	d101      	bne.n	100020fa <xQueueGenericSend+0x6a>
100020f6:	2301      	movs	r3, #1
100020f8:	e000      	b.n	100020fc <xQueueGenericSend+0x6c>
100020fa:	2300      	movs	r3, #0
100020fc:	2b00      	cmp	r3, #0
100020fe:	d101      	bne.n	10002104 <xQueueGenericSend+0x74>
10002100:	b672      	cpsid	i
10002102:	e7fe      	b.n	10002102 <xQueueGenericSend+0x72>
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
10002104:	f7ff fc0e 	bl	10001924 <vPortEnterCritical>
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
10002108:	6a3b      	ldr	r3, [r7, #32]
1000210a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
1000210c:	6a3b      	ldr	r3, [r7, #32]
1000210e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002110:	429a      	cmp	r2, r3
10002112:	d302      	bcc.n	1000211a <xQueueGenericSend+0x8a>
10002114:	683b      	ldr	r3, [r7, #0]
10002116:	2b02      	cmp	r3, #2
10002118:	d138      	bne.n	1000218c <xQueueGenericSend+0xfc>
            {
                traceQUEUE_SEND( pxQueue );

                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1000211a:	6a3b      	ldr	r3, [r7, #32]
1000211c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
1000211e:	61fb      	str	r3, [r7, #28]

                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
10002120:	6a39      	ldr	r1, [r7, #32]
10002122:	68ba      	ldr	r2, [r7, #8]
10002124:	683b      	ldr	r3, [r7, #0]
10002126:	1c08      	adds	r0, r1, #0
10002128:	1c11      	adds	r1, r2, #0
1000212a:	1c1a      	adds	r2, r3, #0
1000212c:	f000 f9e6 	bl	100024fc <prvCopyDataToQueue>
10002130:	1c03      	adds	r3, r0, #0
10002132:	61bb      	str	r3, [r7, #24]

                        if( pxQueue->pxQueueSetContainer != NULL )
10002134:	6a3b      	ldr	r3, [r7, #32]
10002136:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10002138:	2b00      	cmp	r3, #0
1000213a:	d010      	beq.n	1000215e <xQueueGenericSend+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
1000213c:	683b      	ldr	r3, [r7, #0]
1000213e:	2b02      	cmp	r3, #2
10002140:	d104      	bne.n	1000214c <xQueueGenericSend+0xbc>
10002142:	69fb      	ldr	r3, [r7, #28]
10002144:	2b00      	cmp	r3, #0
10002146:	d001      	beq.n	1000214c <xQueueGenericSend+0xbc>
10002148:	46c0      	nop			; (mov r8, r8)
1000214a:	e01b      	b.n	10002184 <xQueueGenericSend+0xf4>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1000214c:	6a3b      	ldr	r3, [r7, #32]
1000214e:	1c18      	adds	r0, r3, #0
10002150:	f000 fb64 	bl	1000281c <prvNotifyQueueSetContainer>
10002154:	1e03      	subs	r3, r0, #0
10002156:	d015      	beq.n	10002184 <xQueueGenericSend+0xf4>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock. A context switch is required. */
                                queueYIELD_IF_USING_PREEMPTION();
10002158:	f7ff fbd6 	bl	10001908 <vPortYield>
1000215c:	e012      	b.n	10002184 <xQueueGenericSend+0xf4>
                        }
                        else
                        {
                            /* If there was a task waiting for data to arrive on the
                             * queue then unblock it now. */
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1000215e:	6a3b      	ldr	r3, [r7, #32]
10002160:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10002162:	2b00      	cmp	r3, #0
10002164:	d009      	beq.n	1000217a <xQueueGenericSend+0xea>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
10002166:	6a3b      	ldr	r3, [r7, #32]
10002168:	3324      	adds	r3, #36	; 0x24
1000216a:	1c18      	adds	r0, r3, #0
1000216c:	f000 ff42 	bl	10002ff4 <xTaskRemoveFromEventList>
10002170:	1e03      	subs	r3, r0, #0
10002172:	d007      	beq.n	10002184 <xQueueGenericSend+0xf4>
                                {
                                    /* The unblocked task has a priority higher than
                                     * our own so yield immediately.  Yes it is ok to
                                     * do this from within the critical section - the
                                     * kernel takes care of that. */
                                    queueYIELD_IF_USING_PREEMPTION();
10002174:	f7ff fbc8 	bl	10001908 <vPortYield>
10002178:	e004      	b.n	10002184 <xQueueGenericSend+0xf4>
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }
                            }
                            else if( xYieldRequired != pdFALSE )
1000217a:	69bb      	ldr	r3, [r7, #24]
1000217c:	2b00      	cmp	r3, #0
1000217e:	d001      	beq.n	10002184 <xQueueGenericSend+0xf4>
                            {
                                /* This path is a special case that will only get
                                 * executed if the task was holding multiple mutexes
                                 * and the mutexes were given back in an order that is
                                 * different to that in which they were taken. */
                                queueYIELD_IF_USING_PREEMPTION();
10002180:	f7ff fbc2 	bl	10001908 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
10002184:	f7ff fbde 	bl	10001944 <vPortExitCritical>
                return pdPASS;
10002188:	2301      	movs	r3, #1
1000218a:	e060      	b.n	1000224e <xQueueGenericSend+0x1be>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
1000218c:	687b      	ldr	r3, [r7, #4]
1000218e:	2b00      	cmp	r3, #0
10002190:	d103      	bne.n	1000219a <xQueueGenericSend+0x10a>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
10002192:	f7ff fbd7 	bl	10001944 <vPortExitCritical>

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
10002196:	2300      	movs	r3, #0
10002198:	e059      	b.n	1000224e <xQueueGenericSend+0x1be>
                }
                else if( xEntryTimeSet == pdFALSE )
1000219a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
1000219c:	2b00      	cmp	r3, #0
1000219e:	d106      	bne.n	100021ae <xQueueGenericSend+0x11e>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
100021a0:	2310      	movs	r3, #16
100021a2:	18fb      	adds	r3, r7, r3
100021a4:	1c18      	adds	r0, r3, #0
100021a6:	f000 ff81 	bl	100030ac <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
100021aa:	2301      	movs	r3, #1
100021ac:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
100021ae:	f7ff fbc9 	bl	10001944 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
100021b2:	f000 fd39 	bl	10002c28 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
100021b6:	f7ff fbb5 	bl	10001924 <vPortEnterCritical>
100021ba:	6a3b      	ldr	r3, [r7, #32]
100021bc:	2244      	movs	r2, #68	; 0x44
100021be:	5c9b      	ldrb	r3, [r3, r2]
100021c0:	b2db      	uxtb	r3, r3
100021c2:	b25b      	sxtb	r3, r3
100021c4:	3301      	adds	r3, #1
100021c6:	d103      	bne.n	100021d0 <xQueueGenericSend+0x140>
100021c8:	6a3b      	ldr	r3, [r7, #32]
100021ca:	2244      	movs	r2, #68	; 0x44
100021cc:	2100      	movs	r1, #0
100021ce:	5499      	strb	r1, [r3, r2]
100021d0:	6a3b      	ldr	r3, [r7, #32]
100021d2:	2245      	movs	r2, #69	; 0x45
100021d4:	5c9b      	ldrb	r3, [r3, r2]
100021d6:	b2db      	uxtb	r3, r3
100021d8:	b25b      	sxtb	r3, r3
100021da:	3301      	adds	r3, #1
100021dc:	d103      	bne.n	100021e6 <xQueueGenericSend+0x156>
100021de:	6a3b      	ldr	r3, [r7, #32]
100021e0:	2245      	movs	r2, #69	; 0x45
100021e2:	2100      	movs	r1, #0
100021e4:	5499      	strb	r1, [r3, r2]
100021e6:	f7ff fbad 	bl	10001944 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
100021ea:	2310      	movs	r3, #16
100021ec:	18fa      	adds	r2, r7, r3
100021ee:	1d3b      	adds	r3, r7, #4
100021f0:	1c10      	adds	r0, r2, #0
100021f2:	1c19      	adds	r1, r3, #0
100021f4:	f000 ff6e 	bl	100030d4 <xTaskCheckForTimeOut>
100021f8:	1e03      	subs	r3, r0, #0
100021fa:	d11f      	bne.n	1000223c <xQueueGenericSend+0x1ac>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
100021fc:	6a3b      	ldr	r3, [r7, #32]
100021fe:	1c18      	adds	r0, r3, #0
10002200:	f000 fa96 	bl	10002730 <prvIsQueueFull>
10002204:	1e03      	subs	r3, r0, #0
10002206:	d012      	beq.n	1000222e <xQueueGenericSend+0x19e>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
10002208:	6a3b      	ldr	r3, [r7, #32]
1000220a:	3310      	adds	r3, #16
1000220c:	1c1a      	adds	r2, r3, #0
1000220e:	687b      	ldr	r3, [r7, #4]
10002210:	1c10      	adds	r0, r2, #0
10002212:	1c19      	adds	r1, r3, #0
10002214:	f000 feae 	bl	10002f74 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list.  It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready last instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
10002218:	6a3b      	ldr	r3, [r7, #32]
1000221a:	1c18      	adds	r0, r3, #0
1000221c:	f000 fa06 	bl	1000262c <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in a ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
10002220:	f000 fd0e 	bl	10002c40 <xTaskResumeAll>
10002224:	1e03      	subs	r3, r0, #0
10002226:	d111      	bne.n	1000224c <xQueueGenericSend+0x1bc>
                {
                    portYIELD_WITHIN_API();
10002228:	f7ff fb6e 	bl	10001908 <vPortYield>
1000222c:	e00e      	b.n	1000224c <xQueueGenericSend+0x1bc>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
1000222e:	6a3b      	ldr	r3, [r7, #32]
10002230:	1c18      	adds	r0, r3, #0
10002232:	f000 f9fb 	bl	1000262c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
10002236:	f000 fd03 	bl	10002c40 <xTaskResumeAll>
1000223a:	e763      	b.n	10002104 <xQueueGenericSend+0x74>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
1000223c:	6a3b      	ldr	r3, [r7, #32]
1000223e:	1c18      	adds	r0, r3, #0
10002240:	f000 f9f4 	bl	1000262c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
10002244:	f000 fcfc 	bl	10002c40 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
10002248:	2300      	movs	r3, #0
1000224a:	e000      	b.n	1000224e <xQueueGenericSend+0x1be>
        }
    } /*lint -restore */
1000224c:	e75a      	b.n	10002104 <xQueueGenericSend+0x74>
}
1000224e:	1c18      	adds	r0, r3, #0
10002250:	46bd      	mov	sp, r7
10002252:	b00a      	add	sp, #40	; 0x28
10002254:	bd80      	pop	{r7, pc}
10002256:	46c0      	nop			; (mov r8, r8)

10002258 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
10002258:	b580      	push	{r7, lr}
1000225a:	b08a      	sub	sp, #40	; 0x28
1000225c:	af00      	add	r7, sp, #0
1000225e:	60f8      	str	r0, [r7, #12]
10002260:	60b9      	str	r1, [r7, #8]
10002262:	607a      	str	r2, [r7, #4]
10002264:	603b      	str	r3, [r7, #0]
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
10002266:	68fb      	ldr	r3, [r7, #12]
10002268:	623b      	str	r3, [r7, #32]

    configASSERT( pxQueue );
1000226a:	6a3b      	ldr	r3, [r7, #32]
1000226c:	2b00      	cmp	r3, #0
1000226e:	d101      	bne.n	10002274 <xQueueGenericSendFromISR+0x1c>
10002270:	b672      	cpsid	i
10002272:	e7fe      	b.n	10002272 <xQueueGenericSendFromISR+0x1a>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
10002274:	68bb      	ldr	r3, [r7, #8]
10002276:	2b00      	cmp	r3, #0
10002278:	d103      	bne.n	10002282 <xQueueGenericSendFromISR+0x2a>
1000227a:	6a3b      	ldr	r3, [r7, #32]
1000227c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000227e:	2b00      	cmp	r3, #0
10002280:	d101      	bne.n	10002286 <xQueueGenericSendFromISR+0x2e>
10002282:	2301      	movs	r3, #1
10002284:	e000      	b.n	10002288 <xQueueGenericSendFromISR+0x30>
10002286:	2300      	movs	r3, #0
10002288:	2b00      	cmp	r3, #0
1000228a:	d101      	bne.n	10002290 <xQueueGenericSendFromISR+0x38>
1000228c:	b672      	cpsid	i
1000228e:	e7fe      	b.n	1000228e <xQueueGenericSendFromISR+0x36>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
10002290:	683b      	ldr	r3, [r7, #0]
10002292:	2b02      	cmp	r3, #2
10002294:	d103      	bne.n	1000229e <xQueueGenericSendFromISR+0x46>
10002296:	6a3b      	ldr	r3, [r7, #32]
10002298:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
1000229a:	2b01      	cmp	r3, #1
1000229c:	d101      	bne.n	100022a2 <xQueueGenericSendFromISR+0x4a>
1000229e:	2301      	movs	r3, #1
100022a0:	e000      	b.n	100022a4 <xQueueGenericSendFromISR+0x4c>
100022a2:	2300      	movs	r3, #0
100022a4:	2b00      	cmp	r3, #0
100022a6:	d101      	bne.n	100022ac <xQueueGenericSendFromISR+0x54>
100022a8:	b672      	cpsid	i
100022aa:	e7fe      	b.n	100022aa <xQueueGenericSendFromISR+0x52>
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
100022ac:	f7ff fb60 	bl	10001970 <ulSetInterruptMaskFromISR>
100022b0:	1c03      	adds	r3, r0, #0
100022b2:	61fb      	str	r3, [r7, #28]
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
100022b4:	6a3b      	ldr	r3, [r7, #32]
100022b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
100022b8:	6a3b      	ldr	r3, [r7, #32]
100022ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
100022bc:	429a      	cmp	r2, r3
100022be:	d302      	bcc.n	100022c6 <xQueueGenericSendFromISR+0x6e>
100022c0:	683b      	ldr	r3, [r7, #0]
100022c2:	2b02      	cmp	r3, #2
100022c4:	d155      	bne.n	10002372 <xQueueGenericSendFromISR+0x11a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
100022c6:	231b      	movs	r3, #27
100022c8:	18fb      	adds	r3, r7, r3
100022ca:	6a3a      	ldr	r2, [r7, #32]
100022cc:	2145      	movs	r1, #69	; 0x45
100022ce:	5c52      	ldrb	r2, [r2, r1]
100022d0:	701a      	strb	r2, [r3, #0]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
100022d2:	6a3b      	ldr	r3, [r7, #32]
100022d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100022d6:	617b      	str	r3, [r7, #20]
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
100022d8:	6a39      	ldr	r1, [r7, #32]
100022da:	68ba      	ldr	r2, [r7, #8]
100022dc:	683b      	ldr	r3, [r7, #0]
100022de:	1c08      	adds	r0, r1, #0
100022e0:	1c11      	adds	r1, r2, #0
100022e2:	1c1a      	adds	r2, r3, #0
100022e4:	f000 f90a 	bl	100024fc <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
100022e8:	231b      	movs	r3, #27
100022ea:	18fb      	adds	r3, r7, r3
100022ec:	781b      	ldrb	r3, [r3, #0]
100022ee:	b25b      	sxtb	r3, r3
100022f0:	3301      	adds	r3, #1
100022f2:	d12a      	bne.n	1000234a <xQueueGenericSendFromISR+0xf2>
            {
                #if ( configUSE_QUEUE_SETS == 1 )
                    {
                        if( pxQueue->pxQueueSetContainer != NULL )
100022f4:	6a3b      	ldr	r3, [r7, #32]
100022f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
100022f8:	2b00      	cmp	r3, #0
100022fa:	d014      	beq.n	10002326 <xQueueGenericSendFromISR+0xce>
                        {
                            if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
100022fc:	683b      	ldr	r3, [r7, #0]
100022fe:	2b02      	cmp	r3, #2
10002300:	d104      	bne.n	1000230c <xQueueGenericSendFromISR+0xb4>
10002302:	697b      	ldr	r3, [r7, #20]
10002304:	2b00      	cmp	r3, #0
10002306:	d001      	beq.n	1000230c <xQueueGenericSendFromISR+0xb4>
10002308:	46c0      	nop			; (mov r8, r8)
1000230a:	e02f      	b.n	1000236c <xQueueGenericSendFromISR+0x114>
                                /* Do not notify the queue set as an existing item
                                 * was overwritten in the queue so the number of items
                                 * in the queue has not changed. */
                                mtCOVERAGE_TEST_MARKER();
                            }
                            else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1000230c:	6a3b      	ldr	r3, [r7, #32]
1000230e:	1c18      	adds	r0, r3, #0
10002310:	f000 fa84 	bl	1000281c <prvNotifyQueueSetContainer>
10002314:	1e03      	subs	r3, r0, #0
10002316:	d029      	beq.n	1000236c <xQueueGenericSendFromISR+0x114>
                            {
                                /* The queue is a member of a queue set, and posting
                                 * to the queue set caused a higher priority task to
                                 * unblock.  A context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
10002318:	687b      	ldr	r3, [r7, #4]
1000231a:	2b00      	cmp	r3, #0
1000231c:	d026      	beq.n	1000236c <xQueueGenericSendFromISR+0x114>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
1000231e:	687b      	ldr	r3, [r7, #4]
10002320:	2201      	movs	r2, #1
10002322:	601a      	str	r2, [r3, #0]
10002324:	e022      	b.n	1000236c <xQueueGenericSendFromISR+0x114>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10002326:	6a3b      	ldr	r3, [r7, #32]
10002328:	6a5b      	ldr	r3, [r3, #36]	; 0x24
1000232a:	2b00      	cmp	r3, #0
1000232c:	d01e      	beq.n	1000236c <xQueueGenericSendFromISR+0x114>
                            {
                                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1000232e:	6a3b      	ldr	r3, [r7, #32]
10002330:	3324      	adds	r3, #36	; 0x24
10002332:	1c18      	adds	r0, r3, #0
10002334:	f000 fe5e 	bl	10002ff4 <xTaskRemoveFromEventList>
10002338:	1e03      	subs	r3, r0, #0
1000233a:	d017      	beq.n	1000236c <xQueueGenericSendFromISR+0x114>
                                {
                                    /* The task waiting has a higher priority so
                                     *  record that a context switch is required. */
                                    if( pxHigherPriorityTaskWoken != NULL )
1000233c:	687b      	ldr	r3, [r7, #4]
1000233e:	2b00      	cmp	r3, #0
10002340:	d014      	beq.n	1000236c <xQueueGenericSendFromISR+0x114>
                                    {
                                        *pxHigherPriorityTaskWoken = pdTRUE;
10002342:	687b      	ldr	r3, [r7, #4]
10002344:	2201      	movs	r2, #1
10002346:	601a      	str	r2, [r3, #0]
10002348:	e010      	b.n	1000236c <xQueueGenericSendFromISR+0x114>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );
1000234a:	231b      	movs	r3, #27
1000234c:	18fb      	adds	r3, r7, r3
1000234e:	781b      	ldrb	r3, [r3, #0]
10002350:	b25b      	sxtb	r3, r3
10002352:	2b7f      	cmp	r3, #127	; 0x7f
10002354:	d101      	bne.n	1000235a <xQueueGenericSendFromISR+0x102>
10002356:	b672      	cpsid	i
10002358:	e7fe      	b.n	10002358 <xQueueGenericSendFromISR+0x100>

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
1000235a:	231b      	movs	r3, #27
1000235c:	18fb      	adds	r3, r7, r3
1000235e:	781b      	ldrb	r3, [r3, #0]
10002360:	3301      	adds	r3, #1
10002362:	b2db      	uxtb	r3, r3
10002364:	b2d9      	uxtb	r1, r3
10002366:	6a3b      	ldr	r3, [r7, #32]
10002368:	2245      	movs	r2, #69	; 0x45
1000236a:	5499      	strb	r1, [r3, r2]
            }

            xReturn = pdPASS;
1000236c:	2301      	movs	r3, #1
1000236e:	627b      	str	r3, [r7, #36]	; 0x24
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
        {
10002370:	e001      	b.n	10002376 <xQueueGenericSendFromISR+0x11e>
            xReturn = pdPASS;
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
10002372:	2300      	movs	r3, #0
10002374:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
10002376:	69fb      	ldr	r3, [r7, #28]
10002378:	1c18      	adds	r0, r3, #0
1000237a:	f7ff faff 	bl	1000197c <vClearInterruptMaskFromISR>

    return xReturn;
1000237e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
10002380:	1c18      	adds	r0, r3, #0
10002382:	46bd      	mov	sp, r7
10002384:	b00a      	add	sp, #40	; 0x28
10002386:	bd80      	pop	{r7, pc}

10002388 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
10002388:	b580      	push	{r7, lr}
1000238a:	b08a      	sub	sp, #40	; 0x28
1000238c:	af00      	add	r7, sp, #0
1000238e:	60f8      	str	r0, [r7, #12]
10002390:	60b9      	str	r1, [r7, #8]
10002392:	607a      	str	r2, [r7, #4]
    BaseType_t xEntryTimeSet = pdFALSE;
10002394:	2300      	movs	r3, #0
10002396:	627b      	str	r3, [r7, #36]	; 0x24
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
10002398:	68fb      	ldr	r3, [r7, #12]
1000239a:	623b      	str	r3, [r7, #32]

    /* Check the pointer is not NULL. */
    configASSERT( ( pxQueue ) );
1000239c:	6a3b      	ldr	r3, [r7, #32]
1000239e:	2b00      	cmp	r3, #0
100023a0:	d101      	bne.n	100023a6 <xQueueReceive+0x1e>
100023a2:	b672      	cpsid	i
100023a4:	e7fe      	b.n	100023a4 <xQueueReceive+0x1c>

    /* The buffer into which data is received can only be NULL if the data size
     * is zero (so no data is copied into the buffer). */
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
100023a6:	68bb      	ldr	r3, [r7, #8]
100023a8:	2b00      	cmp	r3, #0
100023aa:	d103      	bne.n	100023b4 <xQueueReceive+0x2c>
100023ac:	6a3b      	ldr	r3, [r7, #32]
100023ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100023b0:	2b00      	cmp	r3, #0
100023b2:	d101      	bne.n	100023b8 <xQueueReceive+0x30>
100023b4:	2301      	movs	r3, #1
100023b6:	e000      	b.n	100023ba <xQueueReceive+0x32>
100023b8:	2300      	movs	r3, #0
100023ba:	2b00      	cmp	r3, #0
100023bc:	d101      	bne.n	100023c2 <xQueueReceive+0x3a>
100023be:	b672      	cpsid	i
100023c0:	e7fe      	b.n	100023c0 <xQueueReceive+0x38>

    /* Cannot block if the scheduler is suspended. */
    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
100023c2:	f000 ff9d 	bl	10003300 <xTaskGetSchedulerState>
100023c6:	1e03      	subs	r3, r0, #0
100023c8:	d102      	bne.n	100023d0 <xQueueReceive+0x48>
100023ca:	687b      	ldr	r3, [r7, #4]
100023cc:	2b00      	cmp	r3, #0
100023ce:	d101      	bne.n	100023d4 <xQueueReceive+0x4c>
100023d0:	2301      	movs	r3, #1
100023d2:	e000      	b.n	100023d6 <xQueueReceive+0x4e>
100023d4:	2300      	movs	r3, #0
100023d6:	2b00      	cmp	r3, #0
100023d8:	d101      	bne.n	100023de <xQueueReceive+0x56>
100023da:	b672      	cpsid	i
100023dc:	e7fe      	b.n	100023dc <xQueueReceive+0x54>
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
100023de:	f7ff faa1 	bl	10001924 <vPortEnterCritical>
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
100023e2:	6a3b      	ldr	r3, [r7, #32]
100023e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100023e6:	61fb      	str	r3, [r7, #28]

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
100023e8:	69fb      	ldr	r3, [r7, #28]
100023ea:	2b00      	cmp	r3, #0
100023ec:	d01a      	beq.n	10002424 <xQueueReceive+0x9c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
100023ee:	6a3a      	ldr	r2, [r7, #32]
100023f0:	68bb      	ldr	r3, [r7, #8]
100023f2:	1c10      	adds	r0, r2, #0
100023f4:	1c19      	adds	r1, r3, #0
100023f6:	f000 f8f1 	bl	100025dc <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
100023fa:	69fb      	ldr	r3, [r7, #28]
100023fc:	1e5a      	subs	r2, r3, #1
100023fe:	6a3b      	ldr	r3, [r7, #32]
10002400:	639a      	str	r2, [r3, #56]	; 0x38

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
10002402:	6a3b      	ldr	r3, [r7, #32]
10002404:	691b      	ldr	r3, [r3, #16]
10002406:	2b00      	cmp	r3, #0
10002408:	d008      	beq.n	1000241c <xQueueReceive+0x94>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1000240a:	6a3b      	ldr	r3, [r7, #32]
1000240c:	3310      	adds	r3, #16
1000240e:	1c18      	adds	r0, r3, #0
10002410:	f000 fdf0 	bl	10002ff4 <xTaskRemoveFromEventList>
10002414:	1e03      	subs	r3, r0, #0
10002416:	d001      	beq.n	1000241c <xQueueReceive+0x94>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
10002418:	f7ff fa76 	bl	10001908 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
1000241c:	f7ff fa92 	bl	10001944 <vPortExitCritical>
                return pdPASS;
10002420:	2301      	movs	r3, #1
10002422:	e066      	b.n	100024f2 <xQueueReceive+0x16a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
10002424:	687b      	ldr	r3, [r7, #4]
10002426:	2b00      	cmp	r3, #0
10002428:	d103      	bne.n	10002432 <xQueueReceive+0xaa>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
1000242a:	f7ff fa8b 	bl	10001944 <vPortExitCritical>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
1000242e:	2300      	movs	r3, #0
10002430:	e05f      	b.n	100024f2 <xQueueReceive+0x16a>
                }
                else if( xEntryTimeSet == pdFALSE )
10002432:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10002434:	2b00      	cmp	r3, #0
10002436:	d106      	bne.n	10002446 <xQueueReceive+0xbe>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
10002438:	2314      	movs	r3, #20
1000243a:	18fb      	adds	r3, r7, r3
1000243c:	1c18      	adds	r0, r3, #0
1000243e:	f000 fe35 	bl	100030ac <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
10002442:	2301      	movs	r3, #1
10002444:	627b      	str	r3, [r7, #36]	; 0x24
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
10002446:	f7ff fa7d 	bl	10001944 <vPortExitCritical>

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
1000244a:	f000 fbed 	bl	10002c28 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
1000244e:	f7ff fa69 	bl	10001924 <vPortEnterCritical>
10002452:	6a3b      	ldr	r3, [r7, #32]
10002454:	2244      	movs	r2, #68	; 0x44
10002456:	5c9b      	ldrb	r3, [r3, r2]
10002458:	b2db      	uxtb	r3, r3
1000245a:	b25b      	sxtb	r3, r3
1000245c:	3301      	adds	r3, #1
1000245e:	d103      	bne.n	10002468 <xQueueReceive+0xe0>
10002460:	6a3b      	ldr	r3, [r7, #32]
10002462:	2244      	movs	r2, #68	; 0x44
10002464:	2100      	movs	r1, #0
10002466:	5499      	strb	r1, [r3, r2]
10002468:	6a3b      	ldr	r3, [r7, #32]
1000246a:	2245      	movs	r2, #69	; 0x45
1000246c:	5c9b      	ldrb	r3, [r3, r2]
1000246e:	b2db      	uxtb	r3, r3
10002470:	b25b      	sxtb	r3, r3
10002472:	3301      	adds	r3, #1
10002474:	d103      	bne.n	1000247e <xQueueReceive+0xf6>
10002476:	6a3b      	ldr	r3, [r7, #32]
10002478:	2245      	movs	r2, #69	; 0x45
1000247a:	2100      	movs	r1, #0
1000247c:	5499      	strb	r1, [r3, r2]
1000247e:	f7ff fa61 	bl	10001944 <vPortExitCritical>

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
10002482:	2314      	movs	r3, #20
10002484:	18fa      	adds	r2, r7, r3
10002486:	1d3b      	adds	r3, r7, #4
10002488:	1c10      	adds	r0, r2, #0
1000248a:	1c19      	adds	r1, r3, #0
1000248c:	f000 fe22 	bl	100030d4 <xTaskCheckForTimeOut>
10002490:	1e03      	subs	r3, r0, #0
10002492:	d11f      	bne.n	100024d4 <xQueueReceive+0x14c>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
10002494:	6a3b      	ldr	r3, [r7, #32]
10002496:	1c18      	adds	r0, r3, #0
10002498:	f000 f934 	bl	10002704 <prvIsQueueEmpty>
1000249c:	1e03      	subs	r3, r0, #0
1000249e:	d012      	beq.n	100024c6 <xQueueReceive+0x13e>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
100024a0:	6a3b      	ldr	r3, [r7, #32]
100024a2:	3324      	adds	r3, #36	; 0x24
100024a4:	1c1a      	adds	r2, r3, #0
100024a6:	687b      	ldr	r3, [r7, #4]
100024a8:	1c10      	adds	r0, r2, #0
100024aa:	1c19      	adds	r1, r3, #0
100024ac:	f000 fd62 	bl	10002f74 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
100024b0:	6a3b      	ldr	r3, [r7, #32]
100024b2:	1c18      	adds	r0, r3, #0
100024b4:	f000 f8ba 	bl	1000262c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
100024b8:	f000 fbc2 	bl	10002c40 <xTaskResumeAll>
100024bc:	1e03      	subs	r3, r0, #0
100024be:	d117      	bne.n	100024f0 <xQueueReceive+0x168>
                {
                    portYIELD_WITHIN_API();
100024c0:	f7ff fa22 	bl	10001908 <vPortYield>
100024c4:	e014      	b.n	100024f0 <xQueueReceive+0x168>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
100024c6:	6a3b      	ldr	r3, [r7, #32]
100024c8:	1c18      	adds	r0, r3, #0
100024ca:	f000 f8af 	bl	1000262c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
100024ce:	f000 fbb7 	bl	10002c40 <xTaskResumeAll>
100024d2:	e784      	b.n	100023de <xQueueReceive+0x56>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
100024d4:	6a3b      	ldr	r3, [r7, #32]
100024d6:	1c18      	adds	r0, r3, #0
100024d8:	f000 f8a8 	bl	1000262c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
100024dc:	f000 fbb0 	bl	10002c40 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
100024e0:	6a3b      	ldr	r3, [r7, #32]
100024e2:	1c18      	adds	r0, r3, #0
100024e4:	f000 f90e 	bl	10002704 <prvIsQueueEmpty>
100024e8:	1e03      	subs	r3, r0, #0
100024ea:	d001      	beq.n	100024f0 <xQueueReceive+0x168>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
100024ec:	2300      	movs	r3, #0
100024ee:	e000      	b.n	100024f2 <xQueueReceive+0x16a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
100024f0:	e775      	b.n	100023de <xQueueReceive+0x56>
}
100024f2:	1c18      	adds	r0, r3, #0
100024f4:	46bd      	mov	sp, r7
100024f6:	b00a      	add	sp, #40	; 0x28
100024f8:	bd80      	pop	{r7, pc}
100024fa:	46c0      	nop			; (mov r8, r8)

100024fc <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
100024fc:	b580      	push	{r7, lr}
100024fe:	b086      	sub	sp, #24
10002500:	af00      	add	r7, sp, #0
10002502:	60f8      	str	r0, [r7, #12]
10002504:	60b9      	str	r1, [r7, #8]
10002506:	607a      	str	r2, [r7, #4]
    BaseType_t xReturn = pdFALSE;
10002508:	2300      	movs	r3, #0
1000250a:	617b      	str	r3, [r7, #20]
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1000250c:	68fb      	ldr	r3, [r7, #12]
1000250e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10002510:	613b      	str	r3, [r7, #16]

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
10002512:	68fb      	ldr	r3, [r7, #12]
10002514:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002516:	2b00      	cmp	r3, #0
10002518:	d10e      	bne.n	10002538 <prvCopyDataToQueue+0x3c>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1000251a:	68fb      	ldr	r3, [r7, #12]
1000251c:	681b      	ldr	r3, [r3, #0]
1000251e:	2b00      	cmp	r3, #0
10002520:	d152      	bne.n	100025c8 <prvCopyDataToQueue+0xcc>
                {
                    /* The mutex is no longer being held. */
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
10002522:	68fb      	ldr	r3, [r7, #12]
10002524:	689b      	ldr	r3, [r3, #8]
10002526:	1c18      	adds	r0, r3, #0
10002528:	f000 ff06 	bl	10003338 <xTaskPriorityDisinherit>
1000252c:	1c03      	adds	r3, r0, #0
1000252e:	617b      	str	r3, [r7, #20]
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
10002530:	68fb      	ldr	r3, [r7, #12]
10002532:	2200      	movs	r2, #0
10002534:	609a      	str	r2, [r3, #8]
10002536:	e047      	b.n	100025c8 <prvCopyDataToQueue+0xcc>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
10002538:	687b      	ldr	r3, [r7, #4]
1000253a:	2b00      	cmp	r3, #0
1000253c:	d11b      	bne.n	10002576 <prvCopyDataToQueue+0x7a>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
1000253e:	68fb      	ldr	r3, [r7, #12]
10002540:	6859      	ldr	r1, [r3, #4]
10002542:	68fb      	ldr	r3, [r7, #12]
10002544:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002546:	68ba      	ldr	r2, [r7, #8]
10002548:	1c08      	adds	r0, r1, #0
1000254a:	1c11      	adds	r1, r2, #0
1000254c:	1c1a      	adds	r2, r3, #0
1000254e:	f001 fc31 	bl	10003db4 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
10002552:	68fb      	ldr	r3, [r7, #12]
10002554:	685a      	ldr	r2, [r3, #4]
10002556:	68fb      	ldr	r3, [r7, #12]
10002558:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000255a:	18d2      	adds	r2, r2, r3
1000255c:	68fb      	ldr	r3, [r7, #12]
1000255e:	605a      	str	r2, [r3, #4]

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
10002560:	68fb      	ldr	r3, [r7, #12]
10002562:	685a      	ldr	r2, [r3, #4]
10002564:	68fb      	ldr	r3, [r7, #12]
10002566:	689b      	ldr	r3, [r3, #8]
10002568:	429a      	cmp	r2, r3
1000256a:	d32d      	bcc.n	100025c8 <prvCopyDataToQueue+0xcc>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
1000256c:	68fb      	ldr	r3, [r7, #12]
1000256e:	681a      	ldr	r2, [r3, #0]
10002570:	68fb      	ldr	r3, [r7, #12]
10002572:	605a      	str	r2, [r3, #4]
10002574:	e028      	b.n	100025c8 <prvCopyDataToQueue+0xcc>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
10002576:	68fb      	ldr	r3, [r7, #12]
10002578:	68d9      	ldr	r1, [r3, #12]
1000257a:	68fb      	ldr	r3, [r7, #12]
1000257c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
1000257e:	68ba      	ldr	r2, [r7, #8]
10002580:	1c08      	adds	r0, r1, #0
10002582:	1c11      	adds	r1, r2, #0
10002584:	1c1a      	adds	r2, r3, #0
10002586:	f001 fc15 	bl	10003db4 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
1000258a:	68fb      	ldr	r3, [r7, #12]
1000258c:	68da      	ldr	r2, [r3, #12]
1000258e:	68fb      	ldr	r3, [r7, #12]
10002590:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002592:	425b      	negs	r3, r3
10002594:	18d2      	adds	r2, r2, r3
10002596:	68fb      	ldr	r3, [r7, #12]
10002598:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
1000259a:	68fb      	ldr	r3, [r7, #12]
1000259c:	68da      	ldr	r2, [r3, #12]
1000259e:	68fb      	ldr	r3, [r7, #12]
100025a0:	681b      	ldr	r3, [r3, #0]
100025a2:	429a      	cmp	r2, r3
100025a4:	d207      	bcs.n	100025b6 <prvCopyDataToQueue+0xba>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
100025a6:	68fb      	ldr	r3, [r7, #12]
100025a8:	689a      	ldr	r2, [r3, #8]
100025aa:	68fb      	ldr	r3, [r7, #12]
100025ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100025ae:	425b      	negs	r3, r3
100025b0:	18d2      	adds	r2, r2, r3
100025b2:	68fb      	ldr	r3, [r7, #12]
100025b4:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
100025b6:	687b      	ldr	r3, [r7, #4]
100025b8:	2b02      	cmp	r3, #2
100025ba:	d105      	bne.n	100025c8 <prvCopyDataToQueue+0xcc>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
100025bc:	693b      	ldr	r3, [r7, #16]
100025be:	2b00      	cmp	r3, #0
100025c0:	d002      	beq.n	100025c8 <prvCopyDataToQueue+0xcc>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
100025c2:	693b      	ldr	r3, [r7, #16]
100025c4:	3b01      	subs	r3, #1
100025c6:	613b      	str	r3, [r7, #16]
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
100025c8:	693b      	ldr	r3, [r7, #16]
100025ca:	1c5a      	adds	r2, r3, #1
100025cc:	68fb      	ldr	r3, [r7, #12]
100025ce:	639a      	str	r2, [r3, #56]	; 0x38

    return xReturn;
100025d0:	697b      	ldr	r3, [r7, #20]
}
100025d2:	1c18      	adds	r0, r3, #0
100025d4:	46bd      	mov	sp, r7
100025d6:	b006      	add	sp, #24
100025d8:	bd80      	pop	{r7, pc}
100025da:	46c0      	nop			; (mov r8, r8)

100025dc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
100025dc:	b580      	push	{r7, lr}
100025de:	b082      	sub	sp, #8
100025e0:	af00      	add	r7, sp, #0
100025e2:	6078      	str	r0, [r7, #4]
100025e4:	6039      	str	r1, [r7, #0]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
100025e6:	687b      	ldr	r3, [r7, #4]
100025e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100025ea:	2b00      	cmp	r3, #0
100025ec:	d01a      	beq.n	10002624 <prvCopyDataFromQueue+0x48>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
100025ee:	687b      	ldr	r3, [r7, #4]
100025f0:	68da      	ldr	r2, [r3, #12]
100025f2:	687b      	ldr	r3, [r7, #4]
100025f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
100025f6:	18d2      	adds	r2, r2, r3
100025f8:	687b      	ldr	r3, [r7, #4]
100025fa:	60da      	str	r2, [r3, #12]

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
100025fc:	687b      	ldr	r3, [r7, #4]
100025fe:	68da      	ldr	r2, [r3, #12]
10002600:	687b      	ldr	r3, [r7, #4]
10002602:	689b      	ldr	r3, [r3, #8]
10002604:	429a      	cmp	r2, r3
10002606:	d303      	bcc.n	10002610 <prvCopyDataFromQueue+0x34>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
10002608:	687b      	ldr	r3, [r7, #4]
1000260a:	681a      	ldr	r2, [r3, #0]
1000260c:	687b      	ldr	r3, [r7, #4]
1000260e:	60da      	str	r2, [r3, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
10002610:	687b      	ldr	r3, [r7, #4]
10002612:	68da      	ldr	r2, [r3, #12]
10002614:	687b      	ldr	r3, [r7, #4]
10002616:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002618:	6839      	ldr	r1, [r7, #0]
1000261a:	1c08      	adds	r0, r1, #0
1000261c:	1c11      	adds	r1, r2, #0
1000261e:	1c1a      	adds	r2, r3, #0
10002620:	f001 fbc8 	bl	10003db4 <memcpy>
    }
}
10002624:	46bd      	mov	sp, r7
10002626:	b002      	add	sp, #8
10002628:	bd80      	pop	{r7, pc}
1000262a:	46c0      	nop			; (mov r8, r8)

1000262c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
1000262c:	b580      	push	{r7, lr}
1000262e:	b084      	sub	sp, #16
10002630:	af00      	add	r7, sp, #0
10002632:	6078      	str	r0, [r7, #4]

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
10002634:	f7ff f976 	bl	10001924 <vPortEnterCritical>
    {
        int8_t cTxLock = pxQueue->cTxLock;
10002638:	230f      	movs	r3, #15
1000263a:	18fb      	adds	r3, r7, r3
1000263c:	687a      	ldr	r2, [r7, #4]
1000263e:	2145      	movs	r1, #69	; 0x45
10002640:	5c52      	ldrb	r2, [r2, r1]
10002642:	701a      	strb	r2, [r3, #0]

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
10002644:	e023      	b.n	1000268e <prvUnlockQueue+0x62>
        {
            /* Data was posted while the queue was locked.  Are any tasks
             * blocked waiting for data to become available? */
            #if ( configUSE_QUEUE_SETS == 1 )
                {
                    if( pxQueue->pxQueueSetContainer != NULL )
10002646:	687b      	ldr	r3, [r7, #4]
10002648:	6c9b      	ldr	r3, [r3, #72]	; 0x48
1000264a:	2b00      	cmp	r3, #0
1000264c:	d008      	beq.n	10002660 <prvUnlockQueue+0x34>
                    {
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1000264e:	687b      	ldr	r3, [r7, #4]
10002650:	1c18      	adds	r0, r3, #0
10002652:	f000 f8e3 	bl	1000281c <prvNotifyQueueSetContainer>
10002656:	1e03      	subs	r3, r0, #0
10002658:	d011      	beq.n	1000267e <prvUnlockQueue+0x52>
                        {
                            /* The queue is a member of a queue set, and posting to
                             * the queue set caused a higher priority task to unblock.
                             * A context switch is required. */
                            vTaskMissedYield();
1000265a:	f000 fd9f 	bl	1000319c <vTaskMissedYield>
1000265e:	e00e      	b.n	1000267e <prvUnlockQueue+0x52>
                    else
                    {
                        /* Tasks that are removed from the event list will get
                         * added to the pending ready list as the scheduler is still
                         * suspended. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
10002660:	687b      	ldr	r3, [r7, #4]
10002662:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10002664:	2b00      	cmp	r3, #0
10002666:	d009      	beq.n	1000267c <prvUnlockQueue+0x50>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
10002668:	687b      	ldr	r3, [r7, #4]
1000266a:	3324      	adds	r3, #36	; 0x24
1000266c:	1c18      	adds	r0, r3, #0
1000266e:	f000 fcc1 	bl	10002ff4 <xTaskRemoveFromEventList>
10002672:	1e03      	subs	r3, r0, #0
10002674:	d003      	beq.n	1000267e <prvUnlockQueue+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                vTaskMissedYield();
10002676:	f000 fd91 	bl	1000319c <vTaskMissedYield>
1000267a:	e000      	b.n	1000267e <prvUnlockQueue+0x52>
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else
                        {
                            break;
1000267c:	e00d      	b.n	1000269a <prvUnlockQueue+0x6e>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
1000267e:	230f      	movs	r3, #15
10002680:	18fb      	adds	r3, r7, r3
10002682:	781b      	ldrb	r3, [r3, #0]
10002684:	3b01      	subs	r3, #1
10002686:	b2da      	uxtb	r2, r3
10002688:	230f      	movs	r3, #15
1000268a:	18fb      	adds	r3, r7, r3
1000268c:	701a      	strb	r2, [r3, #0]
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
1000268e:	230f      	movs	r3, #15
10002690:	18fb      	adds	r3, r7, r3
10002692:	781b      	ldrb	r3, [r3, #0]
10002694:	b25b      	sxtb	r3, r3
10002696:	2b00      	cmp	r3, #0
10002698:	dcd5      	bgt.n	10002646 <prvUnlockQueue+0x1a>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
1000269a:	687b      	ldr	r3, [r7, #4]
1000269c:	2245      	movs	r2, #69	; 0x45
1000269e:	21ff      	movs	r1, #255	; 0xff
100026a0:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
100026a2:	f7ff f94f 	bl	10001944 <vPortExitCritical>

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
100026a6:	f7ff f93d 	bl	10001924 <vPortEnterCritical>
    {
        int8_t cRxLock = pxQueue->cRxLock;
100026aa:	230e      	movs	r3, #14
100026ac:	18fb      	adds	r3, r7, r3
100026ae:	687a      	ldr	r2, [r7, #4]
100026b0:	2144      	movs	r1, #68	; 0x44
100026b2:	5c52      	ldrb	r2, [r2, r1]
100026b4:	701a      	strb	r2, [r3, #0]

        while( cRxLock > queueLOCKED_UNMODIFIED )
100026b6:	e016      	b.n	100026e6 <prvUnlockQueue+0xba>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
100026b8:	687b      	ldr	r3, [r7, #4]
100026ba:	691b      	ldr	r3, [r3, #16]
100026bc:	2b00      	cmp	r3, #0
100026be:	d011      	beq.n	100026e4 <prvUnlockQueue+0xb8>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
100026c0:	687b      	ldr	r3, [r7, #4]
100026c2:	3310      	adds	r3, #16
100026c4:	1c18      	adds	r0, r3, #0
100026c6:	f000 fc95 	bl	10002ff4 <xTaskRemoveFromEventList>
100026ca:	1e03      	subs	r3, r0, #0
100026cc:	d001      	beq.n	100026d2 <prvUnlockQueue+0xa6>
                {
                    vTaskMissedYield();
100026ce:	f000 fd65 	bl	1000319c <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
100026d2:	230e      	movs	r3, #14
100026d4:	18fb      	adds	r3, r7, r3
100026d6:	781b      	ldrb	r3, [r3, #0]
100026d8:	3b01      	subs	r3, #1
100026da:	b2da      	uxtb	r2, r3
100026dc:	230e      	movs	r3, #14
100026de:	18fb      	adds	r3, r7, r3
100026e0:	701a      	strb	r2, [r3, #0]
100026e2:	e000      	b.n	100026e6 <prvUnlockQueue+0xba>
            }
            else
            {
                break;
100026e4:	e005      	b.n	100026f2 <prvUnlockQueue+0xc6>
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
100026e6:	230e      	movs	r3, #14
100026e8:	18fb      	adds	r3, r7, r3
100026ea:	781b      	ldrb	r3, [r3, #0]
100026ec:	b25b      	sxtb	r3, r3
100026ee:	2b00      	cmp	r3, #0
100026f0:	dce2      	bgt.n	100026b8 <prvUnlockQueue+0x8c>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
100026f2:	687b      	ldr	r3, [r7, #4]
100026f4:	2244      	movs	r2, #68	; 0x44
100026f6:	21ff      	movs	r1, #255	; 0xff
100026f8:	5499      	strb	r1, [r3, r2]
    }
    taskEXIT_CRITICAL();
100026fa:	f7ff f923 	bl	10001944 <vPortExitCritical>
}
100026fe:	46bd      	mov	sp, r7
10002700:	b004      	add	sp, #16
10002702:	bd80      	pop	{r7, pc}

10002704 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
10002704:	b580      	push	{r7, lr}
10002706:	b084      	sub	sp, #16
10002708:	af00      	add	r7, sp, #0
1000270a:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
1000270c:	f7ff f90a 	bl	10001924 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
10002710:	687b      	ldr	r3, [r7, #4]
10002712:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10002714:	2b00      	cmp	r3, #0
10002716:	d102      	bne.n	1000271e <prvIsQueueEmpty+0x1a>
        {
            xReturn = pdTRUE;
10002718:	2301      	movs	r3, #1
1000271a:	60fb      	str	r3, [r7, #12]
1000271c:	e001      	b.n	10002722 <prvIsQueueEmpty+0x1e>
        }
        else
        {
            xReturn = pdFALSE;
1000271e:	2300      	movs	r3, #0
10002720:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
10002722:	f7ff f90f 	bl	10001944 <vPortExitCritical>

    return xReturn;
10002726:	68fb      	ldr	r3, [r7, #12]
}
10002728:	1c18      	adds	r0, r3, #0
1000272a:	46bd      	mov	sp, r7
1000272c:	b004      	add	sp, #16
1000272e:	bd80      	pop	{r7, pc}

10002730 <prvIsQueueFull>:
    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
10002730:	b580      	push	{r7, lr}
10002732:	b084      	sub	sp, #16
10002734:	af00      	add	r7, sp, #0
10002736:	6078      	str	r0, [r7, #4]
    BaseType_t xReturn;

    taskENTER_CRITICAL();
10002738:	f7ff f8f4 	bl	10001924 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
1000273c:	687b      	ldr	r3, [r7, #4]
1000273e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
10002740:	687b      	ldr	r3, [r7, #4]
10002742:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002744:	429a      	cmp	r2, r3
10002746:	d102      	bne.n	1000274e <prvIsQueueFull+0x1e>
        {
            xReturn = pdTRUE;
10002748:	2301      	movs	r3, #1
1000274a:	60fb      	str	r3, [r7, #12]
1000274c:	e001      	b.n	10002752 <prvIsQueueFull+0x22>
        }
        else
        {
            xReturn = pdFALSE;
1000274e:	2300      	movs	r3, #0
10002750:	60fb      	str	r3, [r7, #12]
        }
    }
    taskEXIT_CRITICAL();
10002752:	f7ff f8f7 	bl	10001944 <vPortExitCritical>

    return xReturn;
10002756:	68fb      	ldr	r3, [r7, #12]
}
10002758:	1c18      	adds	r0, r3, #0
1000275a:	46bd      	mov	sp, r7
1000275c:	b004      	add	sp, #16
1000275e:	bd80      	pop	{r7, pc}

10002760 <vQueueAddToRegistry>:

#if ( configQUEUE_REGISTRY_SIZE > 0 )

    void vQueueAddToRegistry( QueueHandle_t xQueue,
                              const char * pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
10002760:	b580      	push	{r7, lr}
10002762:	b084      	sub	sp, #16
10002764:	af00      	add	r7, sp, #0
10002766:	6078      	str	r0, [r7, #4]
10002768:	6039      	str	r1, [r7, #0]
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
1000276a:	2300      	movs	r3, #0
1000276c:	60fb      	str	r3, [r7, #12]
1000276e:	e014      	b.n	1000279a <vQueueAddToRegistry+0x3a>
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
10002770:	4b0d      	ldr	r3, [pc, #52]	; (100027a8 <vQueueAddToRegistry+0x48>)
10002772:	68fa      	ldr	r2, [r7, #12]
10002774:	00d2      	lsls	r2, r2, #3
10002776:	58d3      	ldr	r3, [r2, r3]
10002778:	2b00      	cmp	r3, #0
1000277a:	d10b      	bne.n	10002794 <vQueueAddToRegistry+0x34>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1000277c:	4b0a      	ldr	r3, [pc, #40]	; (100027a8 <vQueueAddToRegistry+0x48>)
1000277e:	68fa      	ldr	r2, [r7, #12]
10002780:	00d2      	lsls	r2, r2, #3
10002782:	6839      	ldr	r1, [r7, #0]
10002784:	50d1      	str	r1, [r2, r3]
                xQueueRegistry[ ux ].xHandle = xQueue;
10002786:	4a08      	ldr	r2, [pc, #32]	; (100027a8 <vQueueAddToRegistry+0x48>)
10002788:	68fb      	ldr	r3, [r7, #12]
1000278a:	00db      	lsls	r3, r3, #3
1000278c:	18d3      	adds	r3, r2, r3
1000278e:	687a      	ldr	r2, [r7, #4]
10002790:	605a      	str	r2, [r3, #4]

                traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
                break;
10002792:	e005      	b.n	100027a0 <vQueueAddToRegistry+0x40>
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
10002794:	68fb      	ldr	r3, [r7, #12]
10002796:	3301      	adds	r3, #1
10002798:	60fb      	str	r3, [r7, #12]
1000279a:	68fb      	ldr	r3, [r7, #12]
1000279c:	2b07      	cmp	r3, #7
1000279e:	d9e7      	bls.n	10002770 <vQueueAddToRegistry+0x10>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
100027a0:	46bd      	mov	sp, r7
100027a2:	b004      	add	sp, #16
100027a4:	bd80      	pop	{r7, pc}
100027a6:	46c0      	nop			; (mov r8, r8)
100027a8:	20002de4 	.word	0x20002de4

100027ac <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
100027ac:	b580      	push	{r7, lr}
100027ae:	b086      	sub	sp, #24
100027b0:	af00      	add	r7, sp, #0
100027b2:	60f8      	str	r0, [r7, #12]
100027b4:	60b9      	str	r1, [r7, #8]
100027b6:	607a      	str	r2, [r7, #4]
        Queue_t * const pxQueue = xQueue;
100027b8:	68fb      	ldr	r3, [r7, #12]
100027ba:	617b      	str	r3, [r7, #20]
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
100027bc:	f7ff f8b2 	bl	10001924 <vPortEnterCritical>
100027c0:	697b      	ldr	r3, [r7, #20]
100027c2:	2244      	movs	r2, #68	; 0x44
100027c4:	5c9b      	ldrb	r3, [r3, r2]
100027c6:	b2db      	uxtb	r3, r3
100027c8:	b25b      	sxtb	r3, r3
100027ca:	3301      	adds	r3, #1
100027cc:	d103      	bne.n	100027d6 <vQueueWaitForMessageRestricted+0x2a>
100027ce:	697b      	ldr	r3, [r7, #20]
100027d0:	2244      	movs	r2, #68	; 0x44
100027d2:	2100      	movs	r1, #0
100027d4:	5499      	strb	r1, [r3, r2]
100027d6:	697b      	ldr	r3, [r7, #20]
100027d8:	2245      	movs	r2, #69	; 0x45
100027da:	5c9b      	ldrb	r3, [r3, r2]
100027dc:	b2db      	uxtb	r3, r3
100027de:	b25b      	sxtb	r3, r3
100027e0:	3301      	adds	r3, #1
100027e2:	d103      	bne.n	100027ec <vQueueWaitForMessageRestricted+0x40>
100027e4:	697b      	ldr	r3, [r7, #20]
100027e6:	2245      	movs	r2, #69	; 0x45
100027e8:	2100      	movs	r1, #0
100027ea:	5499      	strb	r1, [r3, r2]
100027ec:	f7ff f8aa 	bl	10001944 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
100027f0:	697b      	ldr	r3, [r7, #20]
100027f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
100027f4:	2b00      	cmp	r3, #0
100027f6:	d109      	bne.n	1000280c <vQueueWaitForMessageRestricted+0x60>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
100027f8:	697b      	ldr	r3, [r7, #20]
100027fa:	3324      	adds	r3, #36	; 0x24
100027fc:	1c19      	adds	r1, r3, #0
100027fe:	68ba      	ldr	r2, [r7, #8]
10002800:	687b      	ldr	r3, [r7, #4]
10002802:	1c08      	adds	r0, r1, #0
10002804:	1c11      	adds	r1, r2, #0
10002806:	1c1a      	adds	r2, r3, #0
10002808:	f000 fbd0 	bl	10002fac <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
1000280c:	697b      	ldr	r3, [r7, #20]
1000280e:	1c18      	adds	r0, r3, #0
10002810:	f7ff ff0c 	bl	1000262c <prvUnlockQueue>
    }
10002814:	46bd      	mov	sp, r7
10002816:	b006      	add	sp, #24
10002818:	bd80      	pop	{r7, pc}
1000281a:	46c0      	nop			; (mov r8, r8)

1000281c <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
1000281c:	b580      	push	{r7, lr}
1000281e:	b086      	sub	sp, #24
10002820:	af00      	add	r7, sp, #0
10002822:	6078      	str	r0, [r7, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
10002824:	687b      	ldr	r3, [r7, #4]
10002826:	6c9b      	ldr	r3, [r3, #72]	; 0x48
10002828:	613b      	str	r3, [r7, #16]
        BaseType_t xReturn = pdFALSE;
1000282a:	2300      	movs	r3, #0
1000282c:	617b      	str	r3, [r7, #20]

        /* This function must be called form a critical section. */

        configASSERT( pxQueueSetContainer );
1000282e:	693b      	ldr	r3, [r7, #16]
10002830:	2b00      	cmp	r3, #0
10002832:	d101      	bne.n	10002838 <prvNotifyQueueSetContainer+0x1c>
10002834:	b672      	cpsid	i
10002836:	e7fe      	b.n	10002836 <prvNotifyQueueSetContainer+0x1a>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
10002838:	693b      	ldr	r3, [r7, #16]
1000283a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
1000283c:	693b      	ldr	r3, [r7, #16]
1000283e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002840:	429a      	cmp	r2, r3
10002842:	d301      	bcc.n	10002848 <prvNotifyQueueSetContainer+0x2c>
10002844:	b672      	cpsid	i
10002846:	e7fe      	b.n	10002846 <prvNotifyQueueSetContainer+0x2a>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
10002848:	693b      	ldr	r3, [r7, #16]
1000284a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
1000284c:	693b      	ldr	r3, [r7, #16]
1000284e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
10002850:	429a      	cmp	r2, r3
10002852:	d234      	bcs.n	100028be <prvNotifyQueueSetContainer+0xa2>
        {
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
10002854:	230f      	movs	r3, #15
10002856:	18fb      	adds	r3, r7, r3
10002858:	693a      	ldr	r2, [r7, #16]
1000285a:	2145      	movs	r1, #69	; 0x45
1000285c:	5c52      	ldrb	r2, [r2, r1]
1000285e:	701a      	strb	r2, [r3, #0]

            traceQUEUE_SET_SEND( pxQueueSetContainer );

            /* The data copied is the handle of the queue that contains data. */
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
10002860:	693a      	ldr	r2, [r7, #16]
10002862:	1d3b      	adds	r3, r7, #4
10002864:	1c10      	adds	r0, r2, #0
10002866:	1c19      	adds	r1, r3, #0
10002868:	2200      	movs	r2, #0
1000286a:	f7ff fe47 	bl	100024fc <prvCopyDataToQueue>
1000286e:	1c03      	adds	r3, r0, #0
10002870:	617b      	str	r3, [r7, #20]

            if( cTxLock == queueUNLOCKED )
10002872:	230f      	movs	r3, #15
10002874:	18fb      	adds	r3, r7, r3
10002876:	781b      	ldrb	r3, [r3, #0]
10002878:	b25b      	sxtb	r3, r3
1000287a:	3301      	adds	r3, #1
1000287c:	d10d      	bne.n	1000289a <prvNotifyQueueSetContainer+0x7e>
            {
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
1000287e:	693b      	ldr	r3, [r7, #16]
10002880:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10002882:	2b00      	cmp	r3, #0
10002884:	d01b      	beq.n	100028be <prvNotifyQueueSetContainer+0xa2>
                {
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
10002886:	693b      	ldr	r3, [r7, #16]
10002888:	3324      	adds	r3, #36	; 0x24
1000288a:	1c18      	adds	r0, r3, #0
1000288c:	f000 fbb2 	bl	10002ff4 <xTaskRemoveFromEventList>
10002890:	1e03      	subs	r3, r0, #0
10002892:	d014      	beq.n	100028be <prvNotifyQueueSetContainer+0xa2>
                    {
                        /* The task waiting has a higher priority. */
                        xReturn = pdTRUE;
10002894:	2301      	movs	r3, #1
10002896:	617b      	str	r3, [r7, #20]
10002898:	e011      	b.n	100028be <prvNotifyQueueSetContainer+0xa2>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                configASSERT( cTxLock != queueINT8_MAX );
1000289a:	230f      	movs	r3, #15
1000289c:	18fb      	adds	r3, r7, r3
1000289e:	781b      	ldrb	r3, [r3, #0]
100028a0:	b25b      	sxtb	r3, r3
100028a2:	2b7f      	cmp	r3, #127	; 0x7f
100028a4:	d101      	bne.n	100028aa <prvNotifyQueueSetContainer+0x8e>
100028a6:	b672      	cpsid	i
100028a8:	e7fe      	b.n	100028a8 <prvNotifyQueueSetContainer+0x8c>

                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
100028aa:	230f      	movs	r3, #15
100028ac:	18fb      	adds	r3, r7, r3
100028ae:	781b      	ldrb	r3, [r3, #0]
100028b0:	3301      	adds	r3, #1
100028b2:	b2db      	uxtb	r3, r3
100028b4:	b2d9      	uxtb	r1, r3
100028b6:	693b      	ldr	r3, [r7, #16]
100028b8:	2245      	movs	r2, #69	; 0x45
100028ba:	5499      	strb	r1, [r3, r2]
100028bc:	e7ff      	b.n	100028be <prvNotifyQueueSetContainer+0xa2>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
100028be:	697b      	ldr	r3, [r7, #20]
    }
100028c0:	1c18      	adds	r0, r3, #0
100028c2:	46bd      	mov	sp, r7
100028c4:	b006      	add	sp, #24
100028c6:	bd80      	pop	{r7, pc}

100028c8 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
100028c8:	b590      	push	{r4, r7, lr}
100028ca:	b08d      	sub	sp, #52	; 0x34
100028cc:	af04      	add	r7, sp, #16
100028ce:	60f8      	str	r0, [r7, #12]
100028d0:	60b9      	str	r1, [r7, #8]
100028d2:	603b      	str	r3, [r7, #0]
100028d4:	1dbb      	adds	r3, r7, #6
100028d6:	801a      	strh	r2, [r3, #0]
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
100028d8:	1dbb      	adds	r3, r7, #6
100028da:	881b      	ldrh	r3, [r3, #0]
100028dc:	009b      	lsls	r3, r3, #2
100028de:	1c18      	adds	r0, r3, #0
100028e0:	f7ff f8b6 	bl	10001a50 <pvPortMalloc>
100028e4:	1c03      	adds	r3, r0, #0
100028e6:	617b      	str	r3, [r7, #20]

                if( pxStack != NULL )
100028e8:	697b      	ldr	r3, [r7, #20]
100028ea:	2b00      	cmp	r3, #0
100028ec:	d010      	beq.n	10002910 <xTaskCreate+0x48>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
100028ee:	2070      	movs	r0, #112	; 0x70
100028f0:	f7ff f8ae 	bl	10001a50 <pvPortMalloc>
100028f4:	1c03      	adds	r3, r0, #0
100028f6:	61fb      	str	r3, [r7, #28]

                    if( pxNewTCB != NULL )
100028f8:	69fb      	ldr	r3, [r7, #28]
100028fa:	2b00      	cmp	r3, #0
100028fc:	d003      	beq.n	10002906 <xTaskCreate+0x3e>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
100028fe:	69fb      	ldr	r3, [r7, #28]
10002900:	697a      	ldr	r2, [r7, #20]
10002902:	631a      	str	r2, [r3, #48]	; 0x30
10002904:	e006      	b.n	10002914 <xTaskCreate+0x4c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFree( pxStack );
10002906:	697b      	ldr	r3, [r7, #20]
10002908:	1c18      	adds	r0, r3, #0
1000290a:	f7ff f94d 	bl	10001ba8 <vPortFree>
1000290e:	e001      	b.n	10002914 <xTaskCreate+0x4c>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
10002910:	2300      	movs	r3, #0
10002912:	61fb      	str	r3, [r7, #28]
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
10002914:	69fb      	ldr	r3, [r7, #28]
10002916:	2b00      	cmp	r3, #0
10002918:	d016      	beq.n	10002948 <xTaskCreate+0x80>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
1000291a:	1dbb      	adds	r3, r7, #6
1000291c:	881a      	ldrh	r2, [r3, #0]
1000291e:	68f8      	ldr	r0, [r7, #12]
10002920:	68b9      	ldr	r1, [r7, #8]
10002922:	683c      	ldr	r4, [r7, #0]
10002924:	6b3b      	ldr	r3, [r7, #48]	; 0x30
10002926:	9300      	str	r3, [sp, #0]
10002928:	6b7b      	ldr	r3, [r7, #52]	; 0x34
1000292a:	9301      	str	r3, [sp, #4]
1000292c:	69fb      	ldr	r3, [r7, #28]
1000292e:	9302      	str	r3, [sp, #8]
10002930:	2300      	movs	r3, #0
10002932:	9303      	str	r3, [sp, #12]
10002934:	1c23      	adds	r3, r4, #0
10002936:	f000 f80f 	bl	10002958 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
1000293a:	69fb      	ldr	r3, [r7, #28]
1000293c:	1c18      	adds	r0, r3, #0
1000293e:	f000 f8a7 	bl	10002a90 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
10002942:	2301      	movs	r3, #1
10002944:	61bb      	str	r3, [r7, #24]
10002946:	e002      	b.n	1000294e <xTaskCreate+0x86>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
10002948:	2301      	movs	r3, #1
1000294a:	425b      	negs	r3, r3
1000294c:	61bb      	str	r3, [r7, #24]
        }

        return xReturn;
1000294e:	69bb      	ldr	r3, [r7, #24]
    }
10002950:	1c18      	adds	r0, r3, #0
10002952:	46bd      	mov	sp, r7
10002954:	b009      	add	sp, #36	; 0x24
10002956:	bd90      	pop	{r4, r7, pc}

10002958 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
10002958:	b580      	push	{r7, lr}
1000295a:	b086      	sub	sp, #24
1000295c:	af00      	add	r7, sp, #0
1000295e:	60f8      	str	r0, [r7, #12]
10002960:	60b9      	str	r1, [r7, #8]
10002962:	607a      	str	r2, [r7, #4]
10002964:	603b      	str	r3, [r7, #0]

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
10002966:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002968:	6b1a      	ldr	r2, [r3, #48]	; 0x30
1000296a:	687b      	ldr	r3, [r7, #4]
1000296c:	009b      	lsls	r3, r3, #2
1000296e:	1c10      	adds	r0, r2, #0
10002970:	21a5      	movs	r1, #165	; 0xa5
10002972:	1c1a      	adds	r2, r3, #0
10002974:	f001 fa27 	bl	10003dc6 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
10002978:	6abb      	ldr	r3, [r7, #40]	; 0x28
1000297a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
1000297c:	687b      	ldr	r3, [r7, #4]
1000297e:	4943      	ldr	r1, [pc, #268]	; (10002a8c <prvInitialiseNewTask+0x134>)
10002980:	468c      	mov	ip, r1
10002982:	4463      	add	r3, ip
10002984:	009b      	lsls	r3, r3, #2
10002986:	18d3      	adds	r3, r2, r3
10002988:	613b      	str	r3, [r7, #16]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
1000298a:	693b      	ldr	r3, [r7, #16]
1000298c:	2207      	movs	r2, #7
1000298e:	4393      	bics	r3, r2
10002990:	613b      	str	r3, [r7, #16]

            /* Check the alignment of the calculated top of stack is correct. */
            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
10002992:	693b      	ldr	r3, [r7, #16]
10002994:	2207      	movs	r2, #7
10002996:	4013      	ands	r3, r2
10002998:	d001      	beq.n	1000299e <prvInitialiseNewTask+0x46>
1000299a:	b672      	cpsid	i
1000299c:	e7fe      	b.n	1000299c <prvInitialiseNewTask+0x44>
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
1000299e:	68bb      	ldr	r3, [r7, #8]
100029a0:	2b00      	cmp	r3, #0
100029a2:	d01f      	beq.n	100029e4 <prvInitialiseNewTask+0x8c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
100029a4:	2300      	movs	r3, #0
100029a6:	617b      	str	r3, [r7, #20]
100029a8:	e014      	b.n	100029d4 <prvInitialiseNewTask+0x7c>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
100029aa:	68ba      	ldr	r2, [r7, #8]
100029ac:	697b      	ldr	r3, [r7, #20]
100029ae:	18d3      	adds	r3, r2, r3
100029b0:	7818      	ldrb	r0, [r3, #0]
100029b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
100029b4:	2130      	movs	r1, #48	; 0x30
100029b6:	697b      	ldr	r3, [r7, #20]
100029b8:	18d3      	adds	r3, r2, r3
100029ba:	185b      	adds	r3, r3, r1
100029bc:	1c02      	adds	r2, r0, #0
100029be:	711a      	strb	r2, [r3, #4]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
100029c0:	68ba      	ldr	r2, [r7, #8]
100029c2:	697b      	ldr	r3, [r7, #20]
100029c4:	18d3      	adds	r3, r2, r3
100029c6:	781b      	ldrb	r3, [r3, #0]
100029c8:	2b00      	cmp	r3, #0
100029ca:	d100      	bne.n	100029ce <prvInitialiseNewTask+0x76>
            {
                break;
100029cc:	e005      	b.n	100029da <prvInitialiseNewTask+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
100029ce:	697b      	ldr	r3, [r7, #20]
100029d0:	3301      	adds	r3, #1
100029d2:	617b      	str	r3, [r7, #20]
100029d4:	697b      	ldr	r3, [r7, #20]
100029d6:	2b0f      	cmp	r3, #15
100029d8:	d9e7      	bls.n	100029aa <prvInitialiseNewTask+0x52>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
100029da:	6abb      	ldr	r3, [r7, #40]	; 0x28
100029dc:	2243      	movs	r2, #67	; 0x43
100029de:	2100      	movs	r1, #0
100029e0:	5499      	strb	r1, [r3, r2]
100029e2:	e003      	b.n	100029ec <prvInitialiseNewTask+0x94>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
100029e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
100029e6:	2234      	movs	r2, #52	; 0x34
100029e8:	2100      	movs	r1, #0
100029ea:	5499      	strb	r1, [r3, r2]
    }

    /* This is used as an array index so must ensure it's not too large.  First
     * remove the privilege bit if one is present. */
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
100029ec:	6a3b      	ldr	r3, [r7, #32]
100029ee:	2b04      	cmp	r3, #4
100029f0:	d901      	bls.n	100029f6 <prvInitialiseNewTask+0x9e>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
100029f2:	2304      	movs	r3, #4
100029f4:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
100029f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
100029f8:	6a3a      	ldr	r2, [r7, #32]
100029fa:	62da      	str	r2, [r3, #44]	; 0x2c
    #if ( configUSE_MUTEXES == 1 )
        {
            pxNewTCB->uxBasePriority = uxPriority;
100029fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
100029fe:	6a3a      	ldr	r2, [r7, #32]
10002a00:	64da      	str	r2, [r3, #76]	; 0x4c
            pxNewTCB->uxMutexesHeld = 0;
10002a02:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a04:	2200      	movs	r2, #0
10002a06:	651a      	str	r2, [r3, #80]	; 0x50
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
10002a08:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a0a:	3304      	adds	r3, #4
10002a0c:	1c18      	adds	r0, r3, #0
10002a0e:	f7ff f9ed 	bl	10001dec <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
10002a12:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a14:	3318      	adds	r3, #24
10002a16:	1c18      	adds	r0, r3, #0
10002a18:	f7ff f9e8 	bl	10001dec <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
10002a1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a1e:	6aba      	ldr	r2, [r7, #40]	; 0x28
10002a20:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10002a22:	6a3b      	ldr	r3, [r7, #32]
10002a24:	2205      	movs	r2, #5
10002a26:	1ad2      	subs	r2, r2, r3
10002a28:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a2a:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
10002a2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a2e:	6aba      	ldr	r2, [r7, #40]	; 0x28
10002a30:	625a      	str	r2, [r3, #36]	; 0x24
        }
    #endif

    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
        {
            memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
10002a32:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a34:	3354      	adds	r3, #84	; 0x54
10002a36:	1c18      	adds	r0, r3, #0
10002a38:	2100      	movs	r1, #0
10002a3a:	2214      	movs	r2, #20
10002a3c:	f001 f9c3 	bl	10003dc6 <memset>
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
10002a40:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a42:	3368      	adds	r3, #104	; 0x68
10002a44:	1c18      	adds	r0, r3, #0
10002a46:	2100      	movs	r1, #0
10002a48:	2204      	movs	r2, #4
10002a4a:	f001 f9bc 	bl	10003dc6 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
10002a4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a50:	336c      	adds	r3, #108	; 0x6c
10002a52:	1c18      	adds	r0, r3, #0
10002a54:	2100      	movs	r1, #0
10002a56:	2201      	movs	r2, #1
10002a58:	f001 f9b5 	bl	10003dc6 <memset>
        }
    #endif

    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            pxNewTCB->ucDelayAborted = pdFALSE;
10002a5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a5e:	226d      	movs	r2, #109	; 0x6d
10002a60:	2100      	movs	r1, #0
10002a62:	5499      	strb	r1, [r3, r2]
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
10002a64:	6939      	ldr	r1, [r7, #16]
10002a66:	68fa      	ldr	r2, [r7, #12]
10002a68:	683b      	ldr	r3, [r7, #0]
10002a6a:	1c08      	adds	r0, r1, #0
10002a6c:	1c11      	adds	r1, r2, #0
10002a6e:	1c1a      	adds	r2, r3, #0
10002a70:	f7fe febc 	bl	100017ec <pxPortInitialiseStack>
10002a74:	1c02      	adds	r2, r0, #0
10002a76:	6abb      	ldr	r3, [r7, #40]	; 0x28
10002a78:	601a      	str	r2, [r3, #0]
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
10002a7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10002a7c:	2b00      	cmp	r3, #0
10002a7e:	d002      	beq.n	10002a86 <prvInitialiseNewTask+0x12e>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
10002a80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10002a82:	6aba      	ldr	r2, [r7, #40]	; 0x28
10002a84:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10002a86:	46bd      	mov	sp, r7
10002a88:	b006      	add	sp, #24
10002a8a:	bd80      	pop	{r7, pc}
10002a8c:	3fffffff 	.word	0x3fffffff

10002a90 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
10002a90:	b580      	push	{r7, lr}
10002a92:	b082      	sub	sp, #8
10002a94:	af00      	add	r7, sp, #0
10002a96:	6078      	str	r0, [r7, #4]
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
10002a98:	f7fe ff44 	bl	10001924 <vPortEnterCritical>
    {
        uxCurrentNumberOfTasks++;
10002a9c:	4b29      	ldr	r3, [pc, #164]	; (10002b44 <prvAddNewTaskToReadyList+0xb4>)
10002a9e:	681b      	ldr	r3, [r3, #0]
10002aa0:	1c5a      	adds	r2, r3, #1
10002aa2:	4b28      	ldr	r3, [pc, #160]	; (10002b44 <prvAddNewTaskToReadyList+0xb4>)
10002aa4:	601a      	str	r2, [r3, #0]

        if( pxCurrentTCB == NULL )
10002aa6:	4b28      	ldr	r3, [pc, #160]	; (10002b48 <prvAddNewTaskToReadyList+0xb8>)
10002aa8:	681b      	ldr	r3, [r3, #0]
10002aaa:	2b00      	cmp	r3, #0
10002aac:	d109      	bne.n	10002ac2 <prvAddNewTaskToReadyList+0x32>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
10002aae:	4b26      	ldr	r3, [pc, #152]	; (10002b48 <prvAddNewTaskToReadyList+0xb8>)
10002ab0:	687a      	ldr	r2, [r7, #4]
10002ab2:	601a      	str	r2, [r3, #0]

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
10002ab4:	4b23      	ldr	r3, [pc, #140]	; (10002b44 <prvAddNewTaskToReadyList+0xb4>)
10002ab6:	681b      	ldr	r3, [r3, #0]
10002ab8:	2b01      	cmp	r3, #1
10002aba:	d110      	bne.n	10002ade <prvAddNewTaskToReadyList+0x4e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
10002abc:	f000 fb88 	bl	100031d0 <prvInitialiseTaskLists>
10002ac0:	e00d      	b.n	10002ade <prvAddNewTaskToReadyList+0x4e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
10002ac2:	4b22      	ldr	r3, [pc, #136]	; (10002b4c <prvAddNewTaskToReadyList+0xbc>)
10002ac4:	681b      	ldr	r3, [r3, #0]
10002ac6:	2b00      	cmp	r3, #0
10002ac8:	d109      	bne.n	10002ade <prvAddNewTaskToReadyList+0x4e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
10002aca:	4b1f      	ldr	r3, [pc, #124]	; (10002b48 <prvAddNewTaskToReadyList+0xb8>)
10002acc:	681b      	ldr	r3, [r3, #0]
10002ace:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002ad0:	687b      	ldr	r3, [r7, #4]
10002ad2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10002ad4:	429a      	cmp	r2, r3
10002ad6:	d802      	bhi.n	10002ade <prvAddNewTaskToReadyList+0x4e>
                {
                    pxCurrentTCB = pxNewTCB;
10002ad8:	4b1b      	ldr	r3, [pc, #108]	; (10002b48 <prvAddNewTaskToReadyList+0xb8>)
10002ada:	687a      	ldr	r2, [r7, #4]
10002adc:	601a      	str	r2, [r3, #0]
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
10002ade:	4b1c      	ldr	r3, [pc, #112]	; (10002b50 <prvAddNewTaskToReadyList+0xc0>)
10002ae0:	681b      	ldr	r3, [r3, #0]
10002ae2:	1c5a      	adds	r2, r3, #1
10002ae4:	4b1a      	ldr	r3, [pc, #104]	; (10002b50 <prvAddNewTaskToReadyList+0xc0>)
10002ae6:	601a      	str	r2, [r3, #0]

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
10002ae8:	4b19      	ldr	r3, [pc, #100]	; (10002b50 <prvAddNewTaskToReadyList+0xc0>)
10002aea:	681a      	ldr	r2, [r3, #0]
10002aec:	687b      	ldr	r3, [r7, #4]
10002aee:	645a      	str	r2, [r3, #68]	; 0x44
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
10002af0:	687b      	ldr	r3, [r7, #4]
10002af2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002af4:	4b17      	ldr	r3, [pc, #92]	; (10002b54 <prvAddNewTaskToReadyList+0xc4>)
10002af6:	681b      	ldr	r3, [r3, #0]
10002af8:	429a      	cmp	r2, r3
10002afa:	d903      	bls.n	10002b04 <prvAddNewTaskToReadyList+0x74>
10002afc:	687b      	ldr	r3, [r7, #4]
10002afe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002b00:	4b14      	ldr	r3, [pc, #80]	; (10002b54 <prvAddNewTaskToReadyList+0xc4>)
10002b02:	601a      	str	r2, [r3, #0]
10002b04:	687b      	ldr	r3, [r7, #4]
10002b06:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002b08:	1c13      	adds	r3, r2, #0
10002b0a:	009b      	lsls	r3, r3, #2
10002b0c:	189b      	adds	r3, r3, r2
10002b0e:	009b      	lsls	r3, r3, #2
10002b10:	4a11      	ldr	r2, [pc, #68]	; (10002b58 <prvAddNewTaskToReadyList+0xc8>)
10002b12:	189a      	adds	r2, r3, r2
10002b14:	687b      	ldr	r3, [r7, #4]
10002b16:	3304      	adds	r3, #4
10002b18:	1c10      	adds	r0, r2, #0
10002b1a:	1c19      	adds	r1, r3, #0
10002b1c:	f7ff f970 	bl	10001e00 <vListInsertEnd>

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
10002b20:	f7fe ff10 	bl	10001944 <vPortExitCritical>

    if( xSchedulerRunning != pdFALSE )
10002b24:	4b09      	ldr	r3, [pc, #36]	; (10002b4c <prvAddNewTaskToReadyList+0xbc>)
10002b26:	681b      	ldr	r3, [r3, #0]
10002b28:	2b00      	cmp	r3, #0
10002b2a:	d008      	beq.n	10002b3e <prvAddNewTaskToReadyList+0xae>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
10002b2c:	4b06      	ldr	r3, [pc, #24]	; (10002b48 <prvAddNewTaskToReadyList+0xb8>)
10002b2e:	681b      	ldr	r3, [r3, #0]
10002b30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002b32:	687b      	ldr	r3, [r7, #4]
10002b34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10002b36:	429a      	cmp	r2, r3
10002b38:	d201      	bcs.n	10002b3e <prvAddNewTaskToReadyList+0xae>
        {
            taskYIELD_IF_USING_PREEMPTION();
10002b3a:	f7fe fee5 	bl	10001908 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
10002b3e:	46bd      	mov	sp, r7
10002b40:	b002      	add	sp, #8
10002b42:	bd80      	pop	{r7, pc}
10002b44:	20002d78 	.word	0x20002d78
10002b48:	20002ca0 	.word	0x20002ca0
10002b4c:	20002d84 	.word	0x20002d84
10002b50:	20002d94 	.word	0x20002d94
10002b54:	20002d80 	.word	0x20002d80
10002b58:	20002ca4 	.word	0x20002ca4

10002b5c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
10002b5c:	b580      	push	{r7, lr}
10002b5e:	b084      	sub	sp, #16
10002b60:	af00      	add	r7, sp, #0
10002b62:	6078      	str	r0, [r7, #4]
        BaseType_t xAlreadyYielded = pdFALSE;
10002b64:	2300      	movs	r3, #0
10002b66:	60fb      	str	r3, [r7, #12]

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
10002b68:	687b      	ldr	r3, [r7, #4]
10002b6a:	2b00      	cmp	r3, #0
10002b6c:	d010      	beq.n	10002b90 <vTaskDelay+0x34>
        {
            configASSERT( uxSchedulerSuspended == 0 );
10002b6e:	4b0c      	ldr	r3, [pc, #48]	; (10002ba0 <vTaskDelay+0x44>)
10002b70:	681b      	ldr	r3, [r3, #0]
10002b72:	2b00      	cmp	r3, #0
10002b74:	d001      	beq.n	10002b7a <vTaskDelay+0x1e>
10002b76:	b672      	cpsid	i
10002b78:	e7fe      	b.n	10002b78 <vTaskDelay+0x1c>
            vTaskSuspendAll();
10002b7a:	f000 f855 	bl	10002c28 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
10002b7e:	687b      	ldr	r3, [r7, #4]
10002b80:	1c18      	adds	r0, r3, #0
10002b82:	2100      	movs	r1, #0
10002b84:	f000 fc34 	bl	100033f0 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
10002b88:	f000 f85a 	bl	10002c40 <xTaskResumeAll>
10002b8c:	1c03      	adds	r3, r0, #0
10002b8e:	60fb      	str	r3, [r7, #12]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
10002b90:	68fb      	ldr	r3, [r7, #12]
10002b92:	2b00      	cmp	r3, #0
10002b94:	d101      	bne.n	10002b9a <vTaskDelay+0x3e>
        {
            portYIELD_WITHIN_API();
10002b96:	f7fe feb7 	bl	10001908 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
10002b9a:	46bd      	mov	sp, r7
10002b9c:	b004      	add	sp, #16
10002b9e:	bd80      	pop	{r7, pc}
10002ba0:	20002da0 	.word	0x20002da0

10002ba4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
10002ba4:	b580      	push	{r7, lr}
10002ba6:	b084      	sub	sp, #16
10002ba8:	af02      	add	r7, sp, #8
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
10002baa:	4918      	ldr	r1, [pc, #96]	; (10002c0c <vTaskStartScheduler+0x68>)
10002bac:	4a18      	ldr	r2, [pc, #96]	; (10002c10 <vTaskStartScheduler+0x6c>)
10002bae:	2300      	movs	r3, #0
10002bb0:	9300      	str	r3, [sp, #0]
10002bb2:	4b18      	ldr	r3, [pc, #96]	; (10002c14 <vTaskStartScheduler+0x70>)
10002bb4:	9301      	str	r3, [sp, #4]
10002bb6:	1c08      	adds	r0, r1, #0
10002bb8:	1c11      	adds	r1, r2, #0
10002bba:	223c      	movs	r2, #60	; 0x3c
10002bbc:	2300      	movs	r3, #0
10002bbe:	f7ff fe83 	bl	100028c8 <xTaskCreate>
10002bc2:	1c03      	adds	r3, r0, #0
10002bc4:	607b      	str	r3, [r7, #4]
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
10002bc6:	687b      	ldr	r3, [r7, #4]
10002bc8:	2b01      	cmp	r3, #1
10002bca:	d103      	bne.n	10002bd4 <vTaskStartScheduler+0x30>
            {
                xReturn = xTimerCreateTimerTask();
10002bcc:	f000 fc68 	bl	100034a0 <xTimerCreateTimerTask>
10002bd0:	1c03      	adds	r3, r0, #0
10002bd2:	607b      	str	r3, [r7, #4]
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
10002bd4:	687b      	ldr	r3, [r7, #4]
10002bd6:	2b01      	cmp	r3, #1
10002bd8:	d10d      	bne.n	10002bf6 <vTaskStartScheduler+0x52>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
10002bda:	b672      	cpsid	i
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
10002bdc:	4b0e      	ldr	r3, [pc, #56]	; (10002c18 <vTaskStartScheduler+0x74>)
10002bde:	2201      	movs	r2, #1
10002be0:	4252      	negs	r2, r2
10002be2:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
10002be4:	4b0d      	ldr	r3, [pc, #52]	; (10002c1c <vTaskStartScheduler+0x78>)
10002be6:	2201      	movs	r2, #1
10002be8:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
10002bea:	4b0d      	ldr	r3, [pc, #52]	; (10002c20 <vTaskStartScheduler+0x7c>)
10002bec:	2200      	movs	r2, #0
10002bee:	601a      	str	r2, [r3, #0]

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
10002bf0:	f7fe fe66 	bl	100018c0 <xPortStartScheduler>
10002bf4:	e004      	b.n	10002c00 <vTaskStartScheduler+0x5c>
    else
    {
        /* This line will only be reached if the kernel could not be started,
         * because there was not enough FreeRTOS heap to create the idle task
         * or the timer task. */
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
10002bf6:	687b      	ldr	r3, [r7, #4]
10002bf8:	3301      	adds	r3, #1
10002bfa:	d101      	bne.n	10002c00 <vTaskStartScheduler+0x5c>
10002bfc:	b672      	cpsid	i
10002bfe:	e7fe      	b.n	10002bfe <vTaskStartScheduler+0x5a>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
10002c00:	4b08      	ldr	r3, [pc, #32]	; (10002c24 <vTaskStartScheduler+0x80>)
10002c02:	681b      	ldr	r3, [r3, #0]
}
10002c04:	46bd      	mov	sp, r7
10002c06:	b002      	add	sp, #8
10002c08:	bd80      	pop	{r7, pc}
10002c0a:	46c0      	nop			; (mov r8, r8)
10002c0c:	100031b1 	.word	0x100031b1
10002c10:	10003dd8 	.word	0x10003dd8
10002c14:	20002d9c 	.word	0x20002d9c
10002c18:	20002d98 	.word	0x20002d98
10002c1c:	20002d84 	.word	0x20002d84
10002c20:	20002d7c 	.word	0x20002d7c
10002c24:	20000564 	.word	0x20000564

10002c28 <vTaskSuspendAll>:
    vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
10002c28:	b580      	push	{r7, lr}
10002c2a:	af00      	add	r7, sp, #0
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
10002c2c:	4b03      	ldr	r3, [pc, #12]	; (10002c3c <vTaskSuspendAll+0x14>)
10002c2e:	681b      	ldr	r3, [r3, #0]
10002c30:	1c5a      	adds	r2, r3, #1
10002c32:	4b02      	ldr	r3, [pc, #8]	; (10002c3c <vTaskSuspendAll+0x14>)
10002c34:	601a      	str	r2, [r3, #0]

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
10002c36:	46bd      	mov	sp, r7
10002c38:	bd80      	pop	{r7, pc}
10002c3a:	46c0      	nop			; (mov r8, r8)
10002c3c:	20002da0 	.word	0x20002da0

10002c40 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
10002c40:	b580      	push	{r7, lr}
10002c42:	b084      	sub	sp, #16
10002c44:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
10002c46:	2300      	movs	r3, #0
10002c48:	60fb      	str	r3, [r7, #12]
    BaseType_t xAlreadyYielded = pdFALSE;
10002c4a:	2300      	movs	r3, #0
10002c4c:	60bb      	str	r3, [r7, #8]

    /* If uxSchedulerSuspended is zero then this function does not match a
     * previous call to vTaskSuspendAll(). */
    configASSERT( uxSchedulerSuspended );
10002c4e:	4b3a      	ldr	r3, [pc, #232]	; (10002d38 <xTaskResumeAll+0xf8>)
10002c50:	681b      	ldr	r3, [r3, #0]
10002c52:	2b00      	cmp	r3, #0
10002c54:	d101      	bne.n	10002c5a <xTaskResumeAll+0x1a>
10002c56:	b672      	cpsid	i
10002c58:	e7fe      	b.n	10002c58 <xTaskResumeAll+0x18>
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
10002c5a:	f7fe fe63 	bl	10001924 <vPortEnterCritical>
    {
        --uxSchedulerSuspended;
10002c5e:	4b36      	ldr	r3, [pc, #216]	; (10002d38 <xTaskResumeAll+0xf8>)
10002c60:	681b      	ldr	r3, [r3, #0]
10002c62:	1e5a      	subs	r2, r3, #1
10002c64:	4b34      	ldr	r3, [pc, #208]	; (10002d38 <xTaskResumeAll+0xf8>)
10002c66:	601a      	str	r2, [r3, #0]

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10002c68:	4b33      	ldr	r3, [pc, #204]	; (10002d38 <xTaskResumeAll+0xf8>)
10002c6a:	681b      	ldr	r3, [r3, #0]
10002c6c:	2b00      	cmp	r3, #0
10002c6e:	d15b      	bne.n	10002d28 <xTaskResumeAll+0xe8>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
10002c70:	4b32      	ldr	r3, [pc, #200]	; (10002d3c <xTaskResumeAll+0xfc>)
10002c72:	681b      	ldr	r3, [r3, #0]
10002c74:	2b00      	cmp	r3, #0
10002c76:	d057      	beq.n	10002d28 <xTaskResumeAll+0xe8>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10002c78:	e02f      	b.n	10002cda <xTaskResumeAll+0x9a>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10002c7a:	4b31      	ldr	r3, [pc, #196]	; (10002d40 <xTaskResumeAll+0x100>)
10002c7c:	68db      	ldr	r3, [r3, #12]
10002c7e:	68db      	ldr	r3, [r3, #12]
10002c80:	60fb      	str	r3, [r7, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10002c82:	68fb      	ldr	r3, [r7, #12]
10002c84:	3318      	adds	r3, #24
10002c86:	1c18      	adds	r0, r3, #0
10002c88:	f7ff f912 	bl	10001eb0 <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10002c8c:	68fb      	ldr	r3, [r7, #12]
10002c8e:	3304      	adds	r3, #4
10002c90:	1c18      	adds	r0, r3, #0
10002c92:	f7ff f90d 	bl	10001eb0 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
10002c96:	68fb      	ldr	r3, [r7, #12]
10002c98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002c9a:	4b2a      	ldr	r3, [pc, #168]	; (10002d44 <xTaskResumeAll+0x104>)
10002c9c:	681b      	ldr	r3, [r3, #0]
10002c9e:	429a      	cmp	r2, r3
10002ca0:	d903      	bls.n	10002caa <xTaskResumeAll+0x6a>
10002ca2:	68fb      	ldr	r3, [r7, #12]
10002ca4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002ca6:	4b27      	ldr	r3, [pc, #156]	; (10002d44 <xTaskResumeAll+0x104>)
10002ca8:	601a      	str	r2, [r3, #0]
10002caa:	68fb      	ldr	r3, [r7, #12]
10002cac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002cae:	1c13      	adds	r3, r2, #0
10002cb0:	009b      	lsls	r3, r3, #2
10002cb2:	189b      	adds	r3, r3, r2
10002cb4:	009b      	lsls	r3, r3, #2
10002cb6:	4a24      	ldr	r2, [pc, #144]	; (10002d48 <xTaskResumeAll+0x108>)
10002cb8:	189a      	adds	r2, r3, r2
10002cba:	68fb      	ldr	r3, [r7, #12]
10002cbc:	3304      	adds	r3, #4
10002cbe:	1c10      	adds	r0, r2, #0
10002cc0:	1c19      	adds	r1, r3, #0
10002cc2:	f7ff f89d 	bl	10001e00 <vListInsertEnd>

                    /* If the moved task has a priority higher than the current
                     * task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10002cc6:	68fb      	ldr	r3, [r7, #12]
10002cc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002cca:	4b20      	ldr	r3, [pc, #128]	; (10002d4c <xTaskResumeAll+0x10c>)
10002ccc:	681b      	ldr	r3, [r3, #0]
10002cce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10002cd0:	429a      	cmp	r2, r3
10002cd2:	d302      	bcc.n	10002cda <xTaskResumeAll+0x9a>
                    {
                        xYieldPending = pdTRUE;
10002cd4:	4b1e      	ldr	r3, [pc, #120]	; (10002d50 <xTaskResumeAll+0x110>)
10002cd6:	2201      	movs	r2, #1
10002cd8:	601a      	str	r2, [r3, #0]
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
10002cda:	4b19      	ldr	r3, [pc, #100]	; (10002d40 <xTaskResumeAll+0x100>)
10002cdc:	681b      	ldr	r3, [r3, #0]
10002cde:	2b00      	cmp	r3, #0
10002ce0:	d1cb      	bne.n	10002c7a <xTaskResumeAll+0x3a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
10002ce2:	68fb      	ldr	r3, [r7, #12]
10002ce4:	2b00      	cmp	r3, #0
10002ce6:	d001      	beq.n	10002cec <xTaskResumeAll+0xac>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
10002ce8:	f000 faf2 	bl	100032d0 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
10002cec:	4b19      	ldr	r3, [pc, #100]	; (10002d54 <xTaskResumeAll+0x114>)
10002cee:	681b      	ldr	r3, [r3, #0]
10002cf0:	607b      	str	r3, [r7, #4]

                    if( xPendedCounts > ( TickType_t ) 0U )
10002cf2:	687b      	ldr	r3, [r7, #4]
10002cf4:	2b00      	cmp	r3, #0
10002cf6:	d00f      	beq.n	10002d18 <xTaskResumeAll+0xd8>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
10002cf8:	f000 f83c 	bl	10002d74 <xTaskIncrementTick>
10002cfc:	1e03      	subs	r3, r0, #0
10002cfe:	d002      	beq.n	10002d06 <xTaskResumeAll+0xc6>
                            {
                                xYieldPending = pdTRUE;
10002d00:	4b13      	ldr	r3, [pc, #76]	; (10002d50 <xTaskResumeAll+0x110>)
10002d02:	2201      	movs	r2, #1
10002d04:	601a      	str	r2, [r3, #0]
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
10002d06:	687b      	ldr	r3, [r7, #4]
10002d08:	3b01      	subs	r3, #1
10002d0a:	607b      	str	r3, [r7, #4]
                        } while( xPendedCounts > ( TickType_t ) 0U );
10002d0c:	687b      	ldr	r3, [r7, #4]
10002d0e:	2b00      	cmp	r3, #0
10002d10:	d1f2      	bne.n	10002cf8 <xTaskResumeAll+0xb8>

                        xPendedTicks = 0;
10002d12:	4b10      	ldr	r3, [pc, #64]	; (10002d54 <xTaskResumeAll+0x114>)
10002d14:	2200      	movs	r2, #0
10002d16:	601a      	str	r2, [r3, #0]
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
10002d18:	4b0d      	ldr	r3, [pc, #52]	; (10002d50 <xTaskResumeAll+0x110>)
10002d1a:	681b      	ldr	r3, [r3, #0]
10002d1c:	2b00      	cmp	r3, #0
10002d1e:	d003      	beq.n	10002d28 <xTaskResumeAll+0xe8>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
10002d20:	2301      	movs	r3, #1
10002d22:	60bb      	str	r3, [r7, #8]
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
10002d24:	f7fe fdf0 	bl	10001908 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
10002d28:	f7fe fe0c 	bl	10001944 <vPortExitCritical>

    return xAlreadyYielded;
10002d2c:	68bb      	ldr	r3, [r7, #8]
}
10002d2e:	1c18      	adds	r0, r3, #0
10002d30:	46bd      	mov	sp, r7
10002d32:	b004      	add	sp, #16
10002d34:	bd80      	pop	{r7, pc}
10002d36:	46c0      	nop			; (mov r8, r8)
10002d38:	20002da0 	.word	0x20002da0
10002d3c:	20002d78 	.word	0x20002d78
10002d40:	20002d38 	.word	0x20002d38
10002d44:	20002d80 	.word	0x20002d80
10002d48:	20002ca4 	.word	0x20002ca4
10002d4c:	20002ca0 	.word	0x20002ca0
10002d50:	20002d8c 	.word	0x20002d8c
10002d54:	20002d88 	.word	0x20002d88

10002d58 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
10002d58:	b580      	push	{r7, lr}
10002d5a:	b082      	sub	sp, #8
10002d5c:	af00      	add	r7, sp, #0
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
10002d5e:	4b04      	ldr	r3, [pc, #16]	; (10002d70 <xTaskGetTickCount+0x18>)
10002d60:	681b      	ldr	r3, [r3, #0]
10002d62:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    return xTicks;
10002d64:	687b      	ldr	r3, [r7, #4]
}
10002d66:	1c18      	adds	r0, r3, #0
10002d68:	46bd      	mov	sp, r7
10002d6a:	b002      	add	sp, #8
10002d6c:	bd80      	pop	{r7, pc}
10002d6e:	46c0      	nop			; (mov r8, r8)
10002d70:	20002d7c 	.word	0x20002d7c

10002d74 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
10002d74:	b580      	push	{r7, lr}
10002d76:	b086      	sub	sp, #24
10002d78:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
10002d7a:	2300      	movs	r3, #0
10002d7c:	617b      	str	r3, [r7, #20]
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10002d7e:	4b4a      	ldr	r3, [pc, #296]	; (10002ea8 <xTaskIncrementTick+0x134>)
10002d80:	681b      	ldr	r3, [r3, #0]
10002d82:	2b00      	cmp	r3, #0
10002d84:	d000      	beq.n	10002d88 <xTaskIncrementTick+0x14>
10002d86:	e084      	b.n	10002e92 <xTaskIncrementTick+0x11e>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
10002d88:	4b48      	ldr	r3, [pc, #288]	; (10002eac <xTaskIncrementTick+0x138>)
10002d8a:	681b      	ldr	r3, [r3, #0]
10002d8c:	3301      	adds	r3, #1
10002d8e:	613b      	str	r3, [r7, #16]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
10002d90:	4b46      	ldr	r3, [pc, #280]	; (10002eac <xTaskIncrementTick+0x138>)
10002d92:	693a      	ldr	r2, [r7, #16]
10002d94:	601a      	str	r2, [r3, #0]

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
10002d96:	693b      	ldr	r3, [r7, #16]
10002d98:	2b00      	cmp	r3, #0
10002d9a:	d117      	bne.n	10002dcc <xTaskIncrementTick+0x58>
        {
            taskSWITCH_DELAYED_LISTS();
10002d9c:	4b44      	ldr	r3, [pc, #272]	; (10002eb0 <xTaskIncrementTick+0x13c>)
10002d9e:	681b      	ldr	r3, [r3, #0]
10002da0:	681b      	ldr	r3, [r3, #0]
10002da2:	2b00      	cmp	r3, #0
10002da4:	d001      	beq.n	10002daa <xTaskIncrementTick+0x36>
10002da6:	b672      	cpsid	i
10002da8:	e7fe      	b.n	10002da8 <xTaskIncrementTick+0x34>
10002daa:	4b41      	ldr	r3, [pc, #260]	; (10002eb0 <xTaskIncrementTick+0x13c>)
10002dac:	681b      	ldr	r3, [r3, #0]
10002dae:	60fb      	str	r3, [r7, #12]
10002db0:	4b40      	ldr	r3, [pc, #256]	; (10002eb4 <xTaskIncrementTick+0x140>)
10002db2:	681a      	ldr	r2, [r3, #0]
10002db4:	4b3e      	ldr	r3, [pc, #248]	; (10002eb0 <xTaskIncrementTick+0x13c>)
10002db6:	601a      	str	r2, [r3, #0]
10002db8:	4b3e      	ldr	r3, [pc, #248]	; (10002eb4 <xTaskIncrementTick+0x140>)
10002dba:	68fa      	ldr	r2, [r7, #12]
10002dbc:	601a      	str	r2, [r3, #0]
10002dbe:	4b3e      	ldr	r3, [pc, #248]	; (10002eb8 <xTaskIncrementTick+0x144>)
10002dc0:	681b      	ldr	r3, [r3, #0]
10002dc2:	1c5a      	adds	r2, r3, #1
10002dc4:	4b3c      	ldr	r3, [pc, #240]	; (10002eb8 <xTaskIncrementTick+0x144>)
10002dc6:	601a      	str	r2, [r3, #0]
10002dc8:	f000 fa82 	bl	100032d0 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
10002dcc:	4b3b      	ldr	r3, [pc, #236]	; (10002ebc <xTaskIncrementTick+0x148>)
10002dce:	681b      	ldr	r3, [r3, #0]
10002dd0:	693a      	ldr	r2, [r7, #16]
10002dd2:	429a      	cmp	r2, r3
10002dd4:	d349      	bcc.n	10002e6a <xTaskIncrementTick+0xf6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
10002dd6:	4b36      	ldr	r3, [pc, #216]	; (10002eb0 <xTaskIncrementTick+0x13c>)
10002dd8:	681b      	ldr	r3, [r3, #0]
10002dda:	681b      	ldr	r3, [r3, #0]
10002ddc:	2b00      	cmp	r3, #0
10002dde:	d104      	bne.n	10002dea <xTaskIncrementTick+0x76>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10002de0:	4b36      	ldr	r3, [pc, #216]	; (10002ebc <xTaskIncrementTick+0x148>)
10002de2:	2201      	movs	r2, #1
10002de4:	4252      	negs	r2, r2
10002de6:	601a      	str	r2, [r3, #0]
                    break;
10002de8:	e03f      	b.n	10002e6a <xTaskIncrementTick+0xf6>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10002dea:	4b31      	ldr	r3, [pc, #196]	; (10002eb0 <xTaskIncrementTick+0x13c>)
10002dec:	681b      	ldr	r3, [r3, #0]
10002dee:	68db      	ldr	r3, [r3, #12]
10002df0:	68db      	ldr	r3, [r3, #12]
10002df2:	60bb      	str	r3, [r7, #8]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
10002df4:	68bb      	ldr	r3, [r7, #8]
10002df6:	685b      	ldr	r3, [r3, #4]
10002df8:	607b      	str	r3, [r7, #4]

                    if( xConstTickCount < xItemValue )
10002dfa:	693a      	ldr	r2, [r7, #16]
10002dfc:	687b      	ldr	r3, [r7, #4]
10002dfe:	429a      	cmp	r2, r3
10002e00:	d203      	bcs.n	10002e0a <xTaskIncrementTick+0x96>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
10002e02:	4b2e      	ldr	r3, [pc, #184]	; (10002ebc <xTaskIncrementTick+0x148>)
10002e04:	687a      	ldr	r2, [r7, #4]
10002e06:	601a      	str	r2, [r3, #0]
                        break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
10002e08:	e02f      	b.n	10002e6a <xTaskIncrementTick+0xf6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
10002e0a:	68bb      	ldr	r3, [r7, #8]
10002e0c:	3304      	adds	r3, #4
10002e0e:	1c18      	adds	r0, r3, #0
10002e10:	f7ff f84e 	bl	10001eb0 <uxListRemove>

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
10002e14:	68bb      	ldr	r3, [r7, #8]
10002e16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
10002e18:	2b00      	cmp	r3, #0
10002e1a:	d004      	beq.n	10002e26 <xTaskIncrementTick+0xb2>
                    {
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
10002e1c:	68bb      	ldr	r3, [r7, #8]
10002e1e:	3318      	adds	r3, #24
10002e20:	1c18      	adds	r0, r3, #0
10002e22:	f7ff f845 	bl	10001eb0 <uxListRemove>
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
10002e26:	68bb      	ldr	r3, [r7, #8]
10002e28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002e2a:	4b25      	ldr	r3, [pc, #148]	; (10002ec0 <xTaskIncrementTick+0x14c>)
10002e2c:	681b      	ldr	r3, [r3, #0]
10002e2e:	429a      	cmp	r2, r3
10002e30:	d903      	bls.n	10002e3a <xTaskIncrementTick+0xc6>
10002e32:	68bb      	ldr	r3, [r7, #8]
10002e34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002e36:	4b22      	ldr	r3, [pc, #136]	; (10002ec0 <xTaskIncrementTick+0x14c>)
10002e38:	601a      	str	r2, [r3, #0]
10002e3a:	68bb      	ldr	r3, [r7, #8]
10002e3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002e3e:	1c13      	adds	r3, r2, #0
10002e40:	009b      	lsls	r3, r3, #2
10002e42:	189b      	adds	r3, r3, r2
10002e44:	009b      	lsls	r3, r3, #2
10002e46:	4a1f      	ldr	r2, [pc, #124]	; (10002ec4 <xTaskIncrementTick+0x150>)
10002e48:	189a      	adds	r2, r3, r2
10002e4a:	68bb      	ldr	r3, [r7, #8]
10002e4c:	3304      	adds	r3, #4
10002e4e:	1c10      	adds	r0, r2, #0
10002e50:	1c19      	adds	r1, r3, #0
10002e52:	f7fe ffd5 	bl	10001e00 <vListInsertEnd>
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
10002e56:	68bb      	ldr	r3, [r7, #8]
10002e58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002e5a:	4b1b      	ldr	r3, [pc, #108]	; (10002ec8 <xTaskIncrementTick+0x154>)
10002e5c:	681b      	ldr	r3, [r3, #0]
10002e5e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10002e60:	429a      	cmp	r2, r3
10002e62:	d301      	bcc.n	10002e68 <xTaskIncrementTick+0xf4>
                            {
                                xSwitchRequired = pdTRUE;
10002e64:	2301      	movs	r3, #1
10002e66:	617b      	str	r3, [r7, #20]
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                    #endif /* configUSE_PREEMPTION */
                }
            }
10002e68:	e7b5      	b.n	10002dd6 <xTaskIncrementTick+0x62>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
10002e6a:	4b17      	ldr	r3, [pc, #92]	; (10002ec8 <xTaskIncrementTick+0x154>)
10002e6c:	681b      	ldr	r3, [r3, #0]
10002e6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10002e70:	4914      	ldr	r1, [pc, #80]	; (10002ec4 <xTaskIncrementTick+0x150>)
10002e72:	1c13      	adds	r3, r2, #0
10002e74:	009b      	lsls	r3, r3, #2
10002e76:	189b      	adds	r3, r3, r2
10002e78:	009b      	lsls	r3, r3, #2
10002e7a:	585b      	ldr	r3, [r3, r1]
10002e7c:	2b01      	cmp	r3, #1
10002e7e:	d901      	bls.n	10002e84 <xTaskIncrementTick+0x110>
                {
                    xSwitchRequired = pdTRUE;
10002e80:	2301      	movs	r3, #1
10002e82:	617b      	str	r3, [r7, #20]
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
10002e84:	4b11      	ldr	r3, [pc, #68]	; (10002ecc <xTaskIncrementTick+0x158>)
10002e86:	681b      	ldr	r3, [r3, #0]
10002e88:	2b00      	cmp	r3, #0
10002e8a:	d001      	beq.n	10002e90 <xTaskIncrementTick+0x11c>
                {
                    xSwitchRequired = pdTRUE;
10002e8c:	2301      	movs	r3, #1
10002e8e:	617b      	str	r3, [r7, #20]
10002e90:	e004      	b.n	10002e9c <xTaskIncrementTick+0x128>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
10002e92:	4b0f      	ldr	r3, [pc, #60]	; (10002ed0 <xTaskIncrementTick+0x15c>)
10002e94:	681b      	ldr	r3, [r3, #0]
10002e96:	1c5a      	adds	r2, r3, #1
10002e98:	4b0d      	ldr	r3, [pc, #52]	; (10002ed0 <xTaskIncrementTick+0x15c>)
10002e9a:	601a      	str	r2, [r3, #0]
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
10002e9c:	697b      	ldr	r3, [r7, #20]
}
10002e9e:	1c18      	adds	r0, r3, #0
10002ea0:	46bd      	mov	sp, r7
10002ea2:	b006      	add	sp, #24
10002ea4:	bd80      	pop	{r7, pc}
10002ea6:	46c0      	nop			; (mov r8, r8)
10002ea8:	20002da0 	.word	0x20002da0
10002eac:	20002d7c 	.word	0x20002d7c
10002eb0:	20002d30 	.word	0x20002d30
10002eb4:	20002d34 	.word	0x20002d34
10002eb8:	20002d90 	.word	0x20002d90
10002ebc:	20002d98 	.word	0x20002d98
10002ec0:	20002d80 	.word	0x20002d80
10002ec4:	20002ca4 	.word	0x20002ca4
10002ec8:	20002ca0 	.word	0x20002ca0
10002ecc:	20002d8c 	.word	0x20002d8c
10002ed0:	20002d88 	.word	0x20002d88

10002ed4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
10002ed4:	b580      	push	{r7, lr}
10002ed6:	b082      	sub	sp, #8
10002ed8:	af00      	add	r7, sp, #0
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
10002eda:	4b21      	ldr	r3, [pc, #132]	; (10002f60 <vTaskSwitchContext+0x8c>)
10002edc:	681b      	ldr	r3, [r3, #0]
10002ede:	2b00      	cmp	r3, #0
10002ee0:	d003      	beq.n	10002eea <vTaskSwitchContext+0x16>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
10002ee2:	4b20      	ldr	r3, [pc, #128]	; (10002f64 <vTaskSwitchContext+0x90>)
10002ee4:	2201      	movs	r2, #1
10002ee6:	601a      	str	r2, [r3, #0]
10002ee8:	e037      	b.n	10002f5a <vTaskSwitchContext+0x86>
    }
    else
    {
        xYieldPending = pdFALSE;
10002eea:	4b1e      	ldr	r3, [pc, #120]	; (10002f64 <vTaskSwitchContext+0x90>)
10002eec:	2200      	movs	r2, #0
10002eee:	601a      	str	r2, [r3, #0]
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10002ef0:	4b1d      	ldr	r3, [pc, #116]	; (10002f68 <vTaskSwitchContext+0x94>)
10002ef2:	681b      	ldr	r3, [r3, #0]
10002ef4:	607b      	str	r3, [r7, #4]
10002ef6:	e007      	b.n	10002f08 <vTaskSwitchContext+0x34>
10002ef8:	687b      	ldr	r3, [r7, #4]
10002efa:	2b00      	cmp	r3, #0
10002efc:	d101      	bne.n	10002f02 <vTaskSwitchContext+0x2e>
10002efe:	b672      	cpsid	i
10002f00:	e7fe      	b.n	10002f00 <vTaskSwitchContext+0x2c>
10002f02:	687b      	ldr	r3, [r7, #4]
10002f04:	3b01      	subs	r3, #1
10002f06:	607b      	str	r3, [r7, #4]
10002f08:	4918      	ldr	r1, [pc, #96]	; (10002f6c <vTaskSwitchContext+0x98>)
10002f0a:	687a      	ldr	r2, [r7, #4]
10002f0c:	1c13      	adds	r3, r2, #0
10002f0e:	009b      	lsls	r3, r3, #2
10002f10:	189b      	adds	r3, r3, r2
10002f12:	009b      	lsls	r3, r3, #2
10002f14:	585b      	ldr	r3, [r3, r1]
10002f16:	2b00      	cmp	r3, #0
10002f18:	d0ee      	beq.n	10002ef8 <vTaskSwitchContext+0x24>
10002f1a:	687a      	ldr	r2, [r7, #4]
10002f1c:	1c13      	adds	r3, r2, #0
10002f1e:	009b      	lsls	r3, r3, #2
10002f20:	189b      	adds	r3, r3, r2
10002f22:	009b      	lsls	r3, r3, #2
10002f24:	4a11      	ldr	r2, [pc, #68]	; (10002f6c <vTaskSwitchContext+0x98>)
10002f26:	189b      	adds	r3, r3, r2
10002f28:	603b      	str	r3, [r7, #0]
10002f2a:	683b      	ldr	r3, [r7, #0]
10002f2c:	685b      	ldr	r3, [r3, #4]
10002f2e:	685a      	ldr	r2, [r3, #4]
10002f30:	683b      	ldr	r3, [r7, #0]
10002f32:	605a      	str	r2, [r3, #4]
10002f34:	683b      	ldr	r3, [r7, #0]
10002f36:	685a      	ldr	r2, [r3, #4]
10002f38:	683b      	ldr	r3, [r7, #0]
10002f3a:	3308      	adds	r3, #8
10002f3c:	429a      	cmp	r2, r3
10002f3e:	d104      	bne.n	10002f4a <vTaskSwitchContext+0x76>
10002f40:	683b      	ldr	r3, [r7, #0]
10002f42:	685b      	ldr	r3, [r3, #4]
10002f44:	685a      	ldr	r2, [r3, #4]
10002f46:	683b      	ldr	r3, [r7, #0]
10002f48:	605a      	str	r2, [r3, #4]
10002f4a:	683b      	ldr	r3, [r7, #0]
10002f4c:	685b      	ldr	r3, [r3, #4]
10002f4e:	68da      	ldr	r2, [r3, #12]
10002f50:	4b07      	ldr	r3, [pc, #28]	; (10002f70 <vTaskSwitchContext+0x9c>)
10002f52:	601a      	str	r2, [r3, #0]
10002f54:	4b04      	ldr	r3, [pc, #16]	; (10002f68 <vTaskSwitchContext+0x94>)
10002f56:	687a      	ldr	r2, [r7, #4]
10002f58:	601a      	str	r2, [r3, #0]
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
10002f5a:	46bd      	mov	sp, r7
10002f5c:	b002      	add	sp, #8
10002f5e:	bd80      	pop	{r7, pc}
10002f60:	20002da0 	.word	0x20002da0
10002f64:	20002d8c 	.word	0x20002d8c
10002f68:	20002d80 	.word	0x20002d80
10002f6c:	20002ca4 	.word	0x20002ca4
10002f70:	20002ca0 	.word	0x20002ca0

10002f74 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
10002f74:	b580      	push	{r7, lr}
10002f76:	b082      	sub	sp, #8
10002f78:	af00      	add	r7, sp, #0
10002f7a:	6078      	str	r0, [r7, #4]
10002f7c:	6039      	str	r1, [r7, #0]
    configASSERT( pxEventList );
10002f7e:	687b      	ldr	r3, [r7, #4]
10002f80:	2b00      	cmp	r3, #0
10002f82:	d101      	bne.n	10002f88 <vTaskPlaceOnEventList+0x14>
10002f84:	b672      	cpsid	i
10002f86:	e7fe      	b.n	10002f86 <vTaskPlaceOnEventList+0x12>

    /* Place the event list item of the TCB in the appropriate event list.
     * This is placed in the list in priority order so the highest priority task
     * is the first to be woken by the event.  The queue that contains the event
     * list is locked, preventing simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
10002f88:	4b07      	ldr	r3, [pc, #28]	; (10002fa8 <vTaskPlaceOnEventList+0x34>)
10002f8a:	681b      	ldr	r3, [r3, #0]
10002f8c:	3318      	adds	r3, #24
10002f8e:	687a      	ldr	r2, [r7, #4]
10002f90:	1c10      	adds	r0, r2, #0
10002f92:	1c19      	adds	r1, r3, #0
10002f94:	f7fe ff56 	bl	10001e44 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
10002f98:	683b      	ldr	r3, [r7, #0]
10002f9a:	1c18      	adds	r0, r3, #0
10002f9c:	2101      	movs	r1, #1
10002f9e:	f000 fa27 	bl	100033f0 <prvAddCurrentTaskToDelayedList>
}
10002fa2:	46bd      	mov	sp, r7
10002fa4:	b002      	add	sp, #8
10002fa6:	bd80      	pop	{r7, pc}
10002fa8:	20002ca0 	.word	0x20002ca0

10002fac <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
10002fac:	b580      	push	{r7, lr}
10002fae:	b084      	sub	sp, #16
10002fb0:	af00      	add	r7, sp, #0
10002fb2:	60f8      	str	r0, [r7, #12]
10002fb4:	60b9      	str	r1, [r7, #8]
10002fb6:	607a      	str	r2, [r7, #4]
        configASSERT( pxEventList );
10002fb8:	68fb      	ldr	r3, [r7, #12]
10002fba:	2b00      	cmp	r3, #0
10002fbc:	d101      	bne.n	10002fc2 <vTaskPlaceOnEventListRestricted+0x16>
10002fbe:	b672      	cpsid	i
10002fc0:	e7fe      	b.n	10002fc0 <vTaskPlaceOnEventListRestricted+0x14>

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
10002fc2:	4b0b      	ldr	r3, [pc, #44]	; (10002ff0 <vTaskPlaceOnEventListRestricted+0x44>)
10002fc4:	681b      	ldr	r3, [r3, #0]
10002fc6:	3318      	adds	r3, #24
10002fc8:	68fa      	ldr	r2, [r7, #12]
10002fca:	1c10      	adds	r0, r2, #0
10002fcc:	1c19      	adds	r1, r3, #0
10002fce:	f7fe ff17 	bl	10001e00 <vListInsertEnd>

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
10002fd2:	687b      	ldr	r3, [r7, #4]
10002fd4:	2b00      	cmp	r3, #0
10002fd6:	d002      	beq.n	10002fde <vTaskPlaceOnEventListRestricted+0x32>
        {
            xTicksToWait = portMAX_DELAY;
10002fd8:	2301      	movs	r3, #1
10002fda:	425b      	negs	r3, r3
10002fdc:	60bb      	str	r3, [r7, #8]
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
10002fde:	68ba      	ldr	r2, [r7, #8]
10002fe0:	687b      	ldr	r3, [r7, #4]
10002fe2:	1c10      	adds	r0, r2, #0
10002fe4:	1c19      	adds	r1, r3, #0
10002fe6:	f000 fa03 	bl	100033f0 <prvAddCurrentTaskToDelayedList>
    }
10002fea:	46bd      	mov	sp, r7
10002fec:	b004      	add	sp, #16
10002fee:	bd80      	pop	{r7, pc}
10002ff0:	20002ca0 	.word	0x20002ca0

10002ff4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
10002ff4:	b580      	push	{r7, lr}
10002ff6:	b084      	sub	sp, #16
10002ff8:	af00      	add	r7, sp, #0
10002ffa:	6078      	str	r0, [r7, #4]
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10002ffc:	687b      	ldr	r3, [r7, #4]
10002ffe:	68db      	ldr	r3, [r3, #12]
10003000:	68db      	ldr	r3, [r3, #12]
10003002:	60bb      	str	r3, [r7, #8]
    configASSERT( pxUnblockedTCB );
10003004:	68bb      	ldr	r3, [r7, #8]
10003006:	2b00      	cmp	r3, #0
10003008:	d101      	bne.n	1000300e <xTaskRemoveFromEventList+0x1a>
1000300a:	b672      	cpsid	i
1000300c:	e7fe      	b.n	1000300c <xTaskRemoveFromEventList+0x18>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
1000300e:	68bb      	ldr	r3, [r7, #8]
10003010:	3318      	adds	r3, #24
10003012:	1c18      	adds	r0, r3, #0
10003014:	f7fe ff4c 	bl	10001eb0 <uxListRemove>

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10003018:	4b1e      	ldr	r3, [pc, #120]	; (10003094 <xTaskRemoveFromEventList+0xa0>)
1000301a:	681b      	ldr	r3, [r3, #0]
1000301c:	2b00      	cmp	r3, #0
1000301e:	d11d      	bne.n	1000305c <xTaskRemoveFromEventList+0x68>
    {
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
10003020:	68bb      	ldr	r3, [r7, #8]
10003022:	3304      	adds	r3, #4
10003024:	1c18      	adds	r0, r3, #0
10003026:	f7fe ff43 	bl	10001eb0 <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
1000302a:	68bb      	ldr	r3, [r7, #8]
1000302c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000302e:	4b1a      	ldr	r3, [pc, #104]	; (10003098 <xTaskRemoveFromEventList+0xa4>)
10003030:	681b      	ldr	r3, [r3, #0]
10003032:	429a      	cmp	r2, r3
10003034:	d903      	bls.n	1000303e <xTaskRemoveFromEventList+0x4a>
10003036:	68bb      	ldr	r3, [r7, #8]
10003038:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000303a:	4b17      	ldr	r3, [pc, #92]	; (10003098 <xTaskRemoveFromEventList+0xa4>)
1000303c:	601a      	str	r2, [r3, #0]
1000303e:	68bb      	ldr	r3, [r7, #8]
10003040:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003042:	1c13      	adds	r3, r2, #0
10003044:	009b      	lsls	r3, r3, #2
10003046:	189b      	adds	r3, r3, r2
10003048:	009b      	lsls	r3, r3, #2
1000304a:	4a14      	ldr	r2, [pc, #80]	; (1000309c <xTaskRemoveFromEventList+0xa8>)
1000304c:	189a      	adds	r2, r3, r2
1000304e:	68bb      	ldr	r3, [r7, #8]
10003050:	3304      	adds	r3, #4
10003052:	1c10      	adds	r0, r2, #0
10003054:	1c19      	adds	r1, r3, #0
10003056:	f7fe fed3 	bl	10001e00 <vListInsertEnd>
1000305a:	e006      	b.n	1000306a <xTaskRemoveFromEventList+0x76>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1000305c:	68bb      	ldr	r3, [r7, #8]
1000305e:	3318      	adds	r3, #24
10003060:	4a0f      	ldr	r2, [pc, #60]	; (100030a0 <xTaskRemoveFromEventList+0xac>)
10003062:	1c10      	adds	r0, r2, #0
10003064:	1c19      	adds	r1, r3, #0
10003066:	f7fe fecb 	bl	10001e00 <vListInsertEnd>
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
1000306a:	68bb      	ldr	r3, [r7, #8]
1000306c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
1000306e:	4b0d      	ldr	r3, [pc, #52]	; (100030a4 <xTaskRemoveFromEventList+0xb0>)
10003070:	681b      	ldr	r3, [r3, #0]
10003072:	6adb      	ldr	r3, [r3, #44]	; 0x2c
10003074:	429a      	cmp	r2, r3
10003076:	d905      	bls.n	10003084 <xTaskRemoveFromEventList+0x90>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
10003078:	2301      	movs	r3, #1
1000307a:	60fb      	str	r3, [r7, #12]

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
1000307c:	4b0a      	ldr	r3, [pc, #40]	; (100030a8 <xTaskRemoveFromEventList+0xb4>)
1000307e:	2201      	movs	r2, #1
10003080:	601a      	str	r2, [r3, #0]
10003082:	e001      	b.n	10003088 <xTaskRemoveFromEventList+0x94>
    }
    else
    {
        xReturn = pdFALSE;
10003084:	2300      	movs	r3, #0
10003086:	60fb      	str	r3, [r7, #12]
    }

    return xReturn;
10003088:	68fb      	ldr	r3, [r7, #12]
}
1000308a:	1c18      	adds	r0, r3, #0
1000308c:	46bd      	mov	sp, r7
1000308e:	b004      	add	sp, #16
10003090:	bd80      	pop	{r7, pc}
10003092:	46c0      	nop			; (mov r8, r8)
10003094:	20002da0 	.word	0x20002da0
10003098:	20002d80 	.word	0x20002d80
1000309c:	20002ca4 	.word	0x20002ca4
100030a0:	20002d38 	.word	0x20002d38
100030a4:	20002ca0 	.word	0x20002ca0
100030a8:	20002d8c 	.word	0x20002d8c

100030ac <vTaskInternalSetTimeOutState>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
100030ac:	b580      	push	{r7, lr}
100030ae:	b082      	sub	sp, #8
100030b0:	af00      	add	r7, sp, #0
100030b2:	6078      	str	r0, [r7, #4]
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
100030b4:	4b05      	ldr	r3, [pc, #20]	; (100030cc <vTaskInternalSetTimeOutState+0x20>)
100030b6:	681a      	ldr	r2, [r3, #0]
100030b8:	687b      	ldr	r3, [r7, #4]
100030ba:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
100030bc:	4b04      	ldr	r3, [pc, #16]	; (100030d0 <vTaskInternalSetTimeOutState+0x24>)
100030be:	681a      	ldr	r2, [r3, #0]
100030c0:	687b      	ldr	r3, [r7, #4]
100030c2:	605a      	str	r2, [r3, #4]
}
100030c4:	46bd      	mov	sp, r7
100030c6:	b002      	add	sp, #8
100030c8:	bd80      	pop	{r7, pc}
100030ca:	46c0      	nop			; (mov r8, r8)
100030cc:	20002d90 	.word	0x20002d90
100030d0:	20002d7c 	.word	0x20002d7c

100030d4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
100030d4:	b580      	push	{r7, lr}
100030d6:	b086      	sub	sp, #24
100030d8:	af00      	add	r7, sp, #0
100030da:	6078      	str	r0, [r7, #4]
100030dc:	6039      	str	r1, [r7, #0]
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
100030de:	687b      	ldr	r3, [r7, #4]
100030e0:	2b00      	cmp	r3, #0
100030e2:	d101      	bne.n	100030e8 <xTaskCheckForTimeOut+0x14>
100030e4:	b672      	cpsid	i
100030e6:	e7fe      	b.n	100030e6 <xTaskCheckForTimeOut+0x12>
    configASSERT( pxTicksToWait );
100030e8:	683b      	ldr	r3, [r7, #0]
100030ea:	2b00      	cmp	r3, #0
100030ec:	d101      	bne.n	100030f2 <xTaskCheckForTimeOut+0x1e>
100030ee:	b672      	cpsid	i
100030f0:	e7fe      	b.n	100030f0 <xTaskCheckForTimeOut+0x1c>

    taskENTER_CRITICAL();
100030f2:	f7fe fc17 	bl	10001924 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
100030f6:	4b26      	ldr	r3, [pc, #152]	; (10003190 <xTaskCheckForTimeOut+0xbc>)
100030f8:	681b      	ldr	r3, [r3, #0]
100030fa:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
100030fc:	687b      	ldr	r3, [r7, #4]
100030fe:	685b      	ldr	r3, [r3, #4]
10003100:	693a      	ldr	r2, [r7, #16]
10003102:	1ad3      	subs	r3, r2, r3
10003104:	60fb      	str	r3, [r7, #12]

        #if ( INCLUDE_xTaskAbortDelay == 1 )
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
10003106:	4b23      	ldr	r3, [pc, #140]	; (10003194 <xTaskCheckForTimeOut+0xc0>)
10003108:	681b      	ldr	r3, [r3, #0]
1000310a:	226d      	movs	r2, #109	; 0x6d
1000310c:	5c9b      	ldrb	r3, [r3, r2]
1000310e:	2b00      	cmp	r3, #0
10003110:	d007      	beq.n	10003122 <xTaskCheckForTimeOut+0x4e>
            {
                /* The delay was aborted, which is not the same as a time out,
                 * but has the same result. */
                pxCurrentTCB->ucDelayAborted = pdFALSE;
10003112:	4b20      	ldr	r3, [pc, #128]	; (10003194 <xTaskCheckForTimeOut+0xc0>)
10003114:	681b      	ldr	r3, [r3, #0]
10003116:	226d      	movs	r2, #109	; 0x6d
10003118:	2100      	movs	r1, #0
1000311a:	5499      	strb	r1, [r3, r2]
                xReturn = pdTRUE;
1000311c:	2301      	movs	r3, #1
1000311e:	617b      	str	r3, [r7, #20]
10003120:	e02e      	b.n	10003180 <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
10003122:	683b      	ldr	r3, [r7, #0]
10003124:	681b      	ldr	r3, [r3, #0]
10003126:	3301      	adds	r3, #1
10003128:	d102      	bne.n	10003130 <xTaskCheckForTimeOut+0x5c>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
1000312a:	2300      	movs	r3, #0
1000312c:	617b      	str	r3, [r7, #20]
1000312e:	e027      	b.n	10003180 <xTaskCheckForTimeOut+0xac>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
10003130:	687b      	ldr	r3, [r7, #4]
10003132:	681a      	ldr	r2, [r3, #0]
10003134:	4b18      	ldr	r3, [pc, #96]	; (10003198 <xTaskCheckForTimeOut+0xc4>)
10003136:	681b      	ldr	r3, [r3, #0]
10003138:	429a      	cmp	r2, r3
1000313a:	d00a      	beq.n	10003152 <xTaskCheckForTimeOut+0x7e>
1000313c:	687b      	ldr	r3, [r7, #4]
1000313e:	685a      	ldr	r2, [r3, #4]
10003140:	693b      	ldr	r3, [r7, #16]
10003142:	429a      	cmp	r2, r3
10003144:	d805      	bhi.n	10003152 <xTaskCheckForTimeOut+0x7e>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
10003146:	2301      	movs	r3, #1
10003148:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
1000314a:	683b      	ldr	r3, [r7, #0]
1000314c:	2200      	movs	r2, #0
1000314e:	601a      	str	r2, [r3, #0]
10003150:	e016      	b.n	10003180 <xTaskCheckForTimeOut+0xac>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
10003152:	683b      	ldr	r3, [r7, #0]
10003154:	681a      	ldr	r2, [r3, #0]
10003156:	68fb      	ldr	r3, [r7, #12]
10003158:	429a      	cmp	r2, r3
1000315a:	d90c      	bls.n	10003176 <xTaskCheckForTimeOut+0xa2>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
1000315c:	683b      	ldr	r3, [r7, #0]
1000315e:	681a      	ldr	r2, [r3, #0]
10003160:	68fb      	ldr	r3, [r7, #12]
10003162:	1ad2      	subs	r2, r2, r3
10003164:	683b      	ldr	r3, [r7, #0]
10003166:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
10003168:	687b      	ldr	r3, [r7, #4]
1000316a:	1c18      	adds	r0, r3, #0
1000316c:	f7ff ff9e 	bl	100030ac <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
10003170:	2300      	movs	r3, #0
10003172:	617b      	str	r3, [r7, #20]
10003174:	e004      	b.n	10003180 <xTaskCheckForTimeOut+0xac>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
10003176:	683b      	ldr	r3, [r7, #0]
10003178:	2200      	movs	r2, #0
1000317a:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
1000317c:	2301      	movs	r3, #1
1000317e:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
10003180:	f7fe fbe0 	bl	10001944 <vPortExitCritical>

    return xReturn;
10003184:	697b      	ldr	r3, [r7, #20]
}
10003186:	1c18      	adds	r0, r3, #0
10003188:	46bd      	mov	sp, r7
1000318a:	b006      	add	sp, #24
1000318c:	bd80      	pop	{r7, pc}
1000318e:	46c0      	nop			; (mov r8, r8)
10003190:	20002d7c 	.word	0x20002d7c
10003194:	20002ca0 	.word	0x20002ca0
10003198:	20002d90 	.word	0x20002d90

1000319c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
1000319c:	b580      	push	{r7, lr}
1000319e:	af00      	add	r7, sp, #0
    xYieldPending = pdTRUE;
100031a0:	4b02      	ldr	r3, [pc, #8]	; (100031ac <vTaskMissedYield+0x10>)
100031a2:	2201      	movs	r2, #1
100031a4:	601a      	str	r2, [r3, #0]
}
100031a6:	46bd      	mov	sp, r7
100031a8:	bd80      	pop	{r7, pc}
100031aa:	46c0      	nop			; (mov r8, r8)
100031ac:	20002d8c 	.word	0x20002d8c

100031b0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
100031b0:	b580      	push	{r7, lr}
100031b2:	b082      	sub	sp, #8
100031b4:	af00      	add	r7, sp, #0
100031b6:	6078      	str	r0, [r7, #4]

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
100031b8:	f000 f84e 	bl	10003258 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
100031bc:	4b03      	ldr	r3, [pc, #12]	; (100031cc <prvIdleTask+0x1c>)
100031be:	681b      	ldr	r3, [r3, #0]
100031c0:	2b01      	cmp	r3, #1
100031c2:	d901      	bls.n	100031c8 <prvIdleTask+0x18>
                {
                    taskYIELD();
100031c4:	f7fe fba0 	bl	10001908 <vPortYield>
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_TICKLESS_IDLE */
    }
100031c8:	e7f6      	b.n	100031b8 <prvIdleTask+0x8>
100031ca:	46c0      	nop			; (mov r8, r8)
100031cc:	20002ca4 	.word	0x20002ca4

100031d0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
100031d0:	b580      	push	{r7, lr}
100031d2:	b082      	sub	sp, #8
100031d4:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
100031d6:	2300      	movs	r3, #0
100031d8:	607b      	str	r3, [r7, #4]
100031da:	e00c      	b.n	100031f6 <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
100031dc:	687a      	ldr	r2, [r7, #4]
100031de:	1c13      	adds	r3, r2, #0
100031e0:	009b      	lsls	r3, r3, #2
100031e2:	189b      	adds	r3, r3, r2
100031e4:	009b      	lsls	r3, r3, #2
100031e6:	4a14      	ldr	r2, [pc, #80]	; (10003238 <prvInitialiseTaskLists+0x68>)
100031e8:	189b      	adds	r3, r3, r2
100031ea:	1c18      	adds	r0, r3, #0
100031ec:	f7fe fde0 	bl	10001db0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
100031f0:	687b      	ldr	r3, [r7, #4]
100031f2:	3301      	adds	r3, #1
100031f4:	607b      	str	r3, [r7, #4]
100031f6:	687b      	ldr	r3, [r7, #4]
100031f8:	2b04      	cmp	r3, #4
100031fa:	d9ef      	bls.n	100031dc <prvInitialiseTaskLists+0xc>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
100031fc:	4b0f      	ldr	r3, [pc, #60]	; (1000323c <prvInitialiseTaskLists+0x6c>)
100031fe:	1c18      	adds	r0, r3, #0
10003200:	f7fe fdd6 	bl	10001db0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
10003204:	4b0e      	ldr	r3, [pc, #56]	; (10003240 <prvInitialiseTaskLists+0x70>)
10003206:	1c18      	adds	r0, r3, #0
10003208:	f7fe fdd2 	bl	10001db0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
1000320c:	4b0d      	ldr	r3, [pc, #52]	; (10003244 <prvInitialiseTaskLists+0x74>)
1000320e:	1c18      	adds	r0, r3, #0
10003210:	f7fe fdce 	bl	10001db0 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
10003214:	4b0c      	ldr	r3, [pc, #48]	; (10003248 <prvInitialiseTaskLists+0x78>)
10003216:	1c18      	adds	r0, r3, #0
10003218:	f7fe fdca 	bl	10001db0 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
1000321c:	4b0b      	ldr	r3, [pc, #44]	; (1000324c <prvInitialiseTaskLists+0x7c>)
1000321e:	1c18      	adds	r0, r3, #0
10003220:	f7fe fdc6 	bl	10001db0 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
10003224:	4b0a      	ldr	r3, [pc, #40]	; (10003250 <prvInitialiseTaskLists+0x80>)
10003226:	4a05      	ldr	r2, [pc, #20]	; (1000323c <prvInitialiseTaskLists+0x6c>)
10003228:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
1000322a:	4b0a      	ldr	r3, [pc, #40]	; (10003254 <prvInitialiseTaskLists+0x84>)
1000322c:	4a04      	ldr	r2, [pc, #16]	; (10003240 <prvInitialiseTaskLists+0x70>)
1000322e:	601a      	str	r2, [r3, #0]
}
10003230:	46bd      	mov	sp, r7
10003232:	b002      	add	sp, #8
10003234:	bd80      	pop	{r7, pc}
10003236:	46c0      	nop			; (mov r8, r8)
10003238:	20002ca4 	.word	0x20002ca4
1000323c:	20002d08 	.word	0x20002d08
10003240:	20002d1c 	.word	0x20002d1c
10003244:	20002d38 	.word	0x20002d38
10003248:	20002d4c 	.word	0x20002d4c
1000324c:	20002d64 	.word	0x20002d64
10003250:	20002d30 	.word	0x20002d30
10003254:	20002d34 	.word	0x20002d34

10003258 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
10003258:	b580      	push	{r7, lr}
1000325a:	b082      	sub	sp, #8
1000325c:	af00      	add	r7, sp, #0
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
1000325e:	e01a      	b.n	10003296 <prvCheckTasksWaitingTermination+0x3e>
            {
                taskENTER_CRITICAL();
10003260:	f7fe fb60 	bl	10001924 <vPortEnterCritical>
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003264:	4b0f      	ldr	r3, [pc, #60]	; (100032a4 <prvCheckTasksWaitingTermination+0x4c>)
10003266:	68db      	ldr	r3, [r3, #12]
10003268:	68db      	ldr	r3, [r3, #12]
1000326a:	607b      	str	r3, [r7, #4]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1000326c:	687b      	ldr	r3, [r7, #4]
1000326e:	3304      	adds	r3, #4
10003270:	1c18      	adds	r0, r3, #0
10003272:	f7fe fe1d 	bl	10001eb0 <uxListRemove>
                    --uxCurrentNumberOfTasks;
10003276:	4b0c      	ldr	r3, [pc, #48]	; (100032a8 <prvCheckTasksWaitingTermination+0x50>)
10003278:	681b      	ldr	r3, [r3, #0]
1000327a:	1e5a      	subs	r2, r3, #1
1000327c:	4b0a      	ldr	r3, [pc, #40]	; (100032a8 <prvCheckTasksWaitingTermination+0x50>)
1000327e:	601a      	str	r2, [r3, #0]
                    --uxDeletedTasksWaitingCleanUp;
10003280:	4b0a      	ldr	r3, [pc, #40]	; (100032ac <prvCheckTasksWaitingTermination+0x54>)
10003282:	681b      	ldr	r3, [r3, #0]
10003284:	1e5a      	subs	r2, r3, #1
10003286:	4b09      	ldr	r3, [pc, #36]	; (100032ac <prvCheckTasksWaitingTermination+0x54>)
10003288:	601a      	str	r2, [r3, #0]
                }
                taskEXIT_CRITICAL();
1000328a:	f7fe fb5b 	bl	10001944 <vPortExitCritical>

                prvDeleteTCB( pxTCB );
1000328e:	687b      	ldr	r3, [r7, #4]
10003290:	1c18      	adds	r0, r3, #0
10003292:	f000 f80d 	bl	100032b0 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
10003296:	4b05      	ldr	r3, [pc, #20]	; (100032ac <prvCheckTasksWaitingTermination+0x54>)
10003298:	681b      	ldr	r3, [r3, #0]
1000329a:	2b00      	cmp	r3, #0
1000329c:	d1e0      	bne.n	10003260 <prvCheckTasksWaitingTermination+0x8>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
1000329e:	46bd      	mov	sp, r7
100032a0:	b002      	add	sp, #8
100032a2:	bd80      	pop	{r7, pc}
100032a4:	20002d4c 	.word	0x20002d4c
100032a8:	20002d78 	.word	0x20002d78
100032ac:	20002d60 	.word	0x20002d60

100032b0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
100032b0:	b580      	push	{r7, lr}
100032b2:	b082      	sub	sp, #8
100032b4:	af00      	add	r7, sp, #0
100032b6:	6078      	str	r0, [r7, #4]

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFree( pxTCB->pxStack );
100032b8:	687b      	ldr	r3, [r7, #4]
100032ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
100032bc:	1c18      	adds	r0, r3, #0
100032be:	f7fe fc73 	bl	10001ba8 <vPortFree>
                vPortFree( pxTCB );
100032c2:	687b      	ldr	r3, [r7, #4]
100032c4:	1c18      	adds	r0, r3, #0
100032c6:	f7fe fc6f 	bl	10001ba8 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
100032ca:	46bd      	mov	sp, r7
100032cc:	b002      	add	sp, #8
100032ce:	bd80      	pop	{r7, pc}

100032d0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
100032d0:	b580      	push	{r7, lr}
100032d2:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
100032d4:	4b08      	ldr	r3, [pc, #32]	; (100032f8 <prvResetNextTaskUnblockTime+0x28>)
100032d6:	681b      	ldr	r3, [r3, #0]
100032d8:	681b      	ldr	r3, [r3, #0]
100032da:	2b00      	cmp	r3, #0
100032dc:	d104      	bne.n	100032e8 <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
100032de:	4b07      	ldr	r3, [pc, #28]	; (100032fc <prvResetNextTaskUnblockTime+0x2c>)
100032e0:	2201      	movs	r2, #1
100032e2:	4252      	negs	r2, r2
100032e4:	601a      	str	r2, [r3, #0]
100032e6:	e005      	b.n	100032f4 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
100032e8:	4b03      	ldr	r3, [pc, #12]	; (100032f8 <prvResetNextTaskUnblockTime+0x28>)
100032ea:	681b      	ldr	r3, [r3, #0]
100032ec:	68db      	ldr	r3, [r3, #12]
100032ee:	681a      	ldr	r2, [r3, #0]
100032f0:	4b02      	ldr	r3, [pc, #8]	; (100032fc <prvResetNextTaskUnblockTime+0x2c>)
100032f2:	601a      	str	r2, [r3, #0]
    }
}
100032f4:	46bd      	mov	sp, r7
100032f6:	bd80      	pop	{r7, pc}
100032f8:	20002d30 	.word	0x20002d30
100032fc:	20002d98 	.word	0x20002d98

10003300 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
10003300:	b580      	push	{r7, lr}
10003302:	b082      	sub	sp, #8
10003304:	af00      	add	r7, sp, #0
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
10003306:	4b0a      	ldr	r3, [pc, #40]	; (10003330 <xTaskGetSchedulerState+0x30>)
10003308:	681b      	ldr	r3, [r3, #0]
1000330a:	2b00      	cmp	r3, #0
1000330c:	d102      	bne.n	10003314 <xTaskGetSchedulerState+0x14>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
1000330e:	2301      	movs	r3, #1
10003310:	607b      	str	r3, [r7, #4]
10003312:	e008      	b.n	10003326 <xTaskGetSchedulerState+0x26>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
10003314:	4b07      	ldr	r3, [pc, #28]	; (10003334 <xTaskGetSchedulerState+0x34>)
10003316:	681b      	ldr	r3, [r3, #0]
10003318:	2b00      	cmp	r3, #0
1000331a:	d102      	bne.n	10003322 <xTaskGetSchedulerState+0x22>
            {
                xReturn = taskSCHEDULER_RUNNING;
1000331c:	2302      	movs	r3, #2
1000331e:	607b      	str	r3, [r7, #4]
10003320:	e001      	b.n	10003326 <xTaskGetSchedulerState+0x26>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
10003322:	2300      	movs	r3, #0
10003324:	607b      	str	r3, [r7, #4]
            }
        }

        return xReturn;
10003326:	687b      	ldr	r3, [r7, #4]
    }
10003328:	1c18      	adds	r0, r3, #0
1000332a:	46bd      	mov	sp, r7
1000332c:	b002      	add	sp, #8
1000332e:	bd80      	pop	{r7, pc}
10003330:	20002d84 	.word	0x20002d84
10003334:	20002da0 	.word	0x20002da0

10003338 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
10003338:	b580      	push	{r7, lr}
1000333a:	b084      	sub	sp, #16
1000333c:	af00      	add	r7, sp, #0
1000333e:	6078      	str	r0, [r7, #4]
        TCB_t * const pxTCB = pxMutexHolder;
10003340:	687b      	ldr	r3, [r7, #4]
10003342:	60bb      	str	r3, [r7, #8]
        BaseType_t xReturn = pdFALSE;
10003344:	2300      	movs	r3, #0
10003346:	60fb      	str	r3, [r7, #12]

        if( pxMutexHolder != NULL )
10003348:	687b      	ldr	r3, [r7, #4]
1000334a:	2b00      	cmp	r3, #0
1000334c:	d044      	beq.n	100033d8 <xTaskPriorityDisinherit+0xa0>
        {
            /* A task can only have an inherited priority if it holds the mutex.
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
1000334e:	4b25      	ldr	r3, [pc, #148]	; (100033e4 <xTaskPriorityDisinherit+0xac>)
10003350:	681b      	ldr	r3, [r3, #0]
10003352:	68ba      	ldr	r2, [r7, #8]
10003354:	429a      	cmp	r2, r3
10003356:	d001      	beq.n	1000335c <xTaskPriorityDisinherit+0x24>
10003358:	b672      	cpsid	i
1000335a:	e7fe      	b.n	1000335a <xTaskPriorityDisinherit+0x22>
            configASSERT( pxTCB->uxMutexesHeld );
1000335c:	68bb      	ldr	r3, [r7, #8]
1000335e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
10003360:	2b00      	cmp	r3, #0
10003362:	d101      	bne.n	10003368 <xTaskPriorityDisinherit+0x30>
10003364:	b672      	cpsid	i
10003366:	e7fe      	b.n	10003366 <xTaskPriorityDisinherit+0x2e>
            ( pxTCB->uxMutexesHeld )--;
10003368:	68bb      	ldr	r3, [r7, #8]
1000336a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
1000336c:	1e5a      	subs	r2, r3, #1
1000336e:	68bb      	ldr	r3, [r7, #8]
10003370:	651a      	str	r2, [r3, #80]	; 0x50

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
10003372:	68bb      	ldr	r3, [r7, #8]
10003374:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10003376:	68bb      	ldr	r3, [r7, #8]
10003378:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
1000337a:	429a      	cmp	r2, r3
1000337c:	d02c      	beq.n	100033d8 <xTaskPriorityDisinherit+0xa0>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
1000337e:	68bb      	ldr	r3, [r7, #8]
10003380:	6d1b      	ldr	r3, [r3, #80]	; 0x50
10003382:	2b00      	cmp	r3, #0
10003384:	d128      	bne.n	100033d8 <xTaskPriorityDisinherit+0xa0>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
10003386:	68bb      	ldr	r3, [r7, #8]
10003388:	3304      	adds	r3, #4
1000338a:	1c18      	adds	r0, r3, #0
1000338c:	f7fe fd90 	bl	10001eb0 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
10003390:	68bb      	ldr	r3, [r7, #8]
10003392:	6cda      	ldr	r2, [r3, #76]	; 0x4c
10003394:	68bb      	ldr	r3, [r7, #8]
10003396:	62da      	str	r2, [r3, #44]	; 0x2c

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
10003398:	68bb      	ldr	r3, [r7, #8]
1000339a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
1000339c:	2205      	movs	r2, #5
1000339e:	1ad2      	subs	r2, r2, r3
100033a0:	68bb      	ldr	r3, [r7, #8]
100033a2:	619a      	str	r2, [r3, #24]
                    prvAddTaskToReadyList( pxTCB );
100033a4:	68bb      	ldr	r3, [r7, #8]
100033a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100033a8:	4b0f      	ldr	r3, [pc, #60]	; (100033e8 <xTaskPriorityDisinherit+0xb0>)
100033aa:	681b      	ldr	r3, [r3, #0]
100033ac:	429a      	cmp	r2, r3
100033ae:	d903      	bls.n	100033b8 <xTaskPriorityDisinherit+0x80>
100033b0:	68bb      	ldr	r3, [r7, #8]
100033b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100033b4:	4b0c      	ldr	r3, [pc, #48]	; (100033e8 <xTaskPriorityDisinherit+0xb0>)
100033b6:	601a      	str	r2, [r3, #0]
100033b8:	68bb      	ldr	r3, [r7, #8]
100033ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
100033bc:	1c13      	adds	r3, r2, #0
100033be:	009b      	lsls	r3, r3, #2
100033c0:	189b      	adds	r3, r3, r2
100033c2:	009b      	lsls	r3, r3, #2
100033c4:	4a09      	ldr	r2, [pc, #36]	; (100033ec <xTaskPriorityDisinherit+0xb4>)
100033c6:	189a      	adds	r2, r3, r2
100033c8:	68bb      	ldr	r3, [r7, #8]
100033ca:	3304      	adds	r3, #4
100033cc:	1c10      	adds	r0, r2, #0
100033ce:	1c19      	adds	r1, r3, #0
100033d0:	f7fe fd16 	bl	10001e00 <vListInsertEnd>
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
100033d4:	2301      	movs	r3, #1
100033d6:	60fb      	str	r3, [r7, #12]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
100033d8:	68fb      	ldr	r3, [r7, #12]
    }
100033da:	1c18      	adds	r0, r3, #0
100033dc:	46bd      	mov	sp, r7
100033de:	b004      	add	sp, #16
100033e0:	bd80      	pop	{r7, pc}
100033e2:	46c0      	nop			; (mov r8, r8)
100033e4:	20002ca0 	.word	0x20002ca0
100033e8:	20002d80 	.word	0x20002d80
100033ec:	20002ca4 	.word	0x20002ca4

100033f0 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
100033f0:	b580      	push	{r7, lr}
100033f2:	b084      	sub	sp, #16
100033f4:	af00      	add	r7, sp, #0
100033f6:	6078      	str	r0, [r7, #4]
100033f8:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
100033fa:	4b23      	ldr	r3, [pc, #140]	; (10003488 <prvAddCurrentTaskToDelayedList+0x98>)
100033fc:	681b      	ldr	r3, [r3, #0]
100033fe:	60fb      	str	r3, [r7, #12]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
10003400:	4b22      	ldr	r3, [pc, #136]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
10003402:	681b      	ldr	r3, [r3, #0]
10003404:	226d      	movs	r2, #109	; 0x6d
10003406:	2100      	movs	r1, #0
10003408:	5499      	strb	r1, [r3, r2]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1000340a:	4b20      	ldr	r3, [pc, #128]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
1000340c:	681b      	ldr	r3, [r3, #0]
1000340e:	3304      	adds	r3, #4
10003410:	1c18      	adds	r0, r3, #0
10003412:	f7fe fd4d 	bl	10001eb0 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
10003416:	687b      	ldr	r3, [r7, #4]
10003418:	3301      	adds	r3, #1
1000341a:	d10b      	bne.n	10003434 <prvAddCurrentTaskToDelayedList+0x44>
1000341c:	683b      	ldr	r3, [r7, #0]
1000341e:	2b00      	cmp	r3, #0
10003420:	d008      	beq.n	10003434 <prvAddCurrentTaskToDelayedList+0x44>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
10003422:	4b1a      	ldr	r3, [pc, #104]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
10003424:	681b      	ldr	r3, [r3, #0]
10003426:	3304      	adds	r3, #4
10003428:	4a19      	ldr	r2, [pc, #100]	; (10003490 <prvAddCurrentTaskToDelayedList+0xa0>)
1000342a:	1c10      	adds	r0, r2, #0
1000342c:	1c19      	adds	r1, r3, #0
1000342e:	f7fe fce7 	bl	10001e00 <vListInsertEnd>
10003432:	e026      	b.n	10003482 <prvAddCurrentTaskToDelayedList+0x92>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
10003434:	68fa      	ldr	r2, [r7, #12]
10003436:	687b      	ldr	r3, [r7, #4]
10003438:	18d3      	adds	r3, r2, r3
1000343a:	60bb      	str	r3, [r7, #8]

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
1000343c:	4b13      	ldr	r3, [pc, #76]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
1000343e:	681b      	ldr	r3, [r3, #0]
10003440:	68ba      	ldr	r2, [r7, #8]
10003442:	605a      	str	r2, [r3, #4]

                if( xTimeToWake < xConstTickCount )
10003444:	68ba      	ldr	r2, [r7, #8]
10003446:	68fb      	ldr	r3, [r7, #12]
10003448:	429a      	cmp	r2, r3
1000344a:	d209      	bcs.n	10003460 <prvAddCurrentTaskToDelayedList+0x70>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
1000344c:	4b11      	ldr	r3, [pc, #68]	; (10003494 <prvAddCurrentTaskToDelayedList+0xa4>)
1000344e:	681a      	ldr	r2, [r3, #0]
10003450:	4b0e      	ldr	r3, [pc, #56]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
10003452:	681b      	ldr	r3, [r3, #0]
10003454:	3304      	adds	r3, #4
10003456:	1c10      	adds	r0, r2, #0
10003458:	1c19      	adds	r1, r3, #0
1000345a:	f7fe fcf3 	bl	10001e44 <vListInsert>
1000345e:	e010      	b.n	10003482 <prvAddCurrentTaskToDelayedList+0x92>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
10003460:	4b0d      	ldr	r3, [pc, #52]	; (10003498 <prvAddCurrentTaskToDelayedList+0xa8>)
10003462:	681a      	ldr	r2, [r3, #0]
10003464:	4b09      	ldr	r3, [pc, #36]	; (1000348c <prvAddCurrentTaskToDelayedList+0x9c>)
10003466:	681b      	ldr	r3, [r3, #0]
10003468:	3304      	adds	r3, #4
1000346a:	1c10      	adds	r0, r2, #0
1000346c:	1c19      	adds	r1, r3, #0
1000346e:	f7fe fce9 	bl	10001e44 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
10003472:	4b0a      	ldr	r3, [pc, #40]	; (1000349c <prvAddCurrentTaskToDelayedList+0xac>)
10003474:	681b      	ldr	r3, [r3, #0]
10003476:	68ba      	ldr	r2, [r7, #8]
10003478:	429a      	cmp	r2, r3
1000347a:	d202      	bcs.n	10003482 <prvAddCurrentTaskToDelayedList+0x92>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
1000347c:	4b07      	ldr	r3, [pc, #28]	; (1000349c <prvAddCurrentTaskToDelayedList+0xac>)
1000347e:	68ba      	ldr	r2, [r7, #8]
10003480:	601a      	str	r2, [r3, #0]

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
10003482:	46bd      	mov	sp, r7
10003484:	b004      	add	sp, #16
10003486:	bd80      	pop	{r7, pc}
10003488:	20002d7c 	.word	0x20002d7c
1000348c:	20002ca0 	.word	0x20002ca0
10003490:	20002d64 	.word	0x20002d64
10003494:	20002d34 	.word	0x20002d34
10003498:	20002d30 	.word	0x20002d30
1000349c:	20002d98 	.word	0x20002d98

100034a0 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
100034a0:	b580      	push	{r7, lr}
100034a2:	b084      	sub	sp, #16
100034a4:	af02      	add	r7, sp, #8
        BaseType_t xReturn = pdFAIL;
100034a6:	2300      	movs	r3, #0
100034a8:	607b      	str	r3, [r7, #4]

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
100034aa:	f000 fac9 	bl	10003a40 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
100034ae:	4b0e      	ldr	r3, [pc, #56]	; (100034e8 <xTimerCreateTimerTask+0x48>)
100034b0:	681b      	ldr	r3, [r3, #0]
100034b2:	2b00      	cmp	r3, #0
100034b4:	d00d      	beq.n	100034d2 <xTimerCreateTimerTask+0x32>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
100034b6:	490d      	ldr	r1, [pc, #52]	; (100034ec <xTimerCreateTimerTask+0x4c>)
100034b8:	4a0d      	ldr	r2, [pc, #52]	; (100034f0 <xTimerCreateTimerTask+0x50>)
100034ba:	2302      	movs	r3, #2
100034bc:	9300      	str	r3, [sp, #0]
100034be:	4b0d      	ldr	r3, [pc, #52]	; (100034f4 <xTimerCreateTimerTask+0x54>)
100034c0:	9301      	str	r3, [sp, #4]
100034c2:	1c08      	adds	r0, r1, #0
100034c4:	1c11      	adds	r1, r2, #0
100034c6:	2278      	movs	r2, #120	; 0x78
100034c8:	2300      	movs	r3, #0
100034ca:	f7ff f9fd 	bl	100028c8 <xTaskCreate>
100034ce:	1c03      	adds	r3, r0, #0
100034d0:	607b      	str	r3, [r7, #4]
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
100034d2:	687b      	ldr	r3, [r7, #4]
100034d4:	2b00      	cmp	r3, #0
100034d6:	d101      	bne.n	100034dc <xTimerCreateTimerTask+0x3c>
100034d8:	b672      	cpsid	i
100034da:	e7fe      	b.n	100034da <xTimerCreateTimerTask+0x3a>
        return xReturn;
100034dc:	687b      	ldr	r3, [r7, #4]
    }
100034de:	1c18      	adds	r0, r3, #0
100034e0:	46bd      	mov	sp, r7
100034e2:	b002      	add	sp, #8
100034e4:	bd80      	pop	{r7, pc}
100034e6:	46c0      	nop			; (mov r8, r8)
100034e8:	20002dd4 	.word	0x20002dd4
100034ec:	1000362d 	.word	0x1000362d
100034f0:	10003df0 	.word	0x10003df0
100034f4:	20002dd8 	.word	0x20002dd8

100034f8 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
100034f8:	b580      	push	{r7, lr}
100034fa:	b08a      	sub	sp, #40	; 0x28
100034fc:	af00      	add	r7, sp, #0
100034fe:	60f8      	str	r0, [r7, #12]
10003500:	60b9      	str	r1, [r7, #8]
10003502:	607a      	str	r2, [r7, #4]
10003504:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn = pdFAIL;
10003506:	2300      	movs	r3, #0
10003508:	627b      	str	r3, [r7, #36]	; 0x24
        DaemonTaskMessage_t xMessage;

        configASSERT( xTimer );
1000350a:	68fb      	ldr	r3, [r7, #12]
1000350c:	2b00      	cmp	r3, #0
1000350e:	d101      	bne.n	10003514 <xTimerGenericCommand+0x1c>
10003510:	b672      	cpsid	i
10003512:	e7fe      	b.n	10003512 <xTimerGenericCommand+0x1a>

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
10003514:	4b22      	ldr	r3, [pc, #136]	; (100035a0 <xTimerGenericCommand+0xa8>)
10003516:	681b      	ldr	r3, [r3, #0]
10003518:	2b00      	cmp	r3, #0
1000351a:	d03b      	beq.n	10003594 <xTimerGenericCommand+0x9c>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
1000351c:	2314      	movs	r3, #20
1000351e:	18fb      	adds	r3, r7, r3
10003520:	68ba      	ldr	r2, [r7, #8]
10003522:	601a      	str	r2, [r3, #0]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
10003524:	2314      	movs	r3, #20
10003526:	18fb      	adds	r3, r7, r3
10003528:	687a      	ldr	r2, [r7, #4]
1000352a:	605a      	str	r2, [r3, #4]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
1000352c:	2314      	movs	r3, #20
1000352e:	18fb      	adds	r3, r7, r3
10003530:	68fa      	ldr	r2, [r7, #12]
10003532:	609a      	str	r2, [r3, #8]

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
10003534:	68bb      	ldr	r3, [r7, #8]
10003536:	2b05      	cmp	r3, #5
10003538:	dc1f      	bgt.n	1000357a <xTimerGenericCommand+0x82>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
1000353a:	f7ff fee1 	bl	10003300 <xTaskGetSchedulerState>
1000353e:	1e03      	subs	r3, r0, #0
10003540:	2b02      	cmp	r3, #2
10003542:	d10d      	bne.n	10003560 <xTimerGenericCommand+0x68>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
10003544:	4b16      	ldr	r3, [pc, #88]	; (100035a0 <xTimerGenericCommand+0xa8>)
10003546:	6819      	ldr	r1, [r3, #0]
10003548:	2314      	movs	r3, #20
1000354a:	18fa      	adds	r2, r7, r3
1000354c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
1000354e:	1c08      	adds	r0, r1, #0
10003550:	1c11      	adds	r1, r2, #0
10003552:	1c1a      	adds	r2, r3, #0
10003554:	2300      	movs	r3, #0
10003556:	f7fe fd9b 	bl	10002090 <xQueueGenericSend>
1000355a:	1c03      	adds	r3, r0, #0
1000355c:	627b      	str	r3, [r7, #36]	; 0x24
1000355e:	e019      	b.n	10003594 <xTimerGenericCommand+0x9c>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
10003560:	4b0f      	ldr	r3, [pc, #60]	; (100035a0 <xTimerGenericCommand+0xa8>)
10003562:	681a      	ldr	r2, [r3, #0]
10003564:	2314      	movs	r3, #20
10003566:	18fb      	adds	r3, r7, r3
10003568:	1c10      	adds	r0, r2, #0
1000356a:	1c19      	adds	r1, r3, #0
1000356c:	2200      	movs	r2, #0
1000356e:	2300      	movs	r3, #0
10003570:	f7fe fd8e 	bl	10002090 <xQueueGenericSend>
10003574:	1c03      	adds	r3, r0, #0
10003576:	627b      	str	r3, [r7, #36]	; 0x24
10003578:	e00c      	b.n	10003594 <xTimerGenericCommand+0x9c>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
1000357a:	4b09      	ldr	r3, [pc, #36]	; (100035a0 <xTimerGenericCommand+0xa8>)
1000357c:	6819      	ldr	r1, [r3, #0]
1000357e:	2314      	movs	r3, #20
10003580:	18fa      	adds	r2, r7, r3
10003582:	683b      	ldr	r3, [r7, #0]
10003584:	1c08      	adds	r0, r1, #0
10003586:	1c11      	adds	r1, r2, #0
10003588:	1c1a      	adds	r2, r3, #0
1000358a:	2300      	movs	r3, #0
1000358c:	f7fe fe64 	bl	10002258 <xQueueGenericSendFromISR>
10003590:	1c03      	adds	r3, r0, #0
10003592:	627b      	str	r3, [r7, #36]	; 0x24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
10003594:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    }
10003596:	1c18      	adds	r0, r3, #0
10003598:	46bd      	mov	sp, r7
1000359a:	b00a      	add	sp, #40	; 0x28
1000359c:	bd80      	pop	{r7, pc}
1000359e:	46c0      	nop			; (mov r8, r8)
100035a0:	20002dd4 	.word	0x20002dd4

100035a4 <prvProcessExpiredTimer>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
100035a4:	b580      	push	{r7, lr}
100035a6:	b086      	sub	sp, #24
100035a8:	af02      	add	r7, sp, #8
100035aa:	6078      	str	r0, [r7, #4]
100035ac:	6039      	str	r1, [r7, #0]
        BaseType_t xResult;
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
100035ae:	4b1e      	ldr	r3, [pc, #120]	; (10003628 <prvProcessExpiredTimer+0x84>)
100035b0:	681b      	ldr	r3, [r3, #0]
100035b2:	68db      	ldr	r3, [r3, #12]
100035b4:	68db      	ldr	r3, [r3, #12]
100035b6:	60fb      	str	r3, [r7, #12]

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
100035b8:	68fb      	ldr	r3, [r7, #12]
100035ba:	3304      	adds	r3, #4
100035bc:	1c18      	adds	r0, r3, #0
100035be:	f7fe fc77 	bl	10001eb0 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
100035c2:	68fb      	ldr	r3, [r7, #12]
100035c4:	2228      	movs	r2, #40	; 0x28
100035c6:	5c9b      	ldrb	r3, [r3, r2]
100035c8:	1c1a      	adds	r2, r3, #0
100035ca:	2304      	movs	r3, #4
100035cc:	4013      	ands	r3, r2
100035ce:	d01a      	beq.n	10003606 <prvProcessExpiredTimer+0x62>
        {
            /* The timer is inserted into a list using a time relative to anything
             * other than the current time.  It will therefore be inserted into the
             * correct list relative to the time this task thinks it is now. */
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
100035d0:	68fb      	ldr	r3, [r7, #12]
100035d2:	699a      	ldr	r2, [r3, #24]
100035d4:	687b      	ldr	r3, [r7, #4]
100035d6:	18d1      	adds	r1, r2, r3
100035d8:	68f8      	ldr	r0, [r7, #12]
100035da:	683a      	ldr	r2, [r7, #0]
100035dc:	687b      	ldr	r3, [r7, #4]
100035de:	f000 f8c3 	bl	10003768 <prvInsertTimerInActiveList>
100035e2:	1e03      	subs	r3, r0, #0
100035e4:	d018      	beq.n	10003618 <prvProcessExpiredTimer+0x74>
            {
                /* The timer expired before it was added to the active timer
                 * list.  Reload it now.  */
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
100035e6:	68f9      	ldr	r1, [r7, #12]
100035e8:	687a      	ldr	r2, [r7, #4]
100035ea:	2300      	movs	r3, #0
100035ec:	9300      	str	r3, [sp, #0]
100035ee:	1c08      	adds	r0, r1, #0
100035f0:	2100      	movs	r1, #0
100035f2:	2300      	movs	r3, #0
100035f4:	f7ff ff80 	bl	100034f8 <xTimerGenericCommand>
100035f8:	1c03      	adds	r3, r0, #0
100035fa:	60bb      	str	r3, [r7, #8]
                configASSERT( xResult );
100035fc:	68bb      	ldr	r3, [r7, #8]
100035fe:	2b00      	cmp	r3, #0
10003600:	d10a      	bne.n	10003618 <prvProcessExpiredTimer+0x74>
10003602:	b672      	cpsid	i
10003604:	e7fe      	b.n	10003604 <prvProcessExpiredTimer+0x60>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10003606:	68fb      	ldr	r3, [r7, #12]
10003608:	2228      	movs	r2, #40	; 0x28
1000360a:	5c9b      	ldrb	r3, [r3, r2]
1000360c:	2201      	movs	r2, #1
1000360e:	4393      	bics	r3, r2
10003610:	b2d9      	uxtb	r1, r3
10003612:	68fb      	ldr	r3, [r7, #12]
10003614:	2228      	movs	r2, #40	; 0x28
10003616:	5499      	strb	r1, [r3, r2]
            mtCOVERAGE_TEST_MARKER();
        }

        /* Call the timer callback. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
10003618:	68fb      	ldr	r3, [r7, #12]
1000361a:	6a1b      	ldr	r3, [r3, #32]
1000361c:	68fa      	ldr	r2, [r7, #12]
1000361e:	1c10      	adds	r0, r2, #0
10003620:	4798      	blx	r3
    }
10003622:	46bd      	mov	sp, r7
10003624:	b004      	add	sp, #16
10003626:	bd80      	pop	{r7, pc}
10003628:	20002dcc 	.word	0x20002dcc

1000362c <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
1000362c:	b580      	push	{r7, lr}
1000362e:	b084      	sub	sp, #16
10003630:	af00      	add	r7, sp, #0
10003632:	6078      	str	r0, [r7, #4]

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
10003634:	2308      	movs	r3, #8
10003636:	18fb      	adds	r3, r7, r3
10003638:	1c18      	adds	r0, r3, #0
1000363a:	f000 f853 	bl	100036e4 <prvGetNextExpireTime>
1000363e:	1c03      	adds	r3, r0, #0
10003640:	60fb      	str	r3, [r7, #12]

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
10003642:	68bb      	ldr	r3, [r7, #8]
10003644:	68fa      	ldr	r2, [r7, #12]
10003646:	1c10      	adds	r0, r2, #0
10003648:	1c19      	adds	r1, r3, #0
1000364a:	f000 f803 	bl	10003654 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
1000364e:	f000 f8cd 	bl	100037ec <prvProcessReceivedCommands>
        }
10003652:	e7ef      	b.n	10003634 <prvTimerTask+0x8>

10003654 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
10003654:	b580      	push	{r7, lr}
10003656:	b084      	sub	sp, #16
10003658:	af00      	add	r7, sp, #0
1000365a:	6078      	str	r0, [r7, #4]
1000365c:	6039      	str	r1, [r7, #0]
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
1000365e:	f7ff fae3 	bl	10002c28 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
10003662:	2308      	movs	r3, #8
10003664:	18fb      	adds	r3, r7, r3
10003666:	1c18      	adds	r0, r3, #0
10003668:	f000 f85e 	bl	10003728 <prvSampleTimeNow>
1000366c:	1c03      	adds	r3, r0, #0
1000366e:	60fb      	str	r3, [r7, #12]

            if( xTimerListsWereSwitched == pdFALSE )
10003670:	68bb      	ldr	r3, [r7, #8]
10003672:	2b00      	cmp	r3, #0
10003674:	d12d      	bne.n	100036d2 <prvProcessTimerOrBlockTask+0x7e>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
10003676:	683b      	ldr	r3, [r7, #0]
10003678:	2b00      	cmp	r3, #0
1000367a:	d10c      	bne.n	10003696 <prvProcessTimerOrBlockTask+0x42>
1000367c:	687a      	ldr	r2, [r7, #4]
1000367e:	68fb      	ldr	r3, [r7, #12]
10003680:	429a      	cmp	r2, r3
10003682:	d808      	bhi.n	10003696 <prvProcessTimerOrBlockTask+0x42>
                {
                    ( void ) xTaskResumeAll();
10003684:	f7ff fadc 	bl	10002c40 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
10003688:	687a      	ldr	r2, [r7, #4]
1000368a:	68fb      	ldr	r3, [r7, #12]
1000368c:	1c10      	adds	r0, r2, #0
1000368e:	1c19      	adds	r1, r3, #0
10003690:	f7ff ff88 	bl	100035a4 <prvProcessExpiredTimer>
10003694:	e01f      	b.n	100036d6 <prvProcessTimerOrBlockTask+0x82>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
10003696:	683b      	ldr	r3, [r7, #0]
10003698:	2b00      	cmp	r3, #0
1000369a:	d008      	beq.n	100036ae <prvProcessTimerOrBlockTask+0x5a>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
1000369c:	4b0f      	ldr	r3, [pc, #60]	; (100036dc <prvProcessTimerOrBlockTask+0x88>)
1000369e:	681b      	ldr	r3, [r3, #0]
100036a0:	681b      	ldr	r3, [r3, #0]
100036a2:	2b00      	cmp	r3, #0
100036a4:	d101      	bne.n	100036aa <prvProcessTimerOrBlockTask+0x56>
100036a6:	2301      	movs	r3, #1
100036a8:	e000      	b.n	100036ac <prvProcessTimerOrBlockTask+0x58>
100036aa:	2300      	movs	r3, #0
100036ac:	603b      	str	r3, [r7, #0]
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
100036ae:	4b0c      	ldr	r3, [pc, #48]	; (100036e0 <prvProcessTimerOrBlockTask+0x8c>)
100036b0:	6819      	ldr	r1, [r3, #0]
100036b2:	687a      	ldr	r2, [r7, #4]
100036b4:	68fb      	ldr	r3, [r7, #12]
100036b6:	1ad2      	subs	r2, r2, r3
100036b8:	683b      	ldr	r3, [r7, #0]
100036ba:	1c08      	adds	r0, r1, #0
100036bc:	1c11      	adds	r1, r2, #0
100036be:	1c1a      	adds	r2, r3, #0
100036c0:	f7ff f874 	bl	100027ac <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
100036c4:	f7ff fabc 	bl	10002c40 <xTaskResumeAll>
100036c8:	1e03      	subs	r3, r0, #0
100036ca:	d104      	bne.n	100036d6 <prvProcessTimerOrBlockTask+0x82>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
100036cc:	f7fe f91c 	bl	10001908 <vPortYield>
100036d0:	e001      	b.n	100036d6 <prvProcessTimerOrBlockTask+0x82>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
100036d2:	f7ff fab5 	bl	10002c40 <xTaskResumeAll>
            }
        }
    }
100036d6:	46bd      	mov	sp, r7
100036d8:	b004      	add	sp, #16
100036da:	bd80      	pop	{r7, pc}
100036dc:	20002dd0 	.word	0x20002dd0
100036e0:	20002dd4 	.word	0x20002dd4

100036e4 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
100036e4:	b580      	push	{r7, lr}
100036e6:	b084      	sub	sp, #16
100036e8:	af00      	add	r7, sp, #0
100036ea:	6078      	str	r0, [r7, #4]
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
100036ec:	4b0d      	ldr	r3, [pc, #52]	; (10003724 <prvGetNextExpireTime+0x40>)
100036ee:	681b      	ldr	r3, [r3, #0]
100036f0:	681b      	ldr	r3, [r3, #0]
100036f2:	2b00      	cmp	r3, #0
100036f4:	d101      	bne.n	100036fa <prvGetNextExpireTime+0x16>
100036f6:	2201      	movs	r2, #1
100036f8:	e000      	b.n	100036fc <prvGetNextExpireTime+0x18>
100036fa:	2200      	movs	r2, #0
100036fc:	687b      	ldr	r3, [r7, #4]
100036fe:	601a      	str	r2, [r3, #0]

        if( *pxListWasEmpty == pdFALSE )
10003700:	687b      	ldr	r3, [r7, #4]
10003702:	681b      	ldr	r3, [r3, #0]
10003704:	2b00      	cmp	r3, #0
10003706:	d105      	bne.n	10003714 <prvGetNextExpireTime+0x30>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
10003708:	4b06      	ldr	r3, [pc, #24]	; (10003724 <prvGetNextExpireTime+0x40>)
1000370a:	681b      	ldr	r3, [r3, #0]
1000370c:	68db      	ldr	r3, [r3, #12]
1000370e:	681b      	ldr	r3, [r3, #0]
10003710:	60fb      	str	r3, [r7, #12]
10003712:	e001      	b.n	10003718 <prvGetNextExpireTime+0x34>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
10003714:	2300      	movs	r3, #0
10003716:	60fb      	str	r3, [r7, #12]
        }

        return xNextExpireTime;
10003718:	68fb      	ldr	r3, [r7, #12]
    }
1000371a:	1c18      	adds	r0, r3, #0
1000371c:	46bd      	mov	sp, r7
1000371e:	b004      	add	sp, #16
10003720:	bd80      	pop	{r7, pc}
10003722:	46c0      	nop			; (mov r8, r8)
10003724:	20002dcc 	.word	0x20002dcc

10003728 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
10003728:	b580      	push	{r7, lr}
1000372a:	b084      	sub	sp, #16
1000372c:	af00      	add	r7, sp, #0
1000372e:	6078      	str	r0, [r7, #4]
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
10003730:	f7ff fb12 	bl	10002d58 <xTaskGetTickCount>
10003734:	1c03      	adds	r3, r0, #0
10003736:	60fb      	str	r3, [r7, #12]

        if( xTimeNow < xLastTime )
10003738:	4b0a      	ldr	r3, [pc, #40]	; (10003764 <prvSampleTimeNow+0x3c>)
1000373a:	681b      	ldr	r3, [r3, #0]
1000373c:	68fa      	ldr	r2, [r7, #12]
1000373e:	429a      	cmp	r2, r3
10003740:	d205      	bcs.n	1000374e <prvSampleTimeNow+0x26>
        {
            prvSwitchTimerLists();
10003742:	f000 f91f 	bl	10003984 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
10003746:	687b      	ldr	r3, [r7, #4]
10003748:	2201      	movs	r2, #1
1000374a:	601a      	str	r2, [r3, #0]
1000374c:	e002      	b.n	10003754 <prvSampleTimeNow+0x2c>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
1000374e:	687b      	ldr	r3, [r7, #4]
10003750:	2200      	movs	r2, #0
10003752:	601a      	str	r2, [r3, #0]
        }

        xLastTime = xTimeNow;
10003754:	4b03      	ldr	r3, [pc, #12]	; (10003764 <prvSampleTimeNow+0x3c>)
10003756:	68fa      	ldr	r2, [r7, #12]
10003758:	601a      	str	r2, [r3, #0]

        return xTimeNow;
1000375a:	68fb      	ldr	r3, [r7, #12]
    }
1000375c:	1c18      	adds	r0, r3, #0
1000375e:	46bd      	mov	sp, r7
10003760:	b004      	add	sp, #16
10003762:	bd80      	pop	{r7, pc}
10003764:	20002ddc 	.word	0x20002ddc

10003768 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
10003768:	b580      	push	{r7, lr}
1000376a:	b086      	sub	sp, #24
1000376c:	af00      	add	r7, sp, #0
1000376e:	60f8      	str	r0, [r7, #12]
10003770:	60b9      	str	r1, [r7, #8]
10003772:	607a      	str	r2, [r7, #4]
10003774:	603b      	str	r3, [r7, #0]
        BaseType_t xProcessTimerNow = pdFALSE;
10003776:	2300      	movs	r3, #0
10003778:	617b      	str	r3, [r7, #20]

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
1000377a:	68fb      	ldr	r3, [r7, #12]
1000377c:	68ba      	ldr	r2, [r7, #8]
1000377e:	605a      	str	r2, [r3, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
10003780:	68fb      	ldr	r3, [r7, #12]
10003782:	68fa      	ldr	r2, [r7, #12]
10003784:	611a      	str	r2, [r3, #16]

        if( xNextExpiryTime <= xTimeNow )
10003786:	68ba      	ldr	r2, [r7, #8]
10003788:	687b      	ldr	r3, [r7, #4]
1000378a:	429a      	cmp	r2, r3
1000378c:	d812      	bhi.n	100037b4 <prvInsertTimerInActiveList+0x4c>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
1000378e:	687a      	ldr	r2, [r7, #4]
10003790:	683b      	ldr	r3, [r7, #0]
10003792:	1ad2      	subs	r2, r2, r3
10003794:	68fb      	ldr	r3, [r7, #12]
10003796:	699b      	ldr	r3, [r3, #24]
10003798:	429a      	cmp	r2, r3
1000379a:	d302      	bcc.n	100037a2 <prvInsertTimerInActiveList+0x3a>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
1000379c:	2301      	movs	r3, #1
1000379e:	617b      	str	r3, [r7, #20]
100037a0:	e01b      	b.n	100037da <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
100037a2:	4b10      	ldr	r3, [pc, #64]	; (100037e4 <prvInsertTimerInActiveList+0x7c>)
100037a4:	681a      	ldr	r2, [r3, #0]
100037a6:	68fb      	ldr	r3, [r7, #12]
100037a8:	3304      	adds	r3, #4
100037aa:	1c10      	adds	r0, r2, #0
100037ac:	1c19      	adds	r1, r3, #0
100037ae:	f7fe fb49 	bl	10001e44 <vListInsert>
100037b2:	e012      	b.n	100037da <prvInsertTimerInActiveList+0x72>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
100037b4:	687a      	ldr	r2, [r7, #4]
100037b6:	683b      	ldr	r3, [r7, #0]
100037b8:	429a      	cmp	r2, r3
100037ba:	d206      	bcs.n	100037ca <prvInsertTimerInActiveList+0x62>
100037bc:	68ba      	ldr	r2, [r7, #8]
100037be:	683b      	ldr	r3, [r7, #0]
100037c0:	429a      	cmp	r2, r3
100037c2:	d302      	bcc.n	100037ca <prvInsertTimerInActiveList+0x62>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
100037c4:	2301      	movs	r3, #1
100037c6:	617b      	str	r3, [r7, #20]
100037c8:	e007      	b.n	100037da <prvInsertTimerInActiveList+0x72>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
100037ca:	4b07      	ldr	r3, [pc, #28]	; (100037e8 <prvInsertTimerInActiveList+0x80>)
100037cc:	681a      	ldr	r2, [r3, #0]
100037ce:	68fb      	ldr	r3, [r7, #12]
100037d0:	3304      	adds	r3, #4
100037d2:	1c10      	adds	r0, r2, #0
100037d4:	1c19      	adds	r1, r3, #0
100037d6:	f7fe fb35 	bl	10001e44 <vListInsert>
            }
        }

        return xProcessTimerNow;
100037da:	697b      	ldr	r3, [r7, #20]
    }
100037dc:	1c18      	adds	r0, r3, #0
100037de:	46bd      	mov	sp, r7
100037e0:	b006      	add	sp, #24
100037e2:	bd80      	pop	{r7, pc}
100037e4:	20002dd0 	.word	0x20002dd0
100037e8:	20002dcc 	.word	0x20002dcc

100037ec <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
100037ec:	b580      	push	{r7, lr}
100037ee:	b08c      	sub	sp, #48	; 0x30
100037f0:	af02      	add	r7, sp, #8
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
100037f2:	e0b3      	b.n	1000395c <prvProcessReceivedCommands+0x170>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
                {
                    /* Negative commands are pended function calls rather than timer
                     * commands. */
                    if( xMessage.xMessageID < ( BaseType_t ) 0 )
100037f4:	2308      	movs	r3, #8
100037f6:	18fb      	adds	r3, r7, r3
100037f8:	681b      	ldr	r3, [r3, #0]
100037fa:	2b00      	cmp	r3, #0
100037fc:	da11      	bge.n	10003822 <prvProcessReceivedCommands+0x36>
                    {
                        const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
100037fe:	2308      	movs	r3, #8
10003800:	18fb      	adds	r3, r7, r3
10003802:	3304      	adds	r3, #4
10003804:	627b      	str	r3, [r7, #36]	; 0x24

                        /* The timer uses the xCallbackParameters member to request a
                         * callback be executed.  Check the callback is not NULL. */
                        configASSERT( pxCallback );
10003806:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003808:	2b00      	cmp	r3, #0
1000380a:	d101      	bne.n	10003810 <prvProcessReceivedCommands+0x24>
1000380c:	b672      	cpsid	i
1000380e:	e7fe      	b.n	1000380e <prvProcessReceivedCommands+0x22>

                        /* Call the function. */
                        pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
10003810:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003812:	681a      	ldr	r2, [r3, #0]
10003814:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10003816:	6859      	ldr	r1, [r3, #4]
10003818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
1000381a:	689b      	ldr	r3, [r3, #8]
1000381c:	1c08      	adds	r0, r1, #0
1000381e:	1c19      	adds	r1, r3, #0
10003820:	4790      	blx	r2
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
10003822:	2308      	movs	r3, #8
10003824:	18fb      	adds	r3, r7, r3
10003826:	681b      	ldr	r3, [r3, #0]
10003828:	2b00      	cmp	r3, #0
1000382a:	da00      	bge.n	1000382e <prvProcessReceivedCommands+0x42>
1000382c:	e096      	b.n	1000395c <prvProcessReceivedCommands+0x170>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
1000382e:	2308      	movs	r3, #8
10003830:	18fb      	adds	r3, r7, r3
10003832:	689b      	ldr	r3, [r3, #8]
10003834:	623b      	str	r3, [r7, #32]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
10003836:	6a3b      	ldr	r3, [r7, #32]
10003838:	695b      	ldr	r3, [r3, #20]
1000383a:	2b00      	cmp	r3, #0
1000383c:	d004      	beq.n	10003848 <prvProcessReceivedCommands+0x5c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
1000383e:	6a3b      	ldr	r3, [r7, #32]
10003840:	3304      	adds	r3, #4
10003842:	1c18      	adds	r0, r3, #0
10003844:	f7fe fb34 	bl	10001eb0 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
10003848:	1d3b      	adds	r3, r7, #4
1000384a:	1c18      	adds	r0, r3, #0
1000384c:	f7ff ff6c 	bl	10003728 <prvSampleTimeNow>
10003850:	1c03      	adds	r3, r0, #0
10003852:	61fb      	str	r3, [r7, #28]

                switch( xMessage.xMessageID )
10003854:	2308      	movs	r3, #8
10003856:	18fb      	adds	r3, r7, r3
10003858:	681b      	ldr	r3, [r3, #0]
1000385a:	2b09      	cmp	r3, #9
1000385c:	d900      	bls.n	10003860 <prvProcessReceivedCommands+0x74>
1000385e:	e07c      	b.n	1000395a <prvProcessReceivedCommands+0x16e>
10003860:	009a      	lsls	r2, r3, #2
10003862:	4b46      	ldr	r3, [pc, #280]	; (1000397c <prvProcessReceivedCommands+0x190>)
10003864:	18d3      	adds	r3, r2, r3
10003866:	681b      	ldr	r3, [r3, #0]
10003868:	469f      	mov	pc, r3
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                    case tmrCOMMAND_START_DONT_TRACE:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
1000386a:	6a3b      	ldr	r3, [r7, #32]
1000386c:	2228      	movs	r2, #40	; 0x28
1000386e:	5c9b      	ldrb	r3, [r3, r2]
10003870:	2201      	movs	r2, #1
10003872:	4313      	orrs	r3, r2
10003874:	b2d9      	uxtb	r1, r3
10003876:	6a3b      	ldr	r3, [r7, #32]
10003878:	2228      	movs	r2, #40	; 0x28
1000387a:	5499      	strb	r1, [r3, r2]

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
1000387c:	2308      	movs	r3, #8
1000387e:	18fb      	adds	r3, r7, r3
10003880:	685a      	ldr	r2, [r3, #4]
10003882:	6a3b      	ldr	r3, [r7, #32]
10003884:	699b      	ldr	r3, [r3, #24]
10003886:	18d1      	adds	r1, r2, r3
10003888:	2308      	movs	r3, #8
1000388a:	18fb      	adds	r3, r7, r3
1000388c:	685b      	ldr	r3, [r3, #4]
1000388e:	6a38      	ldr	r0, [r7, #32]
10003890:	69fa      	ldr	r2, [r7, #28]
10003892:	f7ff ff69 	bl	10003768 <prvInsertTimerInActiveList>
10003896:	1e03      	subs	r3, r0, #0
10003898:	d020      	beq.n	100038dc <prvProcessReceivedCommands+0xf0>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
1000389a:	6a3b      	ldr	r3, [r7, #32]
1000389c:	6a1b      	ldr	r3, [r3, #32]
1000389e:	6a3a      	ldr	r2, [r7, #32]
100038a0:	1c10      	adds	r0, r2, #0
100038a2:	4798      	blx	r3
                            traceTIMER_EXPIRED( pxTimer );

                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
100038a4:	6a3b      	ldr	r3, [r7, #32]
100038a6:	2228      	movs	r2, #40	; 0x28
100038a8:	5c9b      	ldrb	r3, [r3, r2]
100038aa:	1c1a      	adds	r2, r3, #0
100038ac:	2304      	movs	r3, #4
100038ae:	4013      	ands	r3, r2
100038b0:	d014      	beq.n	100038dc <prvProcessReceivedCommands+0xf0>
                            {
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
100038b2:	2308      	movs	r3, #8
100038b4:	18fb      	adds	r3, r7, r3
100038b6:	685a      	ldr	r2, [r3, #4]
100038b8:	6a3b      	ldr	r3, [r7, #32]
100038ba:	699b      	ldr	r3, [r3, #24]
100038bc:	18d2      	adds	r2, r2, r3
100038be:	6a39      	ldr	r1, [r7, #32]
100038c0:	2300      	movs	r3, #0
100038c2:	9300      	str	r3, [sp, #0]
100038c4:	1c08      	adds	r0, r1, #0
100038c6:	2100      	movs	r1, #0
100038c8:	2300      	movs	r3, #0
100038ca:	f7ff fe15 	bl	100034f8 <xTimerGenericCommand>
100038ce:	1c03      	adds	r3, r0, #0
100038d0:	61bb      	str	r3, [r7, #24]
                                configASSERT( xResult );
100038d2:	69bb      	ldr	r3, [r7, #24]
100038d4:	2b00      	cmp	r3, #0
100038d6:	d101      	bne.n	100038dc <prvProcessReceivedCommands+0xf0>
100038d8:	b672      	cpsid	i
100038da:	e7fe      	b.n	100038da <prvProcessReceivedCommands+0xee>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        break;
100038dc:	e03e      	b.n	1000395c <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
100038de:	6a3b      	ldr	r3, [r7, #32]
100038e0:	2228      	movs	r2, #40	; 0x28
100038e2:	5c9b      	ldrb	r3, [r3, r2]
100038e4:	2201      	movs	r2, #1
100038e6:	4393      	bics	r3, r2
100038e8:	b2d9      	uxtb	r1, r3
100038ea:	6a3b      	ldr	r3, [r7, #32]
100038ec:	2228      	movs	r2, #40	; 0x28
100038ee:	5499      	strb	r1, [r3, r2]
                        break;
100038f0:	e034      	b.n	1000395c <prvProcessReceivedCommands+0x170>

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
100038f2:	6a3b      	ldr	r3, [r7, #32]
100038f4:	2228      	movs	r2, #40	; 0x28
100038f6:	5c9b      	ldrb	r3, [r3, r2]
100038f8:	2201      	movs	r2, #1
100038fa:	4313      	orrs	r3, r2
100038fc:	b2d9      	uxtb	r1, r3
100038fe:	6a3b      	ldr	r3, [r7, #32]
10003900:	2228      	movs	r2, #40	; 0x28
10003902:	5499      	strb	r1, [r3, r2]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
10003904:	2308      	movs	r3, #8
10003906:	18fb      	adds	r3, r7, r3
10003908:	685a      	ldr	r2, [r3, #4]
1000390a:	6a3b      	ldr	r3, [r7, #32]
1000390c:	619a      	str	r2, [r3, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
1000390e:	6a3b      	ldr	r3, [r7, #32]
10003910:	699b      	ldr	r3, [r3, #24]
10003912:	2b00      	cmp	r3, #0
10003914:	d101      	bne.n	1000391a <prvProcessReceivedCommands+0x12e>
10003916:	b672      	cpsid	i
10003918:	e7fe      	b.n	10003918 <prvProcessReceivedCommands+0x12c>
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
1000391a:	6a3b      	ldr	r3, [r7, #32]
1000391c:	699a      	ldr	r2, [r3, #24]
1000391e:	69fb      	ldr	r3, [r7, #28]
10003920:	18d1      	adds	r1, r2, r3
10003922:	6a38      	ldr	r0, [r7, #32]
10003924:	69fa      	ldr	r2, [r7, #28]
10003926:	69fb      	ldr	r3, [r7, #28]
10003928:	f7ff ff1e 	bl	10003768 <prvInsertTimerInActiveList>
                        break;
1000392c:	e016      	b.n	1000395c <prvProcessReceivedCommands+0x170>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
1000392e:	6a3b      	ldr	r3, [r7, #32]
10003930:	2228      	movs	r2, #40	; 0x28
10003932:	5c9b      	ldrb	r3, [r3, r2]
10003934:	1c1a      	adds	r2, r3, #0
10003936:	2302      	movs	r3, #2
10003938:	4013      	ands	r3, r2
1000393a:	d104      	bne.n	10003946 <prvProcessReceivedCommands+0x15a>
                                {
                                    vPortFree( pxTimer );
1000393c:	6a3b      	ldr	r3, [r7, #32]
1000393e:	1c18      	adds	r0, r3, #0
10003940:	f7fe f932 	bl	10001ba8 <vPortFree>
10003944:	e008      	b.n	10003958 <prvProcessReceivedCommands+0x16c>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
10003946:	6a3b      	ldr	r3, [r7, #32]
10003948:	2228      	movs	r2, #40	; 0x28
1000394a:	5c9b      	ldrb	r3, [r3, r2]
1000394c:	2201      	movs	r2, #1
1000394e:	4393      	bics	r3, r2
10003950:	b2d9      	uxtb	r1, r3
10003952:	6a3b      	ldr	r3, [r7, #32]
10003954:	2228      	movs	r2, #40	; 0x28
10003956:	5499      	strb	r1, [r3, r2]
                                 * no need to free the memory - just mark the timer as
                                 * "not active". */
                                pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                            }
                        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
                        break;
10003958:	e000      	b.n	1000395c <prvProcessReceivedCommands+0x170>

                    default:
                        /* Don't expect to get here. */
                        break;
1000395a:	46c0      	nop			; (mov r8, r8)
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched, xResult;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
1000395c:	4b08      	ldr	r3, [pc, #32]	; (10003980 <prvProcessReceivedCommands+0x194>)
1000395e:	681a      	ldr	r2, [r3, #0]
10003960:	2308      	movs	r3, #8
10003962:	18fb      	adds	r3, r7, r3
10003964:	1c10      	adds	r0, r2, #0
10003966:	1c19      	adds	r1, r3, #0
10003968:	2200      	movs	r2, #0
1000396a:	f7fe fd0d 	bl	10002388 <xQueueReceive>
1000396e:	1e03      	subs	r3, r0, #0
10003970:	d000      	beq.n	10003974 <prvProcessReceivedCommands+0x188>
10003972:	e73f      	b.n	100037f4 <prvProcessReceivedCommands+0x8>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
10003974:	46bd      	mov	sp, r7
10003976:	b00a      	add	sp, #40	; 0x28
10003978:	bd80      	pop	{r7, pc}
1000397a:	46c0      	nop			; (mov r8, r8)
1000397c:	10003e00 	.word	0x10003e00
10003980:	20002dd4 	.word	0x20002dd4

10003984 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
10003984:	b580      	push	{r7, lr}
10003986:	b088      	sub	sp, #32
10003988:	af02      	add	r7, sp, #8

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
1000398a:	e042      	b.n	10003a12 <prvSwitchTimerLists+0x8e>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
1000398c:	4b2a      	ldr	r3, [pc, #168]	; (10003a38 <prvSwitchTimerLists+0xb4>)
1000398e:	681b      	ldr	r3, [r3, #0]
10003990:	68db      	ldr	r3, [r3, #12]
10003992:	681b      	ldr	r3, [r3, #0]
10003994:	617b      	str	r3, [r7, #20]

            /* Remove the timer from the list. */
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
10003996:	4b28      	ldr	r3, [pc, #160]	; (10003a38 <prvSwitchTimerLists+0xb4>)
10003998:	681b      	ldr	r3, [r3, #0]
1000399a:	68db      	ldr	r3, [r3, #12]
1000399c:	68db      	ldr	r3, [r3, #12]
1000399e:	613b      	str	r3, [r7, #16]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
100039a0:	693b      	ldr	r3, [r7, #16]
100039a2:	3304      	adds	r3, #4
100039a4:	1c18      	adds	r0, r3, #0
100039a6:	f7fe fa83 	bl	10001eb0 <uxListRemove>
            traceTIMER_EXPIRED( pxTimer );

            /* Execute its callback, then send a command to restart the timer if
             * it is an auto-reload timer.  It cannot be restarted here as the lists
             * have not yet been switched. */
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
100039aa:	693b      	ldr	r3, [r7, #16]
100039ac:	6a1b      	ldr	r3, [r3, #32]
100039ae:	693a      	ldr	r2, [r7, #16]
100039b0:	1c10      	adds	r0, r2, #0
100039b2:	4798      	blx	r3

            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
100039b4:	693b      	ldr	r3, [r7, #16]
100039b6:	2228      	movs	r2, #40	; 0x28
100039b8:	5c9b      	ldrb	r3, [r3, r2]
100039ba:	1c1a      	adds	r2, r3, #0
100039bc:	2304      	movs	r3, #4
100039be:	4013      	ands	r3, r2
100039c0:	d027      	beq.n	10003a12 <prvSwitchTimerLists+0x8e>
                 * the timer going into the same timer list then it has already expired
                 * and the timer should be re-inserted into the current list so it is
                 * processed again within this loop.  Otherwise a command should be sent
                 * to restart the timer to ensure it is only inserted into a list after
                 * the lists have been swapped. */
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
100039c2:	693b      	ldr	r3, [r7, #16]
100039c4:	699a      	ldr	r2, [r3, #24]
100039c6:	697b      	ldr	r3, [r7, #20]
100039c8:	18d3      	adds	r3, r2, r3
100039ca:	60fb      	str	r3, [r7, #12]

                if( xReloadTime > xNextExpireTime )
100039cc:	68fa      	ldr	r2, [r7, #12]
100039ce:	697b      	ldr	r3, [r7, #20]
100039d0:	429a      	cmp	r2, r3
100039d2:	d90e      	bls.n	100039f2 <prvSwitchTimerLists+0x6e>
                {
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
100039d4:	693b      	ldr	r3, [r7, #16]
100039d6:	68fa      	ldr	r2, [r7, #12]
100039d8:	605a      	str	r2, [r3, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
100039da:	693b      	ldr	r3, [r7, #16]
100039dc:	693a      	ldr	r2, [r7, #16]
100039de:	611a      	str	r2, [r3, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
100039e0:	4b15      	ldr	r3, [pc, #84]	; (10003a38 <prvSwitchTimerLists+0xb4>)
100039e2:	681a      	ldr	r2, [r3, #0]
100039e4:	693b      	ldr	r3, [r7, #16]
100039e6:	3304      	adds	r3, #4
100039e8:	1c10      	adds	r0, r2, #0
100039ea:	1c19      	adds	r1, r3, #0
100039ec:	f7fe fa2a 	bl	10001e44 <vListInsert>
100039f0:	e00f      	b.n	10003a12 <prvSwitchTimerLists+0x8e>
                }
                else
                {
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
100039f2:	6939      	ldr	r1, [r7, #16]
100039f4:	697a      	ldr	r2, [r7, #20]
100039f6:	2300      	movs	r3, #0
100039f8:	9300      	str	r3, [sp, #0]
100039fa:	1c08      	adds	r0, r1, #0
100039fc:	2100      	movs	r1, #0
100039fe:	2300      	movs	r3, #0
10003a00:	f7ff fd7a 	bl	100034f8 <xTimerGenericCommand>
10003a04:	1c03      	adds	r3, r0, #0
10003a06:	60bb      	str	r3, [r7, #8]
                    configASSERT( xResult );
10003a08:	68bb      	ldr	r3, [r7, #8]
10003a0a:	2b00      	cmp	r3, #0
10003a0c:	d101      	bne.n	10003a12 <prvSwitchTimerLists+0x8e>
10003a0e:	b672      	cpsid	i
10003a10:	e7fe      	b.n	10003a10 <prvSwitchTimerLists+0x8c>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
10003a12:	4b09      	ldr	r3, [pc, #36]	; (10003a38 <prvSwitchTimerLists+0xb4>)
10003a14:	681b      	ldr	r3, [r3, #0]
10003a16:	681b      	ldr	r3, [r3, #0]
10003a18:	2b00      	cmp	r3, #0
10003a1a:	d1b7      	bne.n	1000398c <prvSwitchTimerLists+0x8>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        pxTemp = pxCurrentTimerList;
10003a1c:	4b06      	ldr	r3, [pc, #24]	; (10003a38 <prvSwitchTimerLists+0xb4>)
10003a1e:	681b      	ldr	r3, [r3, #0]
10003a20:	607b      	str	r3, [r7, #4]
        pxCurrentTimerList = pxOverflowTimerList;
10003a22:	4b06      	ldr	r3, [pc, #24]	; (10003a3c <prvSwitchTimerLists+0xb8>)
10003a24:	681a      	ldr	r2, [r3, #0]
10003a26:	4b04      	ldr	r3, [pc, #16]	; (10003a38 <prvSwitchTimerLists+0xb4>)
10003a28:	601a      	str	r2, [r3, #0]
        pxOverflowTimerList = pxTemp;
10003a2a:	4b04      	ldr	r3, [pc, #16]	; (10003a3c <prvSwitchTimerLists+0xb8>)
10003a2c:	687a      	ldr	r2, [r7, #4]
10003a2e:	601a      	str	r2, [r3, #0]
    }
10003a30:	46bd      	mov	sp, r7
10003a32:	b006      	add	sp, #24
10003a34:	bd80      	pop	{r7, pc}
10003a36:	46c0      	nop			; (mov r8, r8)
10003a38:	20002dcc 	.word	0x20002dcc
10003a3c:	20002dd0 	.word	0x20002dd0

10003a40 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
10003a40:	b580      	push	{r7, lr}
10003a42:	af00      	add	r7, sp, #0
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
10003a44:	f7fd ff6e 	bl	10001924 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
10003a48:	4b14      	ldr	r3, [pc, #80]	; (10003a9c <prvCheckForValidListAndQueue+0x5c>)
10003a4a:	681b      	ldr	r3, [r3, #0]
10003a4c:	2b00      	cmp	r3, #0
10003a4e:	d120      	bne.n	10003a92 <prvCheckForValidListAndQueue+0x52>
            {
                vListInitialise( &xActiveTimerList1 );
10003a50:	4b13      	ldr	r3, [pc, #76]	; (10003aa0 <prvCheckForValidListAndQueue+0x60>)
10003a52:	1c18      	adds	r0, r3, #0
10003a54:	f7fe f9ac 	bl	10001db0 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
10003a58:	4b12      	ldr	r3, [pc, #72]	; (10003aa4 <prvCheckForValidListAndQueue+0x64>)
10003a5a:	1c18      	adds	r0, r3, #0
10003a5c:	f7fe f9a8 	bl	10001db0 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
10003a60:	4b11      	ldr	r3, [pc, #68]	; (10003aa8 <prvCheckForValidListAndQueue+0x68>)
10003a62:	4a0f      	ldr	r2, [pc, #60]	; (10003aa0 <prvCheckForValidListAndQueue+0x60>)
10003a64:	601a      	str	r2, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
10003a66:	4b11      	ldr	r3, [pc, #68]	; (10003aac <prvCheckForValidListAndQueue+0x6c>)
10003a68:	4a0e      	ldr	r2, [pc, #56]	; (10003aa4 <prvCheckForValidListAndQueue+0x64>)
10003a6a:	601a      	str	r2, [r3, #0]

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
10003a6c:	2005      	movs	r0, #5
10003a6e:	2110      	movs	r1, #16
10003a70:	2200      	movs	r2, #0
10003a72:	f7fe fa99 	bl	10001fa8 <xQueueGenericCreate>
10003a76:	1c02      	adds	r2, r0, #0
10003a78:	4b08      	ldr	r3, [pc, #32]	; (10003a9c <prvCheckForValidListAndQueue+0x5c>)
10003a7a:	601a      	str	r2, [r3, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
10003a7c:	4b07      	ldr	r3, [pc, #28]	; (10003a9c <prvCheckForValidListAndQueue+0x5c>)
10003a7e:	681b      	ldr	r3, [r3, #0]
10003a80:	2b00      	cmp	r3, #0
10003a82:	d006      	beq.n	10003a92 <prvCheckForValidListAndQueue+0x52>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
10003a84:	4b05      	ldr	r3, [pc, #20]	; (10003a9c <prvCheckForValidListAndQueue+0x5c>)
10003a86:	681a      	ldr	r2, [r3, #0]
10003a88:	4b09      	ldr	r3, [pc, #36]	; (10003ab0 <prvCheckForValidListAndQueue+0x70>)
10003a8a:	1c10      	adds	r0, r2, #0
10003a8c:	1c19      	adds	r1, r3, #0
10003a8e:	f7fe fe67 	bl	10002760 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
10003a92:	f7fd ff57 	bl	10001944 <vPortExitCritical>
    }
10003a96:	46bd      	mov	sp, r7
10003a98:	bd80      	pop	{r7, pc}
10003a9a:	46c0      	nop			; (mov r8, r8)
10003a9c:	20002dd4 	.word	0x20002dd4
10003aa0:	20002da4 	.word	0x20002da4
10003aa4:	20002db8 	.word	0x20002db8
10003aa8:	20002dcc 	.word	0x20002dcc
10003aac:	20002dd0 	.word	0x20002dd0
10003ab0:	10003df8 	.word	0x10003df8

10003ab4 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
10003ab4:	b580      	push	{r7, lr}
10003ab6:	b082      	sub	sp, #8
10003ab8:	af00      	add	r7, sp, #0
10003aba:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
10003abc:	687b      	ldr	r3, [r7, #4]
10003abe:	6819      	ldr	r1, [r3, #0]
10003ac0:	687b      	ldr	r3, [r7, #4]
10003ac2:	7b1a      	ldrb	r2, [r3, #12]
10003ac4:	687b      	ldr	r3, [r7, #4]
10003ac6:	3304      	adds	r3, #4
10003ac8:	1c08      	adds	r0, r1, #0
10003aca:	1c11      	adds	r1, r2, #0
10003acc:	1c1a      	adds	r2, r3, #0
10003ace:	f7fd fb5b 	bl	10001188 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
10003ad2:	687b      	ldr	r3, [r7, #4]
10003ad4:	6819      	ldr	r1, [r3, #0]
10003ad6:	687b      	ldr	r3, [r7, #4]
10003ad8:	7b1a      	ldrb	r2, [r3, #12]
10003ada:	687b      	ldr	r3, [r7, #4]
10003adc:	7b5b      	ldrb	r3, [r3, #13]
10003ade:	1c08      	adds	r0, r1, #0
10003ae0:	1c11      	adds	r1, r2, #0
10003ae2:	1c1a      	adds	r2, r3, #0
10003ae4:	f7fd fe04 	bl	100016f0 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
10003ae8:	2300      	movs	r3, #0
}
10003aea:	1c18      	adds	r0, r3, #0
10003aec:	46bd      	mov	sp, r7
10003aee:	b002      	add	sp, #8
10003af0:	bd80      	pop	{r7, pc}
10003af2:	46c0      	nop			; (mov r8, r8)

10003af4 <SystemCoreSetup>:
{
  .initialized = false
};
 
void SystemCoreSetup(void)
{
10003af4:	b580      	push	{r7, lr}
10003af6:	af00      	add	r7, sp, #0
#if UC_SERIES == XMC14
  /* Enable Prefetch unit */
  SCU_GENERAL->PFUCR &= ~SCU_GENERAL_PFUCR_PFUBYP_Msk;
10003af8:	4b03      	ldr	r3, [pc, #12]	; (10003b08 <SystemCoreSetup+0x14>)
10003afa:	4a03      	ldr	r2, [pc, #12]	; (10003b08 <SystemCoreSetup+0x14>)
10003afc:	6e92      	ldr	r2, [r2, #104]	; 0x68
10003afe:	2101      	movs	r1, #1
10003b00:	438a      	bics	r2, r1
10003b02:	669a      	str	r2, [r3, #104]	; 0x68
#endif
}
10003b04:	46bd      	mov	sp, r7
10003b06:	bd80      	pop	{r7, pc}
10003b08:	40010000 	.word	0x40010000

10003b0c <CLOCK_XMC1_Init>:

/*
 * API to initialize the CLOCK_XMC1 APP Interrupts
 */
CLOCK_XMC1_STATUS_t CLOCK_XMC1_Init(CLOCK_XMC1_t *handle)
{
10003b0c:	b580      	push	{r7, lr}
10003b0e:	b084      	sub	sp, #16
10003b10:	af00      	add	r7, sp, #0
10003b12:	6078      	str	r0, [r7, #4]
  CLOCK_XMC1_STATUS_t status = CLOCK_XMC1_STATUS_SUCCESS;
10003b14:	230f      	movs	r3, #15
10003b16:	18fb      	adds	r3, r7, r3
10003b18:	2200      	movs	r2, #0
10003b1a:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loci_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10003b1c:	230e      	movs	r3, #14
10003b1e:	18fb      	adds	r3, r7, r3
10003b20:	2200      	movs	r2, #0
10003b22:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t stdbyclkfail_status = CLOCK_XMC1_STATUS_SUCCESS;
10003b24:	230d      	movs	r3, #13
10003b26:	18fb      	adds	r3, r7, r3
10003b28:	2200      	movs	r2, #0
10003b2a:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loss_ext_clock_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10003b2c:	230c      	movs	r3, #12
10003b2e:	18fb      	adds	r3, r7, r3
10003b30:	2200      	movs	r2, #0
10003b32:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t dco1_out_sync_status = CLOCK_XMC1_STATUS_SUCCESS;
10003b34:	230b      	movs	r3, #11
10003b36:	18fb      	adds	r3, r7, r3
10003b38:	2200      	movs	r2, #0
10003b3a:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("CLOCK_XMC1_Init: CLOCK_XMC1 APP handle pointer uninitialized", (handle != NULL));

  if (handle->init_status == false)
10003b3c:	687b      	ldr	r3, [r7, #4]
10003b3e:	781b      	ldrb	r3, [r3, #0]
10003b40:	2201      	movs	r2, #1
10003b42:	4053      	eors	r3, r2
10003b44:	b2db      	uxtb	r3, r3
10003b46:	2b00      	cmp	r3, #0
10003b48:	d01b      	beq.n	10003b82 <CLOCK_XMC1_Init+0x76>

#endif
    }

#endif
    status = (CLOCK_XMC1_STATUS_t)(((uint32_t)loci_event_status) | ((uint32_t)stdbyclkfail_status) |
10003b4a:	230e      	movs	r3, #14
10003b4c:	18fa      	adds	r2, r7, r3
10003b4e:	230d      	movs	r3, #13
10003b50:	18fb      	adds	r3, r7, r3
10003b52:	7812      	ldrb	r2, [r2, #0]
10003b54:	781b      	ldrb	r3, [r3, #0]
10003b56:	4313      	orrs	r3, r2
10003b58:	b2da      	uxtb	r2, r3
10003b5a:	230c      	movs	r3, #12
10003b5c:	18fb      	adds	r3, r7, r3
10003b5e:	781b      	ldrb	r3, [r3, #0]
10003b60:	4313      	orrs	r3, r2
10003b62:	b2d9      	uxtb	r1, r3
10003b64:	230f      	movs	r3, #15
10003b66:	18fb      	adds	r3, r7, r3
10003b68:	220b      	movs	r2, #11
10003b6a:	18ba      	adds	r2, r7, r2
10003b6c:	7812      	ldrb	r2, [r2, #0]
10003b6e:	430a      	orrs	r2, r1
10003b70:	701a      	strb	r2, [r3, #0]
    		                       ((uint32_t)loss_ext_clock_event_status) | ((uint32_t)dco1_out_sync_status));
    if (CLOCK_XMC1_STATUS_SUCCESS == status)
10003b72:	230f      	movs	r3, #15
10003b74:	18fb      	adds	r3, r7, r3
10003b76:	781b      	ldrb	r3, [r3, #0]
10003b78:	2b00      	cmp	r3, #0
10003b7a:	d102      	bne.n	10003b82 <CLOCK_XMC1_Init+0x76>
    {
      handle->init_status = true;
10003b7c:	687b      	ldr	r3, [r7, #4]
10003b7e:	2201      	movs	r2, #1
10003b80:	701a      	strb	r2, [r3, #0]
    }
  }
  return (status);
10003b82:	230f      	movs	r3, #15
10003b84:	18fb      	adds	r3, r7, r3
10003b86:	781b      	ldrb	r3, [r3, #0]
}
10003b88:	1c18      	adds	r0, r3, #0
10003b8a:	46bd      	mov	sp, r7
10003b8c:	b004      	add	sp, #16
10003b8e:	bd80      	pop	{r7, pc}

10003b90 <SystemCoreClockSetup>:

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void SystemCoreClockSetup(void)
{
10003b90:	b590      	push	{r4, r7, lr}
10003b92:	b085      	sub	sp, #20
10003b94:	af00      	add	r7, sp, #0
/* LOCAL DATA STRUCTURES */
const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC1_0_CONFIG =
10003b96:	1c3b      	adds	r3, r7, #0
10003b98:	4a05      	ldr	r2, [pc, #20]	; (10003bb0 <SystemCoreClockSetup+0x20>)
10003b9a:	ca13      	ldmia	r2!, {r0, r1, r4}
10003b9c:	c313      	stmia	r3!, {r0, r1, r4}
10003b9e:	6812      	ldr	r2, [r2, #0]
10003ba0:	601a      	str	r2, [r3, #0]
  .osclp_mode = XMC_SCU_CLOCK_OSCLP_MODE_DISABLED

};

  /* Configure FDIV, IDIV, PCLKSEL dividers*/
  XMC_SCU_CLOCK_Init(&CLOCK_XMC1_0_CONFIG);
10003ba2:	1c3b      	adds	r3, r7, #0
10003ba4:	1c18      	adds	r0, r3, #0
10003ba6:	f7fd fbc7 	bl	10001338 <XMC_SCU_CLOCK_Init>
}
10003baa:	46bd      	mov	sp, r7
10003bac:	b005      	add	sp, #20
10003bae:	bd90      	pop	{r4, r7, pc}
10003bb0:	10003e58 	.word	0x10003e58

10003bb4 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
10003bb4:	b590      	push	{r4, r7, lr}
10003bb6:	b083      	sub	sp, #12
10003bb8:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
10003bba:	1dfb      	adds	r3, r7, #7
10003bbc:	2200      	movs	r2, #0
10003bbe:	701a      	strb	r2, [r3, #0]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC1_Init(&CLOCK_XMC1_0);
10003bc0:	1dfc      	adds	r4, r7, #7
10003bc2:	4b1c      	ldr	r3, [pc, #112]	; (10003c34 <DAVE_Init+0x80>)
10003bc4:	1c18      	adds	r0, r3, #0
10003bc6:	f7ff ffa1 	bl	10003b0c <CLOCK_XMC1_Init>
10003bca:	1c03      	adds	r3, r0, #0
10003bcc:	7023      	strb	r3, [r4, #0]

  if (init_status == DAVE_STATUS_SUCCESS)
10003bce:	1dfb      	adds	r3, r7, #7
10003bd0:	781b      	ldrb	r3, [r3, #0]
10003bd2:	2b00      	cmp	r3, #0
10003bd4:	d106      	bne.n	10003be4 <DAVE_Init+0x30>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_0 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_0); 
10003bd6:	1dfc      	adds	r4, r7, #7
10003bd8:	4b17      	ldr	r3, [pc, #92]	; (10003c38 <DAVE_Init+0x84>)
10003bda:	1c18      	adds	r0, r3, #0
10003bdc:	f7ff ff6a 	bl	10003ab4 <DIGITAL_IO_Init>
10003be0:	1c03      	adds	r3, r0, #0
10003be2:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10003be4:	1dfb      	adds	r3, r7, #7
10003be6:	781b      	ldrb	r3, [r3, #0]
10003be8:	2b00      	cmp	r3, #0
10003bea:	d106      	bne.n	10003bfa <DAVE_Init+0x46>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_1); 
10003bec:	1dfc      	adds	r4, r7, #7
10003bee:	4b13      	ldr	r3, [pc, #76]	; (10003c3c <DAVE_Init+0x88>)
10003bf0:	1c18      	adds	r0, r3, #0
10003bf2:	f7ff ff5f 	bl	10003ab4 <DIGITAL_IO_Init>
10003bf6:	1c03      	adds	r3, r0, #0
10003bf8:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10003bfa:	1dfb      	adds	r3, r7, #7
10003bfc:	781b      	ldrb	r3, [r3, #0]
10003bfe:	2b00      	cmp	r3, #0
10003c00:	d106      	bne.n	10003c10 <DAVE_Init+0x5c>
  {
	 /**  Initialization of GLOBAL_CCU4 APP instance GLOBAL_CCU4_0 */
	 init_status = (DAVE_STATUS_t)GLOBAL_CCU4_Init(&GLOBAL_CCU4_0); 
10003c02:	1dfc      	adds	r4, r7, #7
10003c04:	4b0e      	ldr	r3, [pc, #56]	; (10003c40 <DAVE_Init+0x8c>)
10003c06:	1c18      	adds	r0, r3, #0
10003c08:	f7fd fdd0 	bl	100017ac <GLOBAL_CCU4_Init>
10003c0c:	1c03      	adds	r3, r0, #0
10003c0e:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10003c10:	1dfb      	adds	r3, r7, #7
10003c12:	781b      	ldrb	r3, [r3, #0]
10003c14:	2b00      	cmp	r3, #0
10003c16:	d106      	bne.n	10003c26 <DAVE_Init+0x72>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_2); 
10003c18:	1dfc      	adds	r4, r7, #7
10003c1a:	4b0a      	ldr	r3, [pc, #40]	; (10003c44 <DAVE_Init+0x90>)
10003c1c:	1c18      	adds	r0, r3, #0
10003c1e:	f7ff ff49 	bl	10003ab4 <DIGITAL_IO_Init>
10003c22:	1c03      	adds	r3, r0, #0
10003c24:	7023      	strb	r3, [r4, #0]
   }  
  return init_status;
10003c26:	1dfb      	adds	r3, r7, #7
10003c28:	781b      	ldrb	r3, [r3, #0]
} /**  End of function DAVE_Init */
10003c2a:	1c18      	adds	r0, r3, #0
10003c2c:	46bd      	mov	sp, r7
10003c2e:	b003      	add	sp, #12
10003c30:	bd90      	pop	{r4, r7, pc}
10003c32:	46c0      	nop			; (mov r8, r8)
10003c34:	20002de0 	.word	0x20002de0
10003c38:	10003e28 	.word	0x10003e28
10003c3c:	10003e38 	.word	0x10003e38
10003c40:	20000550 	.word	0x20000550
10003c44:	10003e48 	.word	0x10003e48

10003c48 <XMC_GPIO_ToggleOutput>:
 * and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
10003c48:	b580      	push	{r7, lr}
10003c4a:	b082      	sub	sp, #8
10003c4c:	af00      	add	r7, sp, #0
10003c4e:	6078      	str	r0, [r7, #4]
10003c50:	1c0a      	adds	r2, r1, #0
10003c52:	1cfb      	adds	r3, r7, #3
10003c54:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
10003c56:	1cfb      	adds	r3, r7, #3
10003c58:	781b      	ldrb	r3, [r3, #0]
10003c5a:	4a03      	ldr	r2, [pc, #12]	; (10003c68 <XMC_GPIO_ToggleOutput+0x20>)
10003c5c:	409a      	lsls	r2, r3
10003c5e:	687b      	ldr	r3, [r7, #4]
10003c60:	605a      	str	r2, [r3, #4]
}
10003c62:	46bd      	mov	sp, r7
10003c64:	b002      	add	sp, #8
10003c66:	bd80      	pop	{r7, pc}
10003c68:	00010001 	.word	0x00010001

10003c6c <DIGITAL_IO_ToggleOutput>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
{
10003c6c:	b580      	push	{r7, lr}
10003c6e:	b082      	sub	sp, #8
10003c70:	af00      	add	r7, sp, #0
10003c72:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
10003c74:	687b      	ldr	r3, [r7, #4]
10003c76:	681a      	ldr	r2, [r3, #0]
10003c78:	687b      	ldr	r3, [r7, #4]
10003c7a:	7b1b      	ldrb	r3, [r3, #12]
10003c7c:	1c10      	adds	r0, r2, #0
10003c7e:	1c19      	adds	r1, r3, #0
10003c80:	f7ff ffe2 	bl	10003c48 <XMC_GPIO_ToggleOutput>
}
10003c84:	46bd      	mov	sp, r7
10003c86:	b002      	add	sp, #8
10003c88:	bd80      	pop	{r7, pc}
10003c8a:	46c0      	nop			; (mov r8, r8)

10003c8c <main>:
static void LED_Task0(void *pvParameters);
static void LED_Task1(void *pvParameters);
static void LED_Task2(void *pvParameters);

int main(void)
{
10003c8c:	b590      	push	{r4, r7, lr}
10003c8e:	b085      	sub	sp, #20
10003c90:	af02      	add	r7, sp, #8
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
10003c92:	1dfc      	adds	r4, r7, #7
10003c94:	f7ff ff8e 	bl	10003bb4 <DAVE_Init>
10003c98:	1c03      	adds	r3, r0, #0
10003c9a:	7023      	strb	r3, [r4, #0]

  if(status != DAVE_STATUS_SUCCESS)
10003c9c:	1dfb      	adds	r3, r7, #7
10003c9e:	781b      	ldrb	r3, [r3, #0]
10003ca0:	2b00      	cmp	r3, #0
10003ca2:	d000      	beq.n	10003ca6 <main+0x1a>
  {
    while(1U)
    {
    }
10003ca4:	e7fe      	b.n	10003ca4 <main+0x18>
  }


  /* Creating tasks defined within main.c */
  xTaskCreate(LED_Task0, "Task0", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 1), NULL);
10003ca6:	4915      	ldr	r1, [pc, #84]	; (10003cfc <main+0x70>)
10003ca8:	4a15      	ldr	r2, [pc, #84]	; (10003d00 <main+0x74>)
10003caa:	2301      	movs	r3, #1
10003cac:	9300      	str	r3, [sp, #0]
10003cae:	2300      	movs	r3, #0
10003cb0:	9301      	str	r3, [sp, #4]
10003cb2:	1c08      	adds	r0, r1, #0
10003cb4:	1c11      	adds	r1, r2, #0
10003cb6:	223c      	movs	r2, #60	; 0x3c
10003cb8:	2300      	movs	r3, #0
10003cba:	f7fe fe05 	bl	100028c8 <xTaskCreate>
  xTaskCreate(LED_Task1, "Task1", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 1), NULL);
10003cbe:	4911      	ldr	r1, [pc, #68]	; (10003d04 <main+0x78>)
10003cc0:	4a11      	ldr	r2, [pc, #68]	; (10003d08 <main+0x7c>)
10003cc2:	2301      	movs	r3, #1
10003cc4:	9300      	str	r3, [sp, #0]
10003cc6:	2300      	movs	r3, #0
10003cc8:	9301      	str	r3, [sp, #4]
10003cca:	1c08      	adds	r0, r1, #0
10003ccc:	1c11      	adds	r1, r2, #0
10003cce:	223c      	movs	r2, #60	; 0x3c
10003cd0:	2300      	movs	r3, #0
10003cd2:	f7fe fdf9 	bl	100028c8 <xTaskCreate>
  xTaskCreate(LED_Task2, "Task2", configMINIMAL_STACK_SIZE, NULL, (tskIDLE_PRIORITY + 1), NULL);
10003cd6:	490d      	ldr	r1, [pc, #52]	; (10003d0c <main+0x80>)
10003cd8:	4a0d      	ldr	r2, [pc, #52]	; (10003d10 <main+0x84>)
10003cda:	2301      	movs	r3, #1
10003cdc:	9300      	str	r3, [sp, #0]
10003cde:	2300      	movs	r3, #0
10003ce0:	9301      	str	r3, [sp, #4]
10003ce2:	1c08      	adds	r0, r1, #0
10003ce4:	1c11      	adds	r1, r2, #0
10003ce6:	223c      	movs	r2, #60	; 0x3c
10003ce8:	2300      	movs	r3, #0
10003cea:	f7fe fded 	bl	100028c8 <xTaskCreate>

  /* Start the RTOS scheduler, this function should not return as it causes the execution
  context to change from main() to one of the created tasks. */
  vTaskStartScheduler();
10003cee:	f7fe ff59 	bl	10002ba4 <vTaskStartScheduler>

  /* Should never reach here */
  return 0;
10003cf2:	2300      	movs	r3, #0
}
10003cf4:	1c18      	adds	r0, r3, #0
10003cf6:	46bd      	mov	sp, r7
10003cf8:	b003      	add	sp, #12
10003cfa:	bd90      	pop	{r4, r7, pc}
10003cfc:	10003d15 	.word	0x10003d15
10003d00:	10003e68 	.word	0x10003e68
10003d04:	10003d31 	.word	0x10003d31
10003d08:	10003e70 	.word	0x10003e70
10003d0c:	10003d4d 	.word	0x10003d4d
10003d10:	10003e78 	.word	0x10003e78

10003d14 <LED_Task0>:



/* Task 1 to toggle LED0, ensure DIGITAL_IO_0 is configured and connected to LED0 */
static void LED_Task0(void *pvParameters)
{
10003d14:	b580      	push	{r7, lr}
10003d16:	b082      	sub	sp, #8
10003d18:	af00      	add	r7, sp, #0
10003d1a:	6078      	str	r0, [r7, #4]
  while(1)
  {
    DIGITAL_IO_ToggleOutput(&DIGITAL_IO_0);
10003d1c:	4b03      	ldr	r3, [pc, #12]	; (10003d2c <LED_Task0+0x18>)
10003d1e:	1c18      	adds	r0, r3, #0
10003d20:	f7ff ffa4 	bl	10003c6c <DIGITAL_IO_ToggleOutput>
    vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for 1 second
10003d24:	200a      	movs	r0, #10
10003d26:	f7fe ff19 	bl	10002b5c <vTaskDelay>
    //one_minute_delay();
  }
10003d2a:	e7f7      	b.n	10003d1c <LED_Task0+0x8>
10003d2c:	10003e28 	.word	0x10003e28

10003d30 <LED_Task1>:
}

/* Task 2 to toggle LED1, ensure DIGITAL_IO_1 is configured and connected to LED1 */
static void LED_Task1(void *pvParameters)
{
10003d30:	b580      	push	{r7, lr}
10003d32:	b082      	sub	sp, #8
10003d34:	af00      	add	r7, sp, #0
10003d36:	6078      	str	r0, [r7, #4]
  while(1)
  {
    DIGITAL_IO_ToggleOutput(&DIGITAL_IO_1);
10003d38:	4b03      	ldr	r3, [pc, #12]	; (10003d48 <LED_Task1+0x18>)
10003d3a:	1c18      	adds	r0, r3, #0
10003d3c:	f7ff ff96 	bl	10003c6c <DIGITAL_IO_ToggleOutput>
    vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for 1 second
10003d40:	200a      	movs	r0, #10
10003d42:	f7fe ff0b 	bl	10002b5c <vTaskDelay>
  }
10003d46:	e7f7      	b.n	10003d38 <LED_Task1+0x8>
10003d48:	10003e38 	.word	0x10003e38

10003d4c <LED_Task2>:
}
static void LED_Task2(void *pvParameters)
{
10003d4c:	b580      	push	{r7, lr}
10003d4e:	b082      	sub	sp, #8
10003d50:	af00      	add	r7, sp, #0
10003d52:	6078      	str	r0, [r7, #4]
  while(1)
  {
    DIGITAL_IO_ToggleOutput(&DIGITAL_IO_2);
10003d54:	4b03      	ldr	r3, [pc, #12]	; (10003d64 <LED_Task2+0x18>)
10003d56:	1c18      	adds	r0, r3, #0
10003d58:	f7ff ff88 	bl	10003c6c <DIGITAL_IO_ToggleOutput>
    vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for 1 second
10003d5c:	200a      	movs	r0, #10
10003d5e:	f7fe fefd 	bl	10002b5c <vTaskDelay>
  }
10003d62:	e7f7      	b.n	10003d54 <LED_Task2+0x8>
10003d64:	10003e48 	.word	0x10003e48

10003d68 <__libc_init_array>:
10003d68:	4b0e      	ldr	r3, [pc, #56]	; (10003da4 <__libc_init_array+0x3c>)
10003d6a:	b570      	push	{r4, r5, r6, lr}
10003d6c:	2500      	movs	r5, #0
10003d6e:	1c1e      	adds	r6, r3, #0
10003d70:	4c0d      	ldr	r4, [pc, #52]	; (10003da8 <__libc_init_array+0x40>)
10003d72:	1ae4      	subs	r4, r4, r3
10003d74:	10a4      	asrs	r4, r4, #2
10003d76:	42a5      	cmp	r5, r4
10003d78:	d004      	beq.n	10003d84 <__libc_init_array+0x1c>
10003d7a:	00ab      	lsls	r3, r5, #2
10003d7c:	58f3      	ldr	r3, [r6, r3]
10003d7e:	4798      	blx	r3
10003d80:	3501      	adds	r5, #1
10003d82:	e7f8      	b.n	10003d76 <__libc_init_array+0xe>
10003d84:	f7fd fd02 	bl	1000178c <_init>
10003d88:	4b08      	ldr	r3, [pc, #32]	; (10003dac <__libc_init_array+0x44>)
10003d8a:	2500      	movs	r5, #0
10003d8c:	1c1e      	adds	r6, r3, #0
10003d8e:	4c08      	ldr	r4, [pc, #32]	; (10003db0 <__libc_init_array+0x48>)
10003d90:	1ae4      	subs	r4, r4, r3
10003d92:	10a4      	asrs	r4, r4, #2
10003d94:	42a5      	cmp	r5, r4
10003d96:	d004      	beq.n	10003da2 <__libc_init_array+0x3a>
10003d98:	00ab      	lsls	r3, r5, #2
10003d9a:	58f3      	ldr	r3, [r6, r3]
10003d9c:	4798      	blx	r3
10003d9e:	3501      	adds	r5, #1
10003da0:	e7f8      	b.n	10003d94 <__libc_init_array+0x2c>
10003da2:	bd70      	pop	{r4, r5, r6, pc}
10003da4:	20000568 	.word	0x20000568
10003da8:	20000568 	.word	0x20000568
10003dac:	20000568 	.word	0x20000568
10003db0:	20000568 	.word	0x20000568

10003db4 <memcpy>:
10003db4:	2300      	movs	r3, #0
10003db6:	b510      	push	{r4, lr}
10003db8:	4293      	cmp	r3, r2
10003dba:	d003      	beq.n	10003dc4 <memcpy+0x10>
10003dbc:	5ccc      	ldrb	r4, [r1, r3]
10003dbe:	54c4      	strb	r4, [r0, r3]
10003dc0:	3301      	adds	r3, #1
10003dc2:	e7f9      	b.n	10003db8 <memcpy+0x4>
10003dc4:	bd10      	pop	{r4, pc}

10003dc6 <memset>:
10003dc6:	1c03      	adds	r3, r0, #0
10003dc8:	1882      	adds	r2, r0, r2
10003dca:	4293      	cmp	r3, r2
10003dcc:	d002      	beq.n	10003dd4 <memset+0xe>
10003dce:	7019      	strb	r1, [r3, #0]
10003dd0:	3301      	adds	r3, #1
10003dd2:	e7fa      	b.n	10003dca <memset+0x4>
10003dd4:	4770      	bx	lr
10003dd6:	0000      	movs	r0, r0
10003dd8:	454c4449 	.word	0x454c4449
10003ddc:	00000000 	.word	0x00000000
10003de0:	09632509 	.word	0x09632509
10003de4:	25097525 	.word	0x25097525
10003de8:	75250975 	.word	0x75250975
10003dec:	00000a0d 	.word	0x00000a0d
10003df0:	20726d54 	.word	0x20726d54
10003df4:	00637653 	.word	0x00637653
10003df8:	51726d54 	.word	0x51726d54
10003dfc:	00000000 	.word	0x00000000
10003e00:	1000386a 	.word	0x1000386a
10003e04:	1000386a 	.word	0x1000386a
10003e08:	1000386a 	.word	0x1000386a
10003e0c:	100038de 	.word	0x100038de
10003e10:	100038f2 	.word	0x100038f2
10003e14:	1000392e 	.word	0x1000392e
10003e18:	1000386a 	.word	0x1000386a
10003e1c:	1000386a 	.word	0x1000386a
10003e20:	100038de 	.word	0x100038de
10003e24:	100038f2 	.word	0x100038f2

10003e28 <DIGITAL_IO_0>:
10003e28:	40040400 00000080 00010000 00000000     ...@............

10003e38 <DIGITAL_IO_1>:
10003e38:	40040400 00000080 00010000 00000001     ...@............

10003e48 <DIGITAL_IO_2>:
10003e48:	40040400 00000080 00010000 00000002     ...@............
10003e58:	00010000 03300000 00010000 00000000     ......0.........
10003e68:	6b736154 00000030 6b736154 00000031     Task0...Task1...
10003e78:	6b736154 00000032                       Task2...

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veener>:
/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
    
    .align 1
    
	Insert_InterruptVeener HardFault
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <IRQ31_Veener+0x4>)
2000000e:	4700      	bx	r0
	...

2000002c <SVC_Veener>:
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
	Insert_InterruptVeener SVC
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <IRQ31_Veener+0x8>)
2000002e:	4700      	bx	r0
	...

20000038 <PendSV_Veener>:
    .long 0
    .long 0
	Insert_InterruptVeener PendSV	
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <IRQ31_Veener+0xc>)
2000003a:	4700      	bx	r0

2000003c <SysTick_Veener>:
	Insert_InterruptVeener SysTick
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <IRQ31_Veener+0x10>)
2000003e:	4700      	bx	r0

20000040 <IRQ0_Veener>:
	
	Insert_InterruptVeener IRQ0	
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <IRQ31_Veener+0x14>)
20000042:	4700      	bx	r0

20000044 <IRQ1_Veener>:
	Insert_InterruptVeener IRQ1	
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <IRQ31_Veener+0x18>)
20000046:	4700      	bx	r0

20000048 <IRQ2_Veener>:
	Insert_InterruptVeener IRQ2	
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <IRQ31_Veener+0x1c>)
2000004a:	4700      	bx	r0

2000004c <IRQ3_Veener>:
	Insert_InterruptVeener IRQ3	
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <IRQ31_Veener+0x20>)
2000004e:	4700      	bx	r0

20000050 <IRQ4_Veener>:
	Insert_InterruptVeener IRQ4	
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <IRQ31_Veener+0x24>)
20000052:	4700      	bx	r0

20000054 <IRQ5_Veener>:
	Insert_InterruptVeener IRQ5	
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <IRQ31_Veener+0x28>)
20000056:	4700      	bx	r0

20000058 <IRQ6_Veener>:
	Insert_InterruptVeener IRQ6	
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <IRQ31_Veener+0x2c>)
2000005a:	4700      	bx	r0

2000005c <IRQ7_Veener>:
	Insert_InterruptVeener IRQ7	
2000005c:	4823      	ldr	r0, [pc, #140]	; (200000ec <IRQ31_Veener+0x30>)
2000005e:	4700      	bx	r0

20000060 <IRQ8_Veener>:
	Insert_InterruptVeener IRQ8	
20000060:	4823      	ldr	r0, [pc, #140]	; (200000f0 <IRQ31_Veener+0x34>)
20000062:	4700      	bx	r0

20000064 <IRQ9_Veener>:
	Insert_InterruptVeener IRQ9	
20000064:	4823      	ldr	r0, [pc, #140]	; (200000f4 <IRQ31_Veener+0x38>)
20000066:	4700      	bx	r0

20000068 <IRQ10_Veener>:
	Insert_InterruptVeener IRQ10	
20000068:	4823      	ldr	r0, [pc, #140]	; (200000f8 <IRQ31_Veener+0x3c>)
2000006a:	4700      	bx	r0

2000006c <IRQ11_Veener>:
	Insert_InterruptVeener IRQ11	
2000006c:	4823      	ldr	r0, [pc, #140]	; (200000fc <IRQ31_Veener+0x40>)
2000006e:	4700      	bx	r0

20000070 <IRQ12_Veener>:
	Insert_InterruptVeener IRQ12	
20000070:	4823      	ldr	r0, [pc, #140]	; (20000100 <IRQ31_Veener+0x44>)
20000072:	4700      	bx	r0

20000074 <IRQ13_Veener>:
	Insert_InterruptVeener IRQ13	
20000074:	4823      	ldr	r0, [pc, #140]	; (20000104 <IRQ31_Veener+0x48>)
20000076:	4700      	bx	r0

20000078 <IRQ14_Veener>:
	Insert_InterruptVeener IRQ14	
20000078:	4823      	ldr	r0, [pc, #140]	; (20000108 <IRQ31_Veener+0x4c>)
2000007a:	4700      	bx	r0

2000007c <IRQ15_Veener>:
	Insert_InterruptVeener IRQ15	
2000007c:	4823      	ldr	r0, [pc, #140]	; (2000010c <IRQ31_Veener+0x50>)
2000007e:	4700      	bx	r0

20000080 <IRQ16_Veener>:
	Insert_InterruptVeener IRQ16	
20000080:	4823      	ldr	r0, [pc, #140]	; (20000110 <IRQ31_Veener+0x54>)
20000082:	4700      	bx	r0

20000084 <IRQ17_Veener>:
	Insert_InterruptVeener IRQ17	
20000084:	4823      	ldr	r0, [pc, #140]	; (20000114 <IRQ31_Veener+0x58>)
20000086:	4700      	bx	r0

20000088 <IRQ18_Veener>:
	Insert_InterruptVeener IRQ18	
20000088:	4823      	ldr	r0, [pc, #140]	; (20000118 <IRQ31_Veener+0x5c>)
2000008a:	4700      	bx	r0

2000008c <IRQ19_Veener>:
	Insert_InterruptVeener IRQ19	
2000008c:	4823      	ldr	r0, [pc, #140]	; (2000011c <IRQ31_Veener+0x60>)
2000008e:	4700      	bx	r0

20000090 <IRQ20_Veener>:
	Insert_InterruptVeener IRQ20
20000090:	4823      	ldr	r0, [pc, #140]	; (20000120 <IRQ31_Veener+0x64>)
20000092:	4700      	bx	r0

20000094 <IRQ21_Veener>:
	Insert_InterruptVeener IRQ21
20000094:	4823      	ldr	r0, [pc, #140]	; (20000124 <IRQ31_Veener+0x68>)
20000096:	4700      	bx	r0

20000098 <IRQ22_Veener>:
	Insert_InterruptVeener IRQ22	
20000098:	4823      	ldr	r0, [pc, #140]	; (20000128 <IRQ31_Veener+0x6c>)
2000009a:	4700      	bx	r0

2000009c <IRQ23_Veener>:
	Insert_InterruptVeener IRQ23	
2000009c:	4823      	ldr	r0, [pc, #140]	; (2000012c <IRQ31_Veener+0x70>)
2000009e:	4700      	bx	r0

200000a0 <IRQ24_Veener>:
	Insert_InterruptVeener IRQ24	
200000a0:	4823      	ldr	r0, [pc, #140]	; (20000130 <IRQ31_Veener+0x74>)
200000a2:	4700      	bx	r0

200000a4 <IRQ25_Veener>:
	Insert_InterruptVeener IRQ25	
200000a4:	4823      	ldr	r0, [pc, #140]	; (20000134 <IRQ31_Veener+0x78>)
200000a6:	4700      	bx	r0

200000a8 <IRQ26_Veener>:
	Insert_InterruptVeener IRQ26	
200000a8:	4823      	ldr	r0, [pc, #140]	; (20000138 <IRQ31_Veener+0x7c>)
200000aa:	4700      	bx	r0

200000ac <IRQ27_Veener>:
	Insert_InterruptVeener IRQ27	
200000ac:	4823      	ldr	r0, [pc, #140]	; (2000013c <IRQ31_Veener+0x80>)
200000ae:	4700      	bx	r0

200000b0 <IRQ28_Veener>:
	Insert_InterruptVeener IRQ28	
200000b0:	4823      	ldr	r0, [pc, #140]	; (20000140 <IRQ31_Veener+0x84>)
200000b2:	4700      	bx	r0

200000b4 <IRQ29_Veener>:
	Insert_InterruptVeener IRQ29	
200000b4:	4823      	ldr	r0, [pc, #140]	; (20000144 <IRQ31_Veener+0x88>)
200000b6:	4700      	bx	r0

200000b8 <IRQ30_Veener>:
	Insert_InterruptVeener IRQ30	
200000b8:	4823      	ldr	r0, [pc, #140]	; (20000148 <IRQ31_Veener+0x8c>)
200000ba:	4700      	bx	r0

200000bc <IRQ31_Veener>:
	Insert_InterruptVeener IRQ31	
200000bc:	4823      	ldr	r0, [pc, #140]	; (2000014c <IRQ31_Veener+0x90>)
200000be:	4700      	bx	r0
/* ==================VENEERS VENEERS VENEERS VENEERS VENEERS=============== */
    .section ".XmcVeneerCode","ax",%progbits
    
    .align 1
    
	Insert_InterruptVeener HardFault
200000c0:	1000109d 	.word	0x1000109d
    .long 0
    .long 0
    .long 0
    .long 0
    .long 0
	Insert_InterruptVeener SVC
200000c4:	1000186d 	.word	0x1000186d
    .long 0
    .long 0
	Insert_InterruptVeener PendSV	
200000c8:	10001991 	.word	0x10001991
	Insert_InterruptVeener SysTick
200000cc:	100019e1 	.word	0x100019e1
	
	Insert_InterruptVeener IRQ0	
200000d0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ1	
200000d4:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ2	
200000d8:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ3	
200000dc:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ4	
200000e0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ5	
200000e4:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ6	
200000e8:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ7	
200000ec:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ8	
200000f0:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ9	
200000f4:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ10	
200000f8:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ11	
200000fc:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ12	
20000100:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ13	
20000104:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ14	
20000108:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ15	
2000010c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ16	
20000110:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ17	
20000114:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ18	
20000118:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ19	
2000011c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ20
20000120:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ21
20000124:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ22	
20000128:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ23	
2000012c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ24	
20000130:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ25	
20000134:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ26	
20000138:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ27	
2000013c:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ28	
20000140:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ29	
20000144:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ30	
20000148:	1000109d 	.word	0x1000109d
	Insert_InterruptVeener IRQ31	
2000014c:	1000109d 	.word	0x1000109d
